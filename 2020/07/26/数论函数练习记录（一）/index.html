<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>数论函数练习记录（一） - xyfJASON</title><link rel="manifest" href="/blog-xcpc/manifest.json"><meta name="application-name" content="xyfJASON-xcpc"><meta name="msapplication-TileImage" content="/logo/myfavicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="xyfJASON-xcpc"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="参考资料：oi-wiki 莫比乌斯反演｜oi-wiki 筛法｜oi-wiki 欧拉函数｜blog｜blog"><meta property="og:type" content="blog"><meta property="og:title" content="数论函数练习记录（一）"><meta property="og:url" content="http://xyfjason.github.io/blog-xcpc/2020/07/26/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"><meta property="og:site_name" content="xyfJASON"><meta property="og:description" content="参考资料：oi-wiki 莫比乌斯反演｜oi-wiki 筛法｜oi-wiki 欧拉函数｜blog｜blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://xyfjason.github.io/blog-xcpc/gallery/pexels_numbers1.jpg"><meta property="article:published_time" content="2020-07-26T10:40:44.000Z"><meta property="article:modified_time" content="2021-02-25T03:48:21.547Z"><meta property="article:author" content="xyfJASON"><meta property="article:tag" content="学习笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/blog-xcpc/gallery/pexels_numbers1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://xyfjason.github.io/blog-xcpc/2020/07/26/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"},"headline":"数论函数练习记录（一）","image":["http://xyfjason.github.io/blog-xcpc/gallery/pexels_numbers1.jpg"],"datePublished":"2020-07-26T10:40:44.000Z","dateModified":"2021-02-25T03:48:21.547Z","author":{"@type":"Person","name":"xyfJASON"},"publisher":{"@type":"Organization","name":"xyfJASON","logo":{"@type":"ImageObject","url":"http://xyfjason.github.io/logo/logo.png"}},"description":"参考资料：oi-wiki 莫比乌斯反演｜oi-wiki 筛法｜oi-wiki 欧拉函数｜blog｜blog"}</script><link rel="canonical" href="http://xyfjason.github.io/blog-xcpc/2020/07/26/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"><link rel="icon" href="/blog-xcpc/logo/myfavicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog-xcpc/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog-xcpc/"><img src="/blog-xcpc/logo/logo.png" alt="xyfJASON" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog-xcpc/">Home</a><a class="navbar-item" href="/blog-xcpc/archives">Archives</a><a class="navbar-item" href="/blog-xcpc/categories">Categories</a><a class="navbar-item" href="/blog-xcpc/tags">Tags</a><a class="navbar-item" href="/blog-xcpc/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/xyfjason"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/blog-xcpc/gallery/pexels_numbers1.jpg" alt="数论函数练习记录（一）"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-26T10:40:44.000Z" title="2020/7/26 下午6:40:44">2020-07-26</time>发表</span><span class="level-item"><time dateTime="2021-02-25T03:48:21.547Z" title="2021/2/25 上午11:48:21">2021-02-25</time>更新</span><span class="level-item"><a class="link-muted" href="/blog-xcpc/categories/ICPC-CCPC/">ICPC/CCPC</a><span> / </span><a class="link-muted" href="/blog-xcpc/categories/ICPC-CCPC/Exercises/">Exercises</a></span><span class="level-item">32 分钟读完 (大约4754个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">数论函数练习记录（一）</h1><div class="content"><p>参考资料：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/mobius/">oi-wiki 莫比乌斯反演</a>｜<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/sieve/">oi-wiki 筛法</a>｜<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/euler/">oi-wiki 欧拉函数</a>｜<a target="_blank" rel="noopener" href="https://www.cnblogs.com/heyujun/p/10179497.html">blog</a>｜<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">blog</a> </p>
<span id="more"></span>
<h2 id="CQOI2007-余数求和"><a href="#CQOI2007-余数求和" class="headerlink" title="[CQOI2007]余数求和"></a>[CQOI2007]余数求和</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2261">题目链接</a> </p>
<p>这道题主要是练习<strong>数论分块</strong>。</p>
<script type="math/tex; mode=display">
G(n,k)=\sum_{i=1}^nk\bmod i=\sum_{i=1}^nk-i\cdot\left\lfloor\frac{k}{i}\right\rfloor=nk-\sum_{i=1}^ni\cdot\left\lfloor\frac{k}{i}\right\rfloor</script><p>减号后面的值进行数论分块，每一块是常数 $\left\lfloor\frac{k}{l}\right\rfloor$ 乘以一个等差数列求和 $l+\cdots+r=\frac{(l+r)(r-l+1)}{2}$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, k, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	ans = <span class="number">1ll</span> * n * k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k / l == <span class="number">0</span>)	r = n;</span><br><span class="line">		<span class="keyword">else</span>	r = <span class="built_in">min</span>(n, k / (k / l));</span><br><span class="line">		ans -= (k / l) * (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="POI2007-ZAP-Queries"><a href="#POI2007-ZAP-Queries" class="headerlink" title="[POI2007]ZAP-Queries"></a>[POI2007]ZAP-Queries</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3455">题目链接</a> </p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=k]&=\sum_{i=1}^n\sum_{j=1}^m\left[\gcd\left(\frac{i}{k},\frac{j}{k}\right)=1\right]&&\gcd(i,j)=k\iff\gcd\left(\frac{i}{k},\frac{j}{k}\right)=1\\
&=\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[\gcd(i,j)=1]&&i\to ki,\;j\to kj\\
&=\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}\epsilon\left(\gcd(i,j)\right)&&写作单位元函数\\
&=\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}\sum_{d\mid\gcd(i,j)}\mu(d)&&\epsilon=\mu*1\;并展开\\
&=\sum_{d=1}^{\min\left(\left\lfloor\frac{n}{k}\right\rfloor,\left\lfloor\frac{m}{k}\right\rfloor\right)}\sum_{i=1}^{\left\lfloor\frac{n}{kd}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{kd}\right\rfloor}\mu(d)&&求和号换序并置\;i\to di,\,j\to dj\\
&=\sum_{d=1}^{\min\left(\left\lfloor\frac{n}{k}\right\rfloor,\left\lfloor\frac{m}{k}\right\rfloor\right)}\mu(d)\left\lfloor\frac{n}{kd}\right\rfloor\left\lfloor\frac{m}{kd}\right\rfloor
\end{align}</script><p>接下来进行数论分块，每一块是常数 $\left\lfloor\frac{n}{kl}\right\rfloor\left\lfloor\frac{m}{kl}\right\rfloor$ 乘上 $\mu(l)+\cdots+\mu(r)$，前缀和预处理即可。</p>
<p>这里 $r$ 的计算：$\left\lfloor\frac{n}{kl}\right\rfloor=\left\lfloor\frac{n}{kr}\right\rfloor\leqslant\frac{n}{kr}\implies r\leqslant\frac{\frac{n}{k}}{\left\lfloor\frac{n}{kl}\right\rfloor}\implies r=\left\lfloor\frac{\frac{n}{k}}{\left\lfloor\frac{n}{kl}\right\rfloor}\right\rfloor$. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], pList[N], pID, muS[N];</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)	pList[++pID] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				mu[i * pList[j]] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	mu[i * pList[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	muS[i] = muS[i<span class="number">-1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= <span class="built_in">min</span>(n / k, m / k); l = r + <span class="number">1</span>)&#123;</span><br><span class="line">		r = <span class="built_in">min</span>((n / k) / ((n / k) / l), (m / k) / ((m / k) / l));</span><br><span class="line">		res += <span class="number">1ll</span> * (muS[r] - muS[l<span class="number">-1</span>]) * (n / k / l) * (m / k / l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">50000</span>);</span><br><span class="line">	<span class="keyword">int</span> T; <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T; T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;k);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">calc</span>(a, b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="HAOI2011-Problem-b"><a href="#HAOI2011-Problem-b" class="headerlink" title="[HAOI2011]Problem b"></a>[HAOI2011]Problem b</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2522">题目链接</a> </p>
<p>通过二维前缀和就可以把问题转换成上一道题。</p>
<p>不能乱开 <code>long long</code>，否则常数太大会 <code>TLE</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], pList[N], pID, muS[N];</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)	pList[++pID] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				mu[i * pList[j]] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	mu[i * pList[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	muS[i] = muS[i<span class="number">-1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= <span class="built_in">min</span>(n / k, m / k); l = r + <span class="number">1</span>)&#123;</span><br><span class="line">		r = <span class="built_in">min</span>((n / k) / ((n / k) / l), (m / k) / ((m / k) / l));</span><br><span class="line">		res += <span class="number">1ll</span> * (muS[r] - muS[l<span class="number">-1</span>]) * (n / k / l) * (m / k / l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">50000</span>);</span><br><span class="line">	<span class="keyword">int</span> T; <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T; T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c, d; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">calc</span>(b, d) - <span class="built_in">calc</span>(a<span class="number">-1</span>, d) - <span class="built_in">calc</span>(b, c<span class="number">-1</span>) + <span class="built_in">calc</span>(a<span class="number">-1</span>, c<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="SPOJ5971-LCMSUM"><a href="#SPOJ5971-LCMSUM" class="headerlink" title="[SPOJ5971]LCMSUM"></a>[SPOJ5971]LCMSUM</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/SPOJ-LCMSUM">题目链接</a> </p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\text{lcm(i,n)}&=\sum_{i=1}^n\frac{i\cdot n}{\gcd(i,n)}=n+\sum_{i=1}^{n-1}\frac{i\cdot n}{\gcd(i,n)}=n+\sum_{i=1}^{n-1}\frac{(n-i)\cdot n}{\gcd(n-i,n)}&&根据对称性做变换\;i\to n-i\\
&=n+\frac{1}{2}\sum_{i=1}^{n-1}\frac{n^2}{\gcd(i,n)}=\frac{n}{2}+\frac{1}{2}\sum_{i=1}^n\frac{n^2}{\gcd(i,n)}&&根据\;\gcd(i,n)=\gcd(n-i,n)\;进行合并\\
&=\frac{n}{2}+\frac{n^2}{2}\sum_{d\mid n}\frac{\varphi\left(\frac{n}{d}\right)}{d}&&枚举\;\gcd(i,n)\;的值，乘上\;\gcd(i,n)=d\;的个数，\\&&&即\;\gcd(i/d,n/d)=1\;的个数，即\;\varphi(n/d)\\
&=\frac{n}{2}+\frac{n^2}{2}\sum_{d\mid n}\frac{d\cdot\varphi(d)}{n}=\frac{n}{2}\left(\sum_{d\mid n}d\cdot\varphi(d)+1\right)&&根据对称性做变换\;d\to\frac{n}{d}
\end{align}</script><p>令 $g(n)=\sum\limits_{d\mid n}d\cdot\varphi(d)$，如果我们可以预处理出 $g(n)$，那么我们就可以 $O(1)$ 回答了。我们这样预处理：枚举 $i$，将所有 $i\mid n$ 的 $g(n)$ 加上贡献 $i\cdot\varphi(i)$，这样预处理的复杂度是调和级数，其阶为 $O(n\lg n)$. 【<strong>这种预处理方式很重要！</strong>】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line">LL g[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)	pList[++pID] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				phi[i * pList[j]] = phi[i] * pList[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	phi[i * pList[j]] = phi[i] * (pList[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">1000000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i * j &lt;= <span class="number">1000000</span>; j++)</span><br><span class="line">			g[i*j] += <span class="number">1ll</span> * i * phi[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T; T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (g[n] + <span class="number">1</span>) * n / <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="国家集训队-Crash的数字表格"><a href="#国家集训队-Crash的数字表格" class="headerlink" title="[国家集训队]Crash的数字表格"></a>[国家集训队]Crash的数字表格</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1829">题目链接</a> </p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\sum_{j=1}^m\text{lcm}(i,j)&=\sum_{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{\gcd(i,j)}\\
&=\sum_{d=1}^{\min(n,m)}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}[\gcd(i,j)=1]d\cdot i\cdot j&&考虑\;d=\gcd(i,j)\;的贡献，并置\;i\to di,\,j\to dj\\
&=\sum_{d=1}^{\min(n,m)}d\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\epsilon(\gcd(i,j))\cdot i\cdot j&&写作单位元函数\\
&=\sum_{d=1}^{\min(n,m)}d\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\sum_{r\mid\gcd(i,j)}\mu(r)\cdot i\cdot j&&\epsilon=1*\mu\;并展开\\
&=\sum_{d=1}^{\min(n,m)}d\sum_{r=1}^{\min\left(\left\lfloor\frac{n}{d}\right\rfloor,\left\lfloor\frac{m}{d}\right\rfloor\right)}\sum_{i=1}^{\left\lfloor\frac{n}{dr}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dr}\right\rfloor}r^2\mu(r)\cdot i\cdot j&&经典的求和号换序并置\;i\to ri,\,j\to rj\\
&=\sum_{d=1}^{\min(n,m)}d\sum_{r=1}^{\min\left(\left\lfloor\frac{n}{d}\right\rfloor,\left\lfloor\frac{m}{d}\right\rfloor\right)}r^2\mu(r)\sum_{i=1}^{\left\lfloor\frac{n}{dr}\right\rfloor}i\sum_{j=1}^{\left\lfloor\frac{m}{dr}\right\rfloor}j\\
&=\sum_{d=1}^{\min(n,m)}d\sum_{r=1}^{\min\left(\left\lfloor\frac{n}{d}\right\rfloor,\left\lfloor\frac{m}{d}\right\rfloor\right)}r^2\mu(r)\cdot\frac{\left(\left\lfloor\frac{n}{dr}\right\rfloor+1\right)\left\lfloor\frac{n}{dr}\right\rfloor}{2}\cdot\frac{\left(\left\lfloor\frac{m}{dr}\right\rfloor+1\right)\left\lfloor\frac{m}{dr}\right\rfloor}{2}&&后两项是独立的，可求和
\end{align}</script><p>我们设</p>
<script type="math/tex; mode=display">
S(n,m)=\sum_{r=1}^{\min(n,m)}r^2\mu(r)\cdot\frac{\left(\left\lfloor\frac{n}{r}\right\rfloor+1\right)\left\lfloor\frac{n}{r}\right\rfloor}{2}\cdot\frac{\left(\left\lfloor\frac{m}{r}\right\rfloor+1\right)\left\lfloor\frac{m}{r}\right\rfloor}{2}</script><p>它是可以通过<strong>数论分块</strong>计算的，每一块是常数 $\frac{\left(\left\lfloor\frac{n}{l}\right\rfloor+1\right)\left\lfloor\frac{n}{l}\right\rfloor}{2}\cdot\frac{\left(\left\lfloor\frac{m}{l}\right\rfloor+1\right)\left\lfloor\frac{m}{l}\right\rfloor}{2}$ 乘上 $l^2\mu(l)+\cdots+r^2\mu(r)$，前缀和预处理即可。</p>
<p>那么原式可写作：</p>
<script type="math/tex; mode=display">
\sum_{d=1}^{\min(n,m)}d\cdot S\left(\left\lfloor\frac{n}{d}\right\rfloor,\left\lfloor\frac{m}{d}\right\rfloor\right)</script><p>而它又是一个可以<strong>数论分块</strong>计算的，每一块是常数 $S\left(\left\lfloor\frac{n}{l}\right\rfloor,\left\lfloor\frac{m}{l}\right\rfloor\right)$ 乘上 $l+\cdots+r=\frac{(l+r)(r-l+1)}{2}$. </p>
<p>所以这道题是数论分块的<strong>嵌套</strong>，复杂度为 $O(\sqrt n\cdot\sqrt n)=O(n)$. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000005</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">20101009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)	pList[++pID] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				mu[i * pList[j]] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	mu[i * pList[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		sum[i] = (sum[i<span class="number">-1</span>] + <span class="number">1ll</span> * i * i % MOD * mu[i] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n &gt; m)	<span class="built_in">swap</span>(n, m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">		r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">		res += <span class="number">1ll</span> * (<span class="number">1</span> + n / l) * (n / l) % MOD * (<span class="number">1</span> + m / l) % MOD * (m / l) % MOD * ((sum[r] - sum[l<span class="number">-1</span>]) % MOD + MOD) % MOD * <span class="number">15075757</span> % MOD;</span><br><span class="line">		res %= MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">10000000</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">if</span>(n &gt; m)	<span class="built_in">swap</span>(n, m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> dl = <span class="number">1</span>, dr; dl &lt;= n; dl = dr + <span class="number">1</span>)&#123;</span><br><span class="line">		dr = <span class="built_in">min</span>(n / (n / dl), m / (m / dl));</span><br><span class="line">		ans += (<span class="number">1ll</span> * (dl + dr) * (dr - dl + <span class="number">1</span>) % MOD * <span class="number">10050505</span> % MOD) * <span class="built_in">S</span>(n / dl, m / dl) % MOD;</span><br><span class="line">		ans %= MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这道题还能继续优化：先鸽一下（雾</p>
<hr>
<h2 id="luoguP2398-GCD-SUM"><a href="#luoguP2398-GCD-SUM" class="headerlink" title="[luoguP2398]GCD SUM"></a>[luoguP2398]GCD SUM</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2398">题目链接</a> </p>
<p><strong>解法一</strong>：和上一道题差不多。</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)&=\sum_{d=1}^n\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}d[\gcd(i,j)=1]&&考虑\;d=\gcd(i,j)\;的贡献，并置\;i\to di,\,j\to dj\\
&=\sum_{d=1}^nd\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{r\mid \gcd(i,j)}\mu(r)&&写作单位元函数并展开\\
&=\sum_{d=1}^nd\sum_{r=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{i=1}^{\left\lfloor\frac{n}{dr}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{dr}\right\rfloor}\mu(r)&&求和号换序并置\;i\to ri,\,j\to rj\\
&=\sum_{d=1}^nd\sum_{r=1}^{\left\lfloor\frac{n}{d}\right\rfloor}{\left\lfloor\frac{n}{dr}\right\rfloor}^2\mu(r)
\end{align}</script><p>数论分块嵌套。</p>
<p>复杂度：$O(n)$ </p>
<p><strong>解法二</strong>：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)&=\sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j))*1(\gcd(i,j))&&由\;\text{id}=\varphi*1\\
&=\sum_{i=1}^n\sum_{j=1}^n\sum_{d\mid\gcd(i,j)}\varphi(d)&&把卷积打开\\
&=\sum_{d=1}^n\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\varphi(d)&&求和号换序并置\;i\to di,\,j\to dj\\
&=\sum_{d=1}^n{\left\lfloor\frac{n}{d}\right\rfloor}^2\varphi(d)
\end{align}</script><p>数论分块。</p>
<p>复杂度：$O(\sqrt n)$ （不算线性筛）</p>
<p>注：其实解法一继续推导可得解法二的表达式，不过推导的下一步不是很显然（要卷回去）：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{d=1}^nd\sum_{r=1}^{\left\lfloor\frac{n}{d}\right\rfloor}{\left\lfloor\frac{n}{dr}\right\rfloor}^2\mu(r)&=\sum_{d=1}^nd\sum_{r=1}^{n}[d\mid r]{\left\lfloor\frac{n}{r}\right\rfloor}^2\mu\left(\frac{r}{d}\right)&&置\;r\to\frac{r}{d}\\
&=\sum_{r=1}^n{\left\lfloor\frac{n}{r}\right\rfloor}^2\sum_{d\mid r}\text{id}(d)\cdot\mu\left(\frac{r}{d}\right)&&求和号换序\\
&=\sum_{r=1}^n{\left\lfloor\frac{n}{r}\right\rfloor}^2\varphi(r)&&由\;\text{id}*\mu=\varphi
\end{align}</script><p>这个<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/An-Amazing-Blog/ji-miao-di-mu-bi-wu-si-fan-yan">博客</a>讲的也是这个，并给这种方法起了个名字叫做欧拉反演，哈哈。</p>
<p>解法一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			pList[++pID] = i;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				mu[i * pList[j]] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	mu[i * pList[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, muS[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">100000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++)	muS[i] = muS[i<span class="number">-1</span>] + mu[i];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> dl = <span class="number">1</span>, dr; dl &lt;= n; dl = dr + <span class="number">1</span>)&#123;</span><br><span class="line">		dr = n / (n / dl);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n / dl; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">			r = (n / dl) / (n / dl / l);</span><br><span class="line">			res += <span class="number">1ll</span> * (muS[r] - muS[l<span class="number">-1</span>]) * (n / dl / l) * (n / dl / l);</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="number">1ll</span> * (dl + dr) * (dr - dl + <span class="number">1</span>) / <span class="number">2</span> * res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			pList[++pID] = i;</span><br><span class="line">			phi[i] = i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				phi[i * pList[j]] = phi[i] * pList[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	phi[i * pList[j]] = phi[i] * (pList[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> phiS[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">100000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++)	phiS[i] = phiS[i<span class="number">-1</span>] + phi[i];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">		r = n / (n / l);</span><br><span class="line">		ans += <span class="number">1ll</span> * (phiS[r] - phiS[l<span class="number">-1</span>]) * (n / l) * (n / l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="NOI2010-能量采集"><a href="#NOI2010-能量采集" class="headerlink" title="[NOI2010]能量采集"></a>[NOI2010]能量采集</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1447">题目链接</a> </p>
<p>题目要求的就是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m\left(2\gcd(i,j)-1\right)=2\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)-nm</script><p>和上一题一样了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			pList[++pID] = i;</span><br><span class="line">			phi[i] = i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				phi[i * pList[j]] = phi[i] * pList[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	phi[i * pList[j]] = phi[i] * (pList[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> phiS[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">100000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++)	phiS[i] = phiS[i<span class="number">-1</span>] + phi[i];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="keyword">if</span>(n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">		r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">		ans += <span class="number">1ll</span> * (phiS[r] - phiS[l<span class="number">-1</span>]) * (n / l) * (m / l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">2</span> * ans - <span class="number">1ll</span> * n * m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="SDOI2015-约数个数和"><a href="#SDOI2015-约数个数和" class="headerlink" title="[SDOI2015]约数个数和"></a>[SDOI2015]约数个数和</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3327">题目链接</a> </p>
<p>引理：</p>
<script type="math/tex; mode=display">
d(i\cdot j)=\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)=1]</script><p>证明：约数个数公式：$d(n)=d\left(\prod\limits_{i=1}^k{p_i}^{r_i}\right)=\prod\limits_{i=1}^k(r_i+1)$。考虑 $ij$ 的一个质因子 $p$，设 $i=i’\cdot{p}^{r_i}$ ，$j=j’\cdot{p}^{r_j}$，则 $p$ 对答案有 $r_i+r_j+1$ 的贡献。又考虑右边的式子，由于 $\gcd(x,y)=1$ 的约束，$p$ 只能从 $i$ 或 $j$ 其中一边取出，或者不取出，贡献仍是 $r_i+r_j+1$。证毕。</p>
<p>于是：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\sum_{j=1}^md(i\cdot j)&=\sum_{i=1}^n\sum_{j=1}^m\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)=1]&&由引理\\
&=\sum_{x=1}^n\sum_{y=1}^m\sum_{i=1}^{\left\lfloor\frac{n}{x}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{y}\right\rfloor}\epsilon(\gcd(x,y))&&求和号换序并置\;i\to xi,\,j\to yj\\
&=\sum_{x=1}^n\sum_{y=1}^m{\left\lfloor\frac{n}{x}\right\rfloor}{\left\lfloor\frac{m}{y}\right\rfloor}\sum_{d\mid\gcd(x,y)}\mu(d)&&\epsilon=\mu*1\;并展开，i\,和\,j\,的和式计算出来\\
&=\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{y=1}^{\left\lfloor\frac{m}{d}\right\rfloor}{\left\lfloor\frac{n}{dx}\right\rfloor}{\left\lfloor\frac{m}{dy}\right\rfloor}\mu(d)&&求和号换序并置\;x\to dx,\,y\to dy\\
&=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}{\left\lfloor\frac{n}{dx}\right\rfloor}\sum_{y=1}^{\left\lfloor\frac{m}{d}\right\rfloor}{\left\lfloor\frac{m}{dy}\right\rfloor}\\
&=\sum_{d=1}^{\min(n,m)}\mu(d)\cdot S\left(\left\lfloor\frac{n}{d}\right\rfloor\right)\cdot S\left(\left\lfloor\frac{m}{d}\right\rfloor\right)&&设\,S(i)=\sum_{r=1}^i\left\lfloor\frac{i}{r}\right\rfloor
\end{align}</script><p>$S(1…n)$ 可以通过<strong>数论分块</strong> $O(n\sqrt n)$ 地预处理出来，随后上式可通过<strong>数论分块</strong> $O(\sqrt n)$ 地回答。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			pList[++pID] = i;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				mu[i * pList[j]] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	mu[i * pList[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, muS[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">50000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50000</span>; i++)	muS[i] = muS[i<span class="number">-1</span>] + mu[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50000</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= i; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">			r = i / (i / l);</span><br><span class="line">			S[i] += (r - l + <span class="number">1</span>) * (i / l);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T; T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">if</span>(n &gt; m)	<span class="built_in">swap</span>(n, m);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> dl = <span class="number">1</span>, dr; dl &lt;= n; dl = dr + <span class="number">1</span>)&#123;</span><br><span class="line">			dr = <span class="built_in">min</span>(n / (n / dl), m / (m / dl));</span><br><span class="line">			ans += <span class="number">1ll</span> * (muS[dr] - muS[dl<span class="number">-1</span>]) * S[n / dl] * S[m / dl];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="luoguP2257-YY的GCD"><a href="#luoguP2257-YY的GCD" class="headerlink" title="[luoguP2257]YY的GCD"></a>[luoguP2257]YY的GCD</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2257">题目链接</a> </p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=\text{prime}]&=\sum_{p=1}^{\min(n,m)}\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=p]\quad(p\in\text{prime})&&枚举质数\;p\\
&=\sum_{p=1}^{\min(n,m)}\sum_{d=1}^{\min\left(\left\lfloor\frac{n}{p}\right\rfloor,\left\lfloor\frac{m}{p}\right\rfloor\right)}\mu(d)\left\lfloor\frac{n}{pd}\right\rfloor\left\lfloor\frac{m}{pd}\right\rfloor\quad(p\in\text{prime})&&和之前做过的题目一样的推导\\
&=\sum_{T=1}^{\min(n,m)}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor\sum_{p\mid T}\mu\left(\frac{T}{p}\right)\quad(p\in\text{prime})&&置\;T=pd\\
\end{align}</script><p><strong>最后一步的代换非常重要</strong>！详细逻辑如下：</p>
<script type="math/tex; mode=display">
\sum\limits_{p=1}^{\min(n,m)}\sum\limits_{d=1}^{\min\left(\left\lfloor\frac{n}{p}\right\rfloor,\left\lfloor\frac{m}{p}\right\rfloor\right)}f(p,d)=\sum\limits_{1\leqslant p\cdot d\leqslant\min(n,m)}f(p,d)\overset{T=p\cdot d}{===}\sum\limits_{T=1}^{\min(n,m)}\sum\limits_{p\mid T}f\left(p,\frac{T}{p}\right)</script><p>然后令 $g(T)=\sum\limits_{p\mid T}{\mu\left(\frac{T}{p}\right)}\quad(p\in\text{prime})$，这是可以<strong>预处理</strong>的，即枚举质数 $p$，将 $p\mid n$ 的 $g(n)$ 加上贡献 $\mu\left(\frac{n}{p}\right)$，复杂度是 $O(n\cdot H(n))\sim O(n\lg n)$ </p>
<p>随后数论分块，每一块是常数 $\left\lfloor\frac{n}{l}\right\rfloor\left\lfloor\frac{m}{l}\right\rfloor$ 乘上 $g(l)+\cdots+g(r)$，前缀和预处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			pList[++pID] = i;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				mu[i * pList[j]] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	mu[i * pList[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">10000000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pID; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = pList[i]; j &lt;= <span class="number">10000000</span>; j += pList[i])</span><br><span class="line">			g[j] += mu[j / pList[i]];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000000</span>; i++)	g[i] += g[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">int</span> T; <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T; T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="keyword">if</span>(n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">			r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">			ans += <span class="number">1ll</span> * (g[r] - g[l<span class="number">-1</span>]) * (n / l) * (m / l);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="luoguP2586-GCD"><a href="#luoguP2586-GCD" class="headerlink" title="[luoguP2586]GCD"></a>[luoguP2586]GCD</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2568">题目链接</a> </p>
<p>求的东西和上一道题基本一样，但是没有多组数据，时限加紧。</p>
<p>注意上一道题为了 $O(\sqrt n)$ 地回答而进行了 $O(n\lg n)$ 的预处理，这个预处理在这道题里会超时。但是这道题只需要 $O(n)$ 回答就行了。</p>
<p>重新推一波式子：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=\text{prime}]&=\sum_{p=1}^{n}\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=p]\quad(p\in\text{prime})&&枚举质数\;p\\
&=\sum_{p=1}^n\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{p}\right\rfloor}[\gcd(i,j)=1]\quad(p\in\text{prime})&&置\;i\to pi,\,j\to pj\\
&=\sum_{p=1}^n\left(2\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j=1}^{i}[\gcd(i,j)=1]-1\right)\quad(p\in\text{prime})&&由 \gcd 的对称性\\
&=\sum_{p=1}^n\left(2\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\varphi(i)-1\right)\quad(p\in\text{prime})&&由\;\varphi(n)\;的定义式
\end{align}</script><p>预处理 $\varphi(n)$ 的前缀和，就可以 $O(n)$ 解决了。</p>
<p>上面的推导中最妙的一点是用上了 $\varphi(n)=\sum\limits_{i=1}^n[\gcd(i,n)=1]$ 这个<strong>定义式</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[N], pList[N], pID;</span><br><span class="line"><span class="keyword">bool</span> notP[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	notP[<span class="number">0</span>] = notP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(notP[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			pList[++pID] = i;</span><br><span class="line">			phi[i] = i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pID; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * i * pList[j] &gt; n)	<span class="keyword">break</span>;</span><br><span class="line">			notP[i * pList[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pList[j] == <span class="number">0</span>)&#123;</span><br><span class="line">				phi[i * pList[j]] = phi[i] * pList[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	phi[i * pList[j]] = phi[i] * (pList[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> phiS[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Euler</span>(<span class="number">10000000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000000</span>; i++)	phiS[i] = phiS[i<span class="number">-1</span>] + phi[i];</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; pList[i] &lt;= n; i++)</span><br><span class="line">		ans += <span class="number">2</span> * phiS[n / pList[i]] - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>数论函数练习记录（一）</p><p><a href="http://xyfjason.github.io/blog-xcpc/2020/07/26/数论函数练习记录（一）/">http://xyfjason.github.io/blog-xcpc/2020/07/26/数论函数练习记录（一）/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>xyfJASON</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-07-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-02-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/blog-xcpc/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/blog-xcpc/2020/07/27/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%85%AD%E5%9C%BA%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">2020牛客暑期多校训练营（第六场）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/blog-xcpc/2020/07/26/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-item">数论函数学习笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "ovQ7Ukrh29Ex4n5TKqN19d5D-MdYXbMMI",
            appKey: "bGKUwhryO4w9EE9TcpEaOKGF",
            placeholder: "Please leave your footprints",
            avatar: "monsterid",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/blog-xcpc/logo/myavatar.png" alt="xufJASON"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">xufJASON</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen, Guangdong</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/blog-xcpc/archives"><p class="title">109</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/blog-xcpc/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/blog-xcpc/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyfjason" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyfjason"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Home" href="https://xyfjason.github.io"><i class="fa fa-home"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/"><span class="level-start"><span class="level-item">ICPC/CCPC</span></span><span class="level-end"><span class="level-item tag">108</span></span></a><ul><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/Contests/"><span class="level-start"><span class="level-item">Contests</span></span><span class="level-end"><span class="level-item tag">70</span></span></a><ul><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/Contests/CCPC/"><span class="level-start"><span class="level-item">CCPC</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/Contests/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">45</span></span></a></li><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/Contests/ICPC2020/"><span class="level-start"><span class="level-item">ICPC2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/Contests/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li></ul></li><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/Exercises/"><span class="level-start"><span class="level-item">Exercises</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile" href="/blog-xcpc/categories/ICPC-CCPC/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li><li><a class="level is-mobile" href="/blog-xcpc/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-04T14:40:30.000Z">2021-07-04</time></p><p class="title"><a href="/blog-xcpc/2021/07/04/Nowcoder17797E-2021%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9B-Excellent-Number/">[Nowcoder17797E][2021广东省赛] Excellent Number</a></p><p class="categories"><a href="/blog-xcpc/categories/ICPC-CCPC/">ICPC/CCPC</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Exercises/">Exercises</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-11T02:29:07.000Z">2021-06-11</time></p><p class="title"><a href="/blog-xcpc/2021/06/11/Codeforces-Round-678-Div-2/">Codeforces Round #678 (Div.2)</a></p><p class="categories"><a href="/blog-xcpc/categories/ICPC-CCPC/">ICPC/CCPC</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Contests/">Contests</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Contests/Codeforces/">Codeforces</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-21T13:05:14.000Z">2021-05-21</time></p><p class="title"><a href="/blog-xcpc/2021/05/21/Codeforces-Round-721-Div-2/">Codeforces Round #721 (Div.2)</a></p><p class="categories"><a href="/blog-xcpc/categories/ICPC-CCPC/">ICPC/CCPC</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Contests/">Contests</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Contests/Codeforces/">Codeforces</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-19T14:43:13.000Z">2021-05-19</time></p><p class="title"><a href="/blog-xcpc/2021/05/19/CF833B-The-Bakery/">[CF833B] The Bakery</a></p><p class="categories"><a href="/blog-xcpc/categories/ICPC-CCPC/">ICPC/CCPC</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Exercises/">Exercises</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-19T06:44:41.000Z">2021-05-19</time></p><p class="title"><a href="/blog-xcpc/2021/05/19/ICPC-2020-%E9%93%B6%E5%B7%9D%E7%AB%99%E5%8E%9F%E5%9C%B0%E7%88%86%E7%82%B8%E8%AE%B0/">ICPC-2020 银川站原地爆炸记</a></p><p class="categories"><a href="/blog-xcpc/categories/ICPC-CCPC/">ICPC/CCPC</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Contests/">Contests</a> / <a href="/blog-xcpc/categories/ICPC-CCPC/Contests/ICPC2020/">ICPC2020</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/AtCoder/"><span class="tag">AtCoder</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/CCPC/"><span class="tag">CCPC</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/Codeforces/"><span class="tag">Codeforces</span><span class="tag">57</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/EOJ/"><span class="tag">EOJ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/GMCPC/"><span class="tag">GMCPC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/HDU/"><span class="tag">HDU</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/ICPC/"><span class="tag">ICPC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/Nowcoder/"><span class="tag">Nowcoder</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/POI/"><span class="tag">POI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/hihoCoder/"><span class="tag">hihoCoder</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">学习笔记</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/blog-xcpc/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog-xcpc/"><img src="/blog-xcpc/logo/logo.png" alt="xyfJASON" height="28"></a><p class="is-size-7"><span>&copy; 2021 xyfJASON</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/blog-xcpc/js/column.js"></script><script src="/blog-xcpc/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/blog-xcpc/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/blog-xcpc/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog-xcpc/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog-xcpc/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>