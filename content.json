{"pages":[{"title":"关于我","text":"休对故人思故国，且将新火试新茶。诗酒趁年华。 Introduction高中：成都七中 本科：哈尔滨工业大学（深圳） Blog本博客的内容包括： ICPC/CCPC 学习笔记、题解、比赛游记； 随笔。 OI 生涯旧博客：链接 基于 hexo+github 搭建，采用 icarus 主题。","link":"/blog-xcpc/about/index.html"}],"posts":[{"title":"[2019 ICPC 南京F]Paper Grading","text":"题目链接 Solution对 $s_1,s_2,\\ldots,s_n$ 建一棵 Trie 树，每个 Trie 树的节点上是一棵线段树。首先这样考虑：在加入 $s_i$ 时，它在 Trie 树上会经过一系列节点，把这些节点的线段树的第 $i$ 个位置均加 $1$，那么询问时，我们只需要沿着 Trie 树找到第 $k$ 个节点，询问这个节点上的线段树中区间 $[l,r]$ 的和是多少。但是这样做的问题在于交换 $s_i,s_j$ 时，我们需要修改两条串经过的路径上的全部线段树，这样的时间开销无疑是不行的。 总的来看，现在的操作是：在 Trie 树上进行路径修改、单点查询。采用树上差分，那么操作可以变为单点修改、子树查询。于是再用一个树状数组维护 dfs 序即可。 所以这道题是 Trie 树的 dfs 序上建树状数组套值域线段树。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, m, nowid[N], en[N];string s[N];int tot;struct segTree{ int lson, rson, size;}tr[N*150];inline void pushup(int id){ tr[id].size = tr[tr[id].lson].size + tr[tr[id].rson].size;}void add(int id, int l, int r, int pos, int val){ if(l == r){ tr[id].size += val; return; } int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid){ if(!tr[id].lson) tr[id].lson = ++tot; add(tr[id].lson, l, mid, pos, val); } else{ if(!tr[id].rson) tr[id].rson = ++tot; add(tr[id].rson, mid+1, r, pos, val); } pushup(id);}int sum(int id, int l, int r, int L, int R){ if(id == 0) return 0; if(l == L &amp;&amp; r == R) return tr[id].size; int mid = (l + r) &gt;&gt; 1; if(R &lt;= mid) return sum(tr[id].lson, l, mid, L, R); else if(L &gt; mid) return sum(tr[id].rson, mid+1, r, L, R); else return sum(tr[id].lson, l, mid, L, mid) + sum(tr[id].rson, mid+1, r, mid+1, R);}struct Trie{ int ch[26], root; // cntEnd can be changed according to different problem}trie[N];#define trie_root 0int trie_tot;void insertTrie(string s, int id){ int len = s.size(); int now = trie_root; for(int i = 0; i &lt; len; i++){ if(!trie[now].ch[s[i]-'a']){ trie[now].ch[s[i]-'a'] = ++trie_tot; trie[trie_tot].root = ++tot; } now = trie[now].ch[s[i]-'a']; } en[id] = now;}int st[N], ed[N], dfsClock, fdfn[N];void dfsTrie(int x){ st[x] = ++dfsClock; fdfn[dfsClock] = x; for(int i = 0; i &lt; 26; i++) if(trie[x].ch[i]) dfsTrie(trie[x].ch[i]); ed[x] = dfsClock;}inline int lowbit(int x){ return x &amp; -x; }void addBIT(int x, int pos, int val){ while(x &lt;= trie_tot + 1){ add(trie[fdfn[x]].root, 1, n, pos, val); x += lowbit(x); }}int sumBIT(int x, int l, int r){ int res = 0; while(x){ res += sum(trie[fdfn[x]].root, 1, n, l, r); x -= lowbit(x); } return res;}void addstr(int id, int pos, int val){ addBIT(st[en[id]], pos, val);}int solve(string s, int l, int r, int k){ int now = trie_root; for(int i = 0; i &lt; k; i++){ now = trie[now].ch[s[i]-'a']; if(!now) return 0; } return sumBIT(ed[now], l, r) - sumBIT(st[now]-1, l, r);}int main(){ trie[trie_root].root = ++tot; read(n, m); for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; s[i]; insertTrie(s[i], nowid[i] = i); } dfsTrie(trie_root); for(int i = 1; i &lt;= n; i++) addstr(i, i, 1); while(m--){ int opt; read(opt); if(opt == 1){ int i, j; read(i, j); addstr(nowid[i], i, -1), addstr(nowid[j], j, -1); addstr(nowid[i], j, 1), addstr(nowid[j], i, 1); swap(nowid[i], nowid[j]); } else{ string t; int k, l, r; cin &gt;&gt; t; read(k, l, r); printf(&quot;%d\\n&quot;, solve(t, l, r, k)); } } return 0;}","link":"/blog-xcpc/2021/05/05/2019-ICPC-%E5%8D%97%E4%BA%ACF-Paper-Grading/"},{"title":"[2019 ICPC 南昌K]Tree","text":"题目链接 SolutionDSU on tree. DSU on tree 就是加上了启发式合并的暴力，只需要想好怎么暴力做就行了。 考虑如何求以 $rt$ 为 $\\text{lca}$ 的满足条件的点对 $(x,y)$ 的数量，即 $v_x+v_y=2\\cdot v_{rt}$ 及 $dep_x+dep_y-2\\cdot dep_{rt}\\leqslant k$. 考虑对每一个值 $v$ 都用数据结构维护值为 $v$ 的点的深度，那么依次扫描 $rt$ 的子树，枚举到 $x$ 时，数据结构里已经存入了之前子树的信息，只需要在维护 $2\\cdot v_{rt}-v_x$ 的数据结构里找到满足 $d\\leqslant k+2\\cdot dep_{rt}-dep_x$ 的深度 $d$ 有多少个，然后扫描完这棵子树后将它上面的信息存入数据结构。可以对每个值开动态开点线段树完成这个操作，线段树的下标表示深度。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, v[N], k, root[N];LL ans;vector&lt;int&gt; edge[N];int sz[N], son[N], dep[N];void dfs(int x, int d){ sz[x] = 1, son[x] = 0, dep[x] = d; for(auto &amp;to : edge[x]){ dfs(to, d+1); sz[x] += sz[to]; if(!son[x] || sz[to] &gt; sz[son[x]]) son[x] = to; }}int tot;struct segTree{ int lson, rson, cnt;}tr[N*200];inline void pushup(int rt){ tr[rt].cnt = tr[tr[rt].lson].cnt + tr[tr[rt].rson].cnt;}void add(int rt, int l, int r, int p, int val){ if(l == r){ tr[rt].cnt += val; return; } int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid){ if(!tr[rt].lson) tr[rt].lson = ++tot; add(tr[rt].lson, l, mid, p, val); } else{ if(!tr[rt].rson) tr[rt].rson = ++tot; add(tr[rt].rson, mid+1, r, p, val); } pushup(rt);}LL query(int rt, int l, int r, int L, int R){ if(rt == 0) return 0; if(L &gt; R) return 0; if(l == L &amp;&amp; r == R) return tr[rt].cnt; int mid = (l + r) &gt;&gt; 1; if(R &lt;= mid) return query(tr[rt].lson, l, mid, L, R); else if(L &gt; mid) return query(tr[rt].rson, mid+1, r, L, R); else return query(tr[rt].lson, l, mid, L, mid) + query(tr[rt].rson, mid+1, r, mid+1, R);}void getAns(int x, int rtx){ if(2*v[rtx]-v[x] &gt;= 0 &amp;&amp; 2*v[rtx]-v[x] &lt;= n) ans += query(root[2*v[rtx]-v[x]], 1, n, 1, min(n, k + 2 * dep[rtx] - dep[x])); // dep[x] + d - 2 * dep[rtx] &lt;= k for(auto &amp;to : edge[x]) getAns(to, rtx);}void getData(int x){ add(root[v[x]], 1, n, dep[x], 1); for(auto &amp;to : edge[x]) getData(to);}void delData(int x){ add(root[v[x]], 1, n, dep[x], -1); for(auto &amp;to : edge[x]) delData(to);}void dsu(int x, bool opt){ for(auto &amp;to : edge[x]){ if(to == son[x]) continue; dsu(to, true); } if(son[x]) dsu(son[x], false); for(auto &amp;to : edge[x]){ if(to == son[x]) continue; getAns(to, x); getData(to); } if(opt){ for(auto &amp;to : edge[x]) delData(to); } else add(root[v[x]], 1, n, dep[x], 1);}int main(){ read(n, k); for(int i = 1; i &lt;= n; i++) read(v[i]); for(int i = 2; i &lt;= n; i++){ int f; read(f); edge[f].emplace_back(i); } dfs(1, 1); for(int i = 0; i &lt;= n; i++) root[i] = ++tot; dsu(1, true); printf(&quot;%lld\\n&quot;, ans * 2); return 0;}","link":"/blog-xcpc/2021/05/01/2019-ICPC-%E5%8D%97%E6%98%8CK-Tree/"},{"title":"2020杭电多校（第七场）","text":"比赛链接 收获 互质的数对分布的很稠密 递归思想可以用在构造题中 1007 Game我们倒着考虑，先手要赢，最长的那条边必须由先手走（或者走不到），于是乎次长的边必须由先手走（或者走不到），于是乎第三长的边……因此，如果第 $1$ 个点和其他某个点进行了匹配，则先手胜；否则先手负。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2005;int T, n, sid;LL x[N], y[N];struct Segment{ LL x, y, dis; bool operator &lt; (const Segment &amp;A) const{ return dis &gt; A.dis; }}s[N*N];inline LL dis2(int a, int b){ return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(x[i], y[i]); sid = 0; vector&lt;int&gt; vis(n+5, 0); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt; i; j++) s[++sid] = (Segment){j, i, dis2(i, j)}; sort(s+1, s+sid+1); for(int i = 1, bl = 1, sum = 0; sum &lt;= n - 2; i++, bl++){ while(i &lt;= sid &amp;&amp; (vis[s[i].x] || vis[s[i].y])) i++; if(i == sid + 1) break; for(int k = i; k &lt;= sid; k++){ if(s[k].dis != s[i].dis){ i = k; break; } if (vis[s[k].x] == 0 &amp;&amp; vis[s[k].y] == 0) vis[s[k].x] = bl, vis[s[k].y] = bl, sum += 2; else if (vis[s[k].x] == 0 &amp;&amp; vis[s[k].y] == bl) vis[s[k].y] = bl, ++sum; else if(vis[s[k].y] == 0 &amp;&amp; vis[s[k].x] == bl) vis[s[k].y] = bl, ++sum; } } bool ok = false; for(int i = 2; i &lt;= n; i++){ if(vis[i] == vis[1]){ ok = true; break; } } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} 1009 Increasing and Decreasing对于 ${1,2,\\cdots,n}$，要得到长度为 $y$ 的最长下降子序列，将后 $y$ 个数翻转；现在要得到长度为 $x$ 的最长上升子序列，只需要把前 $n-y$ 个数分割成 $x-1$ 段，每一段长度 $\\leqslant y$，每一段分别翻转。为了保证字典序最小，尽可能使靠前的段长度小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, x, y, ans[N];bool solve(int pos, int k){ if(pos &lt; k) return false; if(pos &gt; 1ll * k * y) return false; if(pos == k) return true; if(k == 1){ reverse(ans + 1, ans + pos + 1); return true; } int len = min(y, pos - k + 1); reverse(ans + pos - len + 1, ans + pos + 1); return solve(pos - len, k - 1);}int main(){ for(read(T); T; T--){ read(n, x, y); for(int i = 1; i &lt;= n; i++) ans[i] = i; reverse(ans + n - y + 1, ans + n + 1); int now = n-y; if(solve(now, x - 1)){ puts(&quot;YES&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d%c&quot;, ans[i], &quot; \\n&quot;[i==n]); } else puts(&quot;NO&quot;); } return 0;} 1010 Jogging打个表可以发现，互质的数对分布的很稠密，只要从 $(x,y)$ 出发不走到对角线 $(i,i)$，走到的点就是有穷且较少的。 答案就是起点的度数除以能走到的点的度数和（这里说的“度数”指的是能到达的点的数量，包括自己） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 998244353;const int N = 105;LL gcd(LL a, LL b){ return b == 0 ? a : gcd(b, a % b); }inline int z(LL x, LL y){ int res = 0; for(int i = -1; i &lt;= 1; i++) for(int j = -1; j &lt;= 1; j++) if(!(i == 0 &amp;&amp; j == 0)) res += (gcd(x+i, y+j) &gt; 1); return res;}bool inf;int sum = 0;map&lt;pair&lt;LL, LL&gt;, bool&gt; vis;void dfs(LL x, LL y){ if(inf) return; if(x == y){ inf = true; return; } vis[mp(x,y)] = true; sum += 1 + z(x,y); for(int i = -1; i &lt;= 1; i++){ for(int j = -1; j &lt;= 1; j++){ if(i == 0 &amp;&amp; j == 0) continue; if(gcd(x+i,y+j) &lt;= 1) continue; if(!vis[mp(x+i,y+j)]) dfs(x+i,y+j); } }}int main(){ int T; for(read(T); T; T--){ LL x, y; read(x, y); inf = false; sum = 0; vis.clear(); dfs(x, y); if(inf) puts(&quot;0/1&quot;); else{ int up = 1 + z(x,y); int g = gcd(up, sum); sum /= g; up /= g; printf(&quot;%d/%d\\n&quot;, up, sum); } } return 0;}","link":"/blog-xcpc/2020/08/11/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E4%B8%83%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第一场）","text":"比赛链接 收获 对图可以进行分块：按照度数将点分为“大点”和“小点”——大点是度数 $&gt;\\sqrt n$ 的点，不超过 $\\sqrt n$ 个；小点是度数 $\\leqslant \\sqrt n$ 的点。 1004 Distinct Sub-palindromes 当 $n=1$ 时，答案是 $26$，即所有字母； 当 $n=2$ 时，答案是 $26\\times26$，即所有字母任意组合，不同回文子串数为 $2$; 当 $n=3$ 时，答案是 $26\\times26\\times26$，即所有字母任意组合，不同回文子串数为 $3$； 当 $n\\geqslant4$ 时，答案是 $A_{26}^3=26\\times25\\times24$。首先考虑 $n=4$ 的情况，此时，我们可以用三个字母构造出不同回文子串数为 $3$ 的序列：$abca$，当固定了前三个位置填 $a,b,c$ 后，第四个位置只能填 $a$，因此是 $A_{26}^3$ 种；考虑 $n=5$，会发现在 $abca$ 的基础上只能填 $b$ 才能仍然保持不同回文子串数为 $3$；同理可推得，要使不同回文子串数保持为 $3$，只能 $abcabcabc\\cdots$，因此 $n\\geqslant4$ 时答案都是 $A_{26}^3$。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n;int main(){ for(read(T); T; T--){ read(n); if(n == 1) puts(&quot;26&quot;); else if(n == 2) puts(&quot;676&quot;); else if(n == 3) printf(&quot;%d\\n&quot;, 26*26*26); else printf(&quot;%d\\n&quot;, 26*25*24); } return 0;} 1005 Fibonacci Sum$\\textbf{Fibonacci}$ 数列通项公式：$$F_n=\\frac{1}{\\sqrt 5}\\left({\\left(\\frac{1+\\sqrt 5}{2}\\right)}^n-{\\left(\\frac{1-\\sqrt 5}{2}\\right)}^n\\right)$$$\\sqrt 5$ 在模意义下就是 $x^2\\equiv 5\\pmod p$ 的解，二次剩余解之得到：$x=383008016$. 记 $A=\\frac{1+\\sqrt5}{2},,B=\\frac{1-\\sqrt 5}{2},,D=\\frac{1}{\\sqrt 5}$，那么 $F_n=D(A^n-B^n)$. 喜闻乐见的推式子时间：$$\\begin{align}\\sum_{i=0}^N{(F_{iC})}^K&amp;=\\sum_{i=0}^ND^K{(A^{iC}-B^{iC})}^K\\&amp;=D^K\\sum_{i=0}^N\\sum_{j=0}^K\\binom{K}{j} A^{iCj}B^{iC(K-j)}{(-1)}^{K-j}&amp;&amp;二项式展开\\&amp;=D^K\\sum_{j=0}^K{(-1)}^{K-j}\\binom{K}{j}\\sum_{i=0}^N {(A^{Cj}B^{C(K-j)})}^i&amp;&amp;求和号换序\\&amp;=D^K\\sum_{j=0}^K{(-1)}^{K-j}\\binom{K}{j}\\left({\\begin{cases}\\frac{1-E_j^i}{1-E_j},&amp;E_j\\neq1\\N+1,&amp;E_j=1\\end{cases}}\\right)&amp;&amp;等比数列求和，记;E_j=A^{Cj}B^{C(K-j)}\\end{align}$$枚举 $j$ 即可。 不过此题卡常，可以有两个常数优化： 快速幂的时候指数降幂； 从 $E_j$ 到 $E_{j+1}$ 可以 $O(1)$ 递推，不需要 $O(\\lg 10^9)$ 重新计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 1e9+9;const LL _5 = 383008016;const LL inv2 = 500000005;const LL A = 691504013;const LL B = 308495997;const LL D = 276601605;inline LL fpow(LL bs, LL idx){ bs %= MOD, idx %= (MOD - 1); LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}LL N, C; int K;LL fact[100005] = {1}, invfact[100005] = {1};int main(){ for(int i = 1; i &lt;= 100000; i++){ fact[i] = fact[i-1] * i % MOD; invfact[i] = fpow(fact[i], MOD-2); } int T; for(read(T); T; T--){ read(N, C, K); LL ans = 0; LL Ac = fpow(A, C), Bc = fpow(B, C), Ec = Ac * fpow(Bc, MOD-2) % MOD; LL E = fpow(Bc, K); for(int j = 0; j &lt;= K; j++){ LL binom = fact[K] * invfact[j] % MOD * invfact[K-j] % MOD; if((K - j) &amp; 1) binom = MOD - binom; if(E == 1) ans += (N + 1) % MOD * binom % MOD; else ans += binom * (fpow(E, N+1) - 1) % MOD * fpow(E - 1, MOD-2) % MOD; ans = ((ans % MOD) + MOD) % MOD; E = E * Ec % MOD; } ans = ans * fpow(D, K) % MOD; printf(&quot;%lld\\n&quot;, ans); } return 0;} 1006 Finding a MEX按照度数将点分为“大点”和“小点”——大点是度数 $&gt;\\sqrt n$ 的点，不超过 $\\sqrt n$ 个；小点是度数 $\\leqslant \\sqrt n$ 的点。对于小点，每次询问直接暴力统计，复杂度 $O(\\sqrt n)$；对于大点，我们维护一个值域树状数组，存储与它相邻的点的值，那么求 $\\text{MEX}$ 可以在树状数组上二分。考虑如何维护：每次更改一个点的值时，就更新与之相邻的大点的树状数组，由于大点不超过 $\\sqrt n$ 个，所以一次更改操作也是 $O(\\sqrt n)$ 的，这样复杂度就得到了保证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)inline int lowbit(int x){ return x &amp; -x; }inline void add(vi &amp;c, vi&amp;b, int n, int x, int val){ if(x &gt; n) return; b[x] += val; if(val == 1 &amp;&amp; b[x] == 1){ while(x &lt;= n){ c[x] += val; x += lowbit(x); } } else if(val == -1 &amp;&amp; b[x] == 0){ while(x &lt;= n){ c[x] += val; x += lowbit(x); } }}inline int sum(vi&amp;c, int n, int x){ int res = 0; while(x){ res += c[x]; x -= lowbit(x); } return res;}inline int mex(vi&amp;c, int n){ int l = 1, r = n; while(l &lt; r){ int mid = (l + r) &gt;&gt; 1; if(sum(c, n, mid) &lt; mid) r = mid; else l = mid + 1; } return l;}const int N = 100005;int T, n, m, a[N];int main(){ for(read(T); T; T--){ read(n, m); int sq = sqrt(n); vector&lt;vi&gt; edge(n+1, vi()), adjBig(n+1, vi()); vi deg(n+1, 0); for(int i = 1; i &lt;= n; i++) read(a[i]), a[i]++; for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); deg[u]++, deg[v]++; } vector&lt;vi&gt; c(n+1, vi()), b(n+1, vi()); for(int i = 1; i &lt;= n; i++){ if(deg[i] &gt; sq){ c[i].resize(deg[i]+2); b[i].resize(deg[i]+2); for(auto &amp;to : edge[i]) adjBig[to].pb(i); } } for(int i = 1; i &lt;= n; i++) for(auto &amp;k : adjBig[i]) add(c[k], b[k], deg[k]+1, a[i], 1); int q; for(read(q); q; q--){ int opt, u; read(opt, u); if(opt == 1){ for(auto &amp;k : adjBig[u]) add(c[k], b[k], deg[k]+1, a[u], -1); int x; read(x); x++; a[u] = x; for(auto &amp;k : adjBig[u]) add(c[k], b[k], deg[k]+1, x, 1); } else{ if(deg[u] &gt; sq) printf(&quot;%d\\n&quot;, mex(c[u], deg[u]+1) - 1); else{ vi r(deg[u]+1); for(auto &amp;k : edge[u]) if(a[k] &lt;= deg[u] + 1) r[a[k]]++; int res = 0; for(res = 1; res &lt;= deg[u] + 1; res++){ if(r[res] == 0){ printf(&quot;%d\\n&quot;, res - 1); break; } } } } } } return 0;} 1009 Leading Robots首先，那些 $a,p$ 均比某个机器人小的机器人可以扔掉不管了。然后，由于超过别人的机器人一定是 $a$ 更大的，所以我们可以按照 $a$ 升序排序，又已经剔掉了 $a,p$ 均比别人小的机器人，所以现在 $p$ 是降序的。考虑 $t=0$ 时领先的那个机器人（排序后的第一个元素），我们只需要往后找到谁第一个超过它，那么谁就领先，随后再往后找谁第一个超过现在领先的机器人……如此解决问题。 设排序后的机器人序列为：${x_1,x_2,\\cdots,x_n}$，则机器人 $x_3$ 先于 $x_2$ 超过 $x_1$ 的充要条件是：$1,3$ 相遇的时间小于 $1,2$ 相遇的时间，即 $\\sqrt{\\frac{2(p_1-p_3)}{a_3-a_1}}&lt;\\sqrt{\\frac{2(p_1-p_2)}{a_2-a_1}}$，即 $\\frac{p_1-p_3}{a_3-a_1}&lt;\\frac{p_1-p_2}{a_2-a_1}$，乘出来后用行列式表达就是：$\\begin{vmatrix}1&amp;1&amp;1\\a_1&amp;a_2&amp;a_3\\p_1&amp;p_2&amp;p_3\\end{vmatrix}&gt;0$。注意到，假设点 $X_1(a_1,p_1),,X_2(a_2,p_2),,X_3(a_3,p_3)$，那么上述行列式就是 $\\Delta X_1X_2X_3$ 的有向面积。换句话说，$x_3$ 比 $x_2$ 先超过 $x_1$ 的充要条件是 $\\overrightarrow{X_1X_3}$ 在 $\\overrightarrow{X_1X_2}$ 的左侧。那么，我们把这些点 $X_i(a_i,p_i)$ 画出来就会发现，答案其实就是求一个凸包（当然处理一下两个机器人重合的特殊情况）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;const LL INF = 1e14;const int N = 50100;//------------------------------------ Vector &amp; Point ------------------------------------//struct Vector{ LL x, y; int id; Vector() {} Vector(LL x, LL y):x(x), y(y){ id = -1; }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector(A.x + B.x, A.y + B.y); }Vector operator - (Vector A, Vector B){ return Vector(A.x - B.x, A.y - B.y); }Vector operator * (LL k, Vector A){ return Vector(k * A.x, k * A.y); }bool operator &lt; (const Vector &amp;A, const Vector &amp;B){ return A.x == B.x ? A.y &lt; B.y : A.x &lt; B.x;}bool operator == (const Vector &amp;A, const Vector &amp;B){ return A.x == B.x &amp;&amp; A.y == B.y; }// dot productLL operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; }// cross productLL operator ^ (Vector A, Vector B){ return A.x * B.y - A.y * B.x; }//------------------------------------------------------------------------------////------------------------------------ Convex Hull ------------------------------------//void ConvexHull(int n, Point p[], Point sta[], int &amp;staid){ // there're n points stored in p[], the points on convex hull will be saved in sta[] sort(p+1, p+n+1); n = unique(p+1, p+n+1) - (p+1); staid = 0; for(int i = 1; i &lt;= n; i++){ // points on edge // while(staid &gt; 1 &amp;&amp; ((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt; 0) staid--; // no points on edge while(staid &gt; 1 &amp;&amp; ((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt;= 0) staid--; sta[++staid] = p[i]; } int k = staid; for(int i = n-1; i &gt;= 1; i--){ // points on edge // while(staid &gt; k &amp;&amp; ((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt; 0) staid--; // no points on edge while(staid &gt; k &amp;&amp; ((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt;= 0) staid--; sta[++staid] = p[i]; } if(n &gt; 1) staid--;}int T, n;Point p[N], ch[N];int main(){ for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt;= n + 5; i++) p[i].x = p[i].y = 0, p[i].id = -1; LL mxy = -INF, mxx = -INF; for(int i = 1; i &lt;= n; i++){ scanf(&quot;%lld%lld&quot;, &amp;p[i].y, &amp;p[i].x); p[i].id = i; mxy = max(mxy, p[i].y); mxx = max(mxx, p[i].x); } p[++n] = Point(0, 0); p[++n] = Point(0, mxy); p[++n] = Point(mxx, 0); sort(p+1, p+n+1); for(int i = 2; i &lt;= n; i++) if(p[i] == p[i-1]) p[i].id = p[i-1].id = -1; int tot = 0; ConvexHull(n, p, ch, tot); int ans = 0; for(int i = 1; i &lt;= tot; i++) if(ch[i].id != -1) ans++; printf(&quot;%d\\n&quot;, ans); } return 0;} 1012 Mow这就是一个半平面交的经典题啊，类似 poj3384。 如果 $B\\geqslant A$，就全部手动打扫；否则，就用机器打扫它能打扫的所有位置，即圆在这个多边形内部能覆盖的最大面积，然后手动打扫剩下的位置。把所有边往里面移动 $r$，半平面交得到圆心可以到达的区域，那么圆能覆盖的面积就是这个区域面积加上该区域各条边支出去的小矩形面积再加上一个整圆的面积。 只是这道题估计造了些 corner cases 的数据，尽管它保证了逆时针或顺时针输入一个凸多边形，但是直接用总会 WA。后来干脆先求凸包再做就 AC 了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const double eps = 1e-14;const double PI = 4 * atan2(1, 1);const double INF = 1e16;const int N = 1005;inline int sgn(double x){ if(fabs(x) &lt; eps) return 0; else if(x &gt; 0) return 1; else return -1;}inline int cmp(double x, double y){ return sgn(x-y); }//------------------------------------ Vector &amp; Point ------------------------------------//struct Vector{ double x, y; Vector() {} Vector(double x, double y):x(x), y(y){} void read(){ scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector(A.x + B.x, A.y + B.y); }Vector operator - (Vector A, Vector B){ return Vector(A.x - B.x, A.y - B.y); }Vector operator * (double k, Vector A){ return Vector(k * A.x, k * A.y); }Vector operator * (Vector A, double k){ return k * A; }bool operator &lt; (const Vector &amp;A, const Vector &amp;B){ return cmp(A.x, B.x) == 0 ? cmp(A.y, B.y) &lt; 0 : cmp(A.x, B.x) &lt; 0;}bool operator == (const Vector &amp;A, const Vector &amp;B){ return (cmp(A.x, B.x) == 0) &amp;&amp; (cmp(A.y, B.y) == 0); }// dot productdouble operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; }// cross productdouble operator ^ (Vector A, Vector B){ return A.x * B.y - A.y * B.x; }double Length(Vector A){ return sqrt(A * A); }// get the normal vector of AVector Normal(Vector A){ double L = Length(A); return Vector(-A.y/L, A.x/L); }//------------------------------------------------------------------------------////------------------------------------ Line ------------------------------------//struct Line{ Point p; Vector v; double ang; // angle of inclination (-PI, PI] Line() {} Line(Point p, Vector v):p(p), v(v){ ang = atan2(v.y, v.x); } Line(double a, double b, double c){ // ax + by + c = 0 if(sgn(a) == 0) p = Point(0, -c/b), v = Vector(1, 0); else if(sgn(b) == 0) p = Point(-c/a, 0), v = Vector(0, 1); else p = Point(0, -c/b), v = Vector(-b, a); } Point getPoint(double t){ return p + v * t; } bool operator &lt; (const Line &amp;L) const{ return ang &lt; L.ang; }};bool PointOnRight(Point p, Line l){ return sgn(l.v ^ (p-l.p)) &lt; 0; }Point GetLineIntersection(Line l1, Line l2){ Vector u = l1.p - l2.p; double t = (l2.v ^ u) / (l1.v ^ l2.v); return l1.p + l1.v * t;}double PolygonArea(int n, Point p[]){ double S = 0; for(int i = 2; i &lt; n; i++) S += ((p[i] - p[1]) ^ (p[i+1] - p[1])) / 2; return S;}void ConvexHull(int n, Point p[], Point sta[], int &amp;staid){ // there're n points stored in p[], the points on convex hull will be saved in sta[] sort(p+1, p+n+1); n = unique(p+1, p+n+1) - (p+1); staid = 0; for(int i = 1; i &lt;= n; i++){ // points on edge // while(staid &gt; 1 &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt; 0) staid--; // no points on edge while(staid &gt; 1 &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt;= 0) staid--; sta[++staid] = p[i]; } int k = staid; for(int i = n-1; i &gt;= 1; i--){ // points on edge // while(staid &gt; k &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt; 0) staid--; // no points on edge while(staid &gt; k &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt;= 0) staid--; sta[++staid] = p[i]; } if(n &gt; 1) staid--;}//------------------------------------ HalfplaneIntersection ------------------------------------//struct Halfplane{ Point P[N]; // P[i] is the intersection of line Q[i] and Q[i+1] Line Q[N]; // deque void HalfplaneIntersection(Line L[], int n, Point res[], int &amp;m){ // L[] are the lines, n is the number of lines, res[] stores the result of the intersection (a polygon) // m is the number of points of the intersection (which is a polygon) sort(L + 1, L + n + 1); int head, tail; Q[head = tail = 0] = L[1]; for(int i = 2; i &lt;= n; i++){ while(head &lt; tail &amp;&amp; PointOnRight(P[tail - 1], L[i])) tail--; while(head &lt; tail &amp;&amp; PointOnRight(P[head], L[i])) head++; Q[++tail] = L[i]; if(sgn(Q[tail].v ^ Q[tail - 1].v) == 0){ // parallel, the inner one remains tail--; if(!PointOnRight(L[i].p, Q[tail])) Q[tail] = L[i]; } if(head &lt; tail) P[tail - 1] = GetLineIntersection(Q[tail-1], Q[tail]); } while(head &lt; tail &amp;&amp; PointOnRight(P[tail - 1], Q[head])) tail--; // delete useless plane P[tail] = GetLineIntersection(Q[tail], Q[head]); m = 0; for(int i = head; i &lt;= tail; i++) res[++m] = P[i]; } };//-----------------------------------------------------------------------------------------------//int T, n;LL A, B;double r;Point p[N], q[N], ch[N];Line l[N];Halfplane hp;int main(){ for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d%lf&quot;, &amp;n, &amp;r); scanf(&quot;%lld%lld&quot;, &amp;A, &amp;B); for(int i = 1; i &lt;= n; i++) p[i].read(); int tot = 0; ConvexHull(n, p, ch, tot); if(tot &lt;= 2){ printf(&quot;%.12f\\n&quot;, 0.0); continue; } double Stot = PolygonArea(tot, ch); if(B &gt;= A){ printf(&quot;%.12f\\n&quot;, Stot * A); continue; } int qn = 0; ch[0] = ch[n]; for(int i = 1; i &lt;= n; i++){ Point t = ch[i] + r * Normal(ch[i] - ch[i-1]); l[i] = Line(t, ch[i] - ch[i-1]); } hp.HalfplaneIntersection(l, n, q, qn); if(qn &lt; 3){ printf(&quot;%.12f\\n&quot;, Stot * A); continue; } double SB = PolygonArea(qn, q); q[0] = q[qn]; for(int i = 1; i &lt;= qn; i++) SB += Length(q[i] - q[i-1]) * r; SB += PI * r * r; printf(&quot;%.12f\\n&quot;, (Stot - SB) * A + SB * B); } return 0;}","link":"/blog-xcpc/2020/07/21/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第三场）","text":"比赛链接 收获 括号匹配不一定要用栈，也可以用队列——特别是要求字典序最小时。 1004 Tokitsukaze and Multiple问题其实就是把序列给切分成若干段，问和为 $p$ 的倍数的最多有多少段。 贪心：作前缀和，从左往右扫，扫到模 $p$ 相同的数就形成一段。证明：如果这里不形成一段，那么右端点会右移，占掉了更多的数，答案不会更优。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int T, n, p;int main(){ for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;p); map&lt;int, int&gt; m; m[0] = 1; int ans = 0, s = 0; for(int i = 1; i &lt;= n; i++){ int a; scanf(&quot;%d&quot;, &amp;a); (s += a) %= p; if(m[s]) ans++, m.clear(), m[s] = 1; else m[s] = 1; } printf(&quot;%d\\n&quot;, ans); } return 0;} 1005 Little W and Contest并查集维护关系，记录每一个连通块里 $1,2$ 的数量。 先把初始答案算出来，考虑合并操作导致答案减少的量：合并两个集合，那么减少了从这两个集合里拿出两个 $2$ 与其他的 $1$ 或 $2$ 匹配的数量，以及从这两个集合里拿出一个 $1$、一个 $2$ 与其他的 $2$ 匹配的数量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;const LL MOD = 1e9 + 7;const LL inv2 = 500000004;const LL inv3 = 333333336;int T, n;LL sum[3];int fa[N];LL cnt[N][3];int findfa(int x){ return x == fa[x] ? x : fa[x] = findfa(fa[x]); }inline void unionn(int x, int y){ cnt[findfa(x)][1] += cnt[findfa(y)][1]; cnt[findfa(x)][2] += cnt[findfa(y)][2]; fa[findfa(y)] = findfa(x);}int main(){ for(read(T); T; T--){ read(n); sum[1] = sum[2] = 0; for(int i = 1; i &lt;= n; i++) cnt[i][1] = cnt[i][2] = 0, fa[i] = i; for(int i = 1; i &lt;= n; i++){ int x; read(x); cnt[i][x] = 1; sum[x]++; } LL ans = 0; if(sum[2] &gt;= 3) ans += sum[2] * (sum[2]-1) / 2 % MOD * (sum[2]-2) % MOD * inv3 % MOD; if(sum[2] &gt;= 2) (ans += sum[2] * (sum[2] - 1) / 2 % MOD * sum[1] % MOD) %= MOD; printf(&quot;%lld\\n&quot;, ans); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); u = findfa(u), v = findfa(v); ans -= cnt[u][2] * cnt[v][2] * (sum[2] - cnt[u][2] - cnt[v][2] + sum[1] - cnt[u][1] - cnt[v][1]); ans -= (cnt[u][2] * cnt[v][1] + cnt[u][1] * cnt[v][2]) * (sum[2] - cnt[u][2] - cnt[v][2]); ((ans %= MOD) += MOD) %= MOD; unionn(u, v); printf(&quot;%lld\\n&quot;, ans); } } return 0;} 1007 Tokitsukaze and Rescue真就硬搜……算出最短路，枚举删掉其中的一条边，然后再算最短路…… 看了题解，暴搜可行的原因是随机边权下，最短路边数很少。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 55;const int INF = 1e9;int T, n, k, g[N][N], ans;int dis[N], pre[N];bool vis[N];bool tag[N][N];void dijkstra(){ for(int i = 1; i &lt;= n; i++) dis[i] = INF, vis[i] = false, pre[i] = 0; dis[1] = 0; for(int i = 1; i &lt;= n; i++){ int mndis = INF, mark = 0; for(int j = 1; j &lt;= n; j++) if(dis[j] &lt; mndis &amp;&amp; !vis[j]) mndis = dis[j], mark = j; vis[mark] = true; for(int j = 1; j &lt;= n; j++){ if(tag[mark][j]) continue; if(dis[j] &gt; dis[mark] + g[mark][j]){ dis[j] = dis[mark] + g[mark][j]; pre[j] = mark; } } }}void dfs(int x){ dijkstra(); if(x == k){ ans = max(ans, dis[n]); return; } int now = n; vector&lt;pii&gt; v; while(pre[now]){ v.pb(mp(now, pre[now])); now = pre[now]; } for(auto &amp;k : v){ tag[k.first][k.second] = tag[k.second][k.first] = true; dfs(x+1); tag[k.first][k.second] = tag[k.second][k.first] = false; }}int main(){ for(read(T); T; T--){ read(n, k); ans = 0; for(int i = n * (n - 1) / 2; i; i--){ int u, v, w; read(u, v, w); g[u][v] = g[v][u] = w; } dfs(0); printf(&quot;%d\\n&quot;, ans); } return 0;} 1008 Triangle Collision完全弹性碰撞的处理方法就是把图形关于碰撞边做对称，然后小球路径不变保持直线即可。换句话说，就是在无限大密铺等边三角形上走一条直线路径。 只考虑小球与三角形最下面的边碰撞情形，其他情形变换一下坐标。如图做平行线（蓝色虚线），有两种情况： 红色路径（两条平行线之间）：每个碰撞点都和一个三角形有关，如图编号，发现奇数号的碰撞点很好求（红圈圈出），是一条平行于 $x$ 轴的直线与轨迹的交点；至于偶数号碰撞点，设为 $k$，我们把 $k+1$ 号碰撞点求出来，就可以确定出 $k$ 号三角形的位置，于是可以求得 $k$ 号碰撞点。 绿色路径（两条平行线之外）：只考虑右边（左边对称一下）。为了方便转一下坐标系，得到上图二。类似于第一种情况编号求解即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;const double PI = 4 * atan2(1, 1);const double INF = 1e16;inline int sgn(double x){ if(fabs(x) &lt; eps) return 0; else if(x &gt; 0) return 1; else return -1;}inline int cmp(double x, double y){ return sgn(x-y); }struct Vector{ double x, y; Vector() {} Vector(double x, double y):x(x), y(y){} void read(){ scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector(A.x + B.x, A.y + B.y); }Vector operator - (Vector A, Vector B){ return Vector(A.x - B.x, A.y - B.y); }Vector operator * (double k, Vector A){ return Vector(k * A.x, k * A.y); }Vector operator * (Vector A, double k){ return k * A; }Vector operator / (Vector A, double k){ return Vector(A.x / k, A.y / k); }bool operator &lt; (const Vector &amp;A, const Vector &amp;B){ return cmp(A.x, B.x) == 0 ? cmp(A.y, B.y) &lt; 0 : cmp(A.x, B.x) &lt; 0;}bool operator == (const Vector &amp;A, const Vector &amp;B){ return (cmp(A.x, B.x) == 0) &amp;&amp; (cmp(A.y, B.y) == 0); }// dot productdouble operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; }// cross productdouble operator ^ (Vector A, Vector B){ return A.x * B.y - A.y * B.x; }double Length(Vector A){ return sqrt(A * A); }// rotate rad counterclockwiseVector Rotate(Vector A, double rad){ double co = cos(rad), si = sin(rad); return Vector(A.x * co - A.y * si, A.x * si + A.y * co);}// test if vector B is to the left of vector Abool ToTheLeft(Vector A, Vector B){ return sgn(A ^ B) &gt; 0; }struct Line{ Point p; Vector v; double ang; // angle of inclination (-PI, PI] Line() {} Line(Point p, Vector v):p(p), v(v){ ang = atan2(v.y, v.x); } Line(double a, double b, double c){ // ax + by + c = 0 if(sgn(a) == 0) p = Point(0, -c/b), v = Vector(1, 0); else if(sgn(b) == 0) p = Point(-c/a, 0), v = Vector(0, 1); else p = Point(0, -c/b), v = Vector(-b, a); } Point getPoint(double t){ return p + v * t; } bool operator &lt; (const Line &amp;L) const{ return ang &lt; L.ang; }};bool PointOnLine(Point p, Line l){ return sgn(l.v ^ (p-l.p)) == 0; }bool PointOnRight(Point p, Line l){ return sgn(l.v ^ (p-l.p)) &lt; 0; }Point GetLineIntersection(Line l1, Line l2){ Vector u = l1.p - l2.p; double t = (l2.v ^ u) / (l1.v ^ l2.v); return l1.p + l1.v * t;}//------------------------------------------------------------------------//Point P;Vector v;double L;int k;inline void solve1(){ double y = -(k/2) * (sqrt(3)/2) * L; Line l(Point(0, y), Vector(1, 0)); Line route(P, v); Point inter = GetLineIntersection(l, route); if(k &amp; 1){ printf(&quot;%.8f\\n&quot;, Length(inter - P) / Length(v)); return; } else{ int kl = 0, kr = 0; Line ll, lr; if(k % 4 == 0){ kl = floor(inter.x / L - 0.5), kr = ceil(inter.x / L - 0.5); while(cmp((kl+1)*L+L/2, inter.x) &lt; 0) kl++; while(cmp((kr-1)*L+L/2, inter.x) &gt; 0) kr--; if(kl != kr-1) puts(&quot;Something wrong1!&quot;); ll = Line(Point(kl*L+L/2, y), Vector(1, sqrt(3))); lr = Line(Point(kr*L+L/2, y), Vector(-1, sqrt(3))); } else{ kl = floor(inter.x / L), kr = ceil(inter.x / L); while(cmp((kl+1)*L, inter.x) &lt; 0) kl++; while(cmp((kr-1)*L, inter.x) &gt; 0) kr--; if(kl != kr-1) puts(&quot;Something wrong2!&quot;); ll = Line(Point(kl*L, y), Vector(1, sqrt(3))); lr = Line(Point(kr*L, y), Vector(-1, sqrt(3))); } Point interl = GetLineIntersection(ll, route), interr = GetLineIntersection(lr, route); if(cmp(interl.y, y) &gt;= 0 &amp;&amp; cmp(interl.y, y+sqrt(3)/2*L) &lt;= 0){ printf(&quot;%.8f\\n&quot;, Length(interl - P) / Length(v)); return; } else if(cmp(interr.y, y) &gt;= 0 &amp;&amp; cmp(interr.y, y+sqrt(3)/2*L) &lt;= 0){ printf(&quot;%.8f\\n&quot;, Length(interr - P) / Length(v)); return; } else puts(&quot;Something wrong3!&quot;); }}inline void solve2(){ P.x += L/2; P = Rotate(P, -PI/3), v = Rotate(v, -PI/3); double y = -((k+1)/2) * (sqrt(3)/2) * L; Line l(Point(0, y), Vector(1, 0)); Line route(P, v); Point inter = GetLineIntersection(l, route); if(!(k &amp; 1)){ printf(&quot;%.8f\\n&quot;, Length(inter - P) / Length(v)); return; } else{ int kl = 0, kr = 0; Line ll, lr; if((k+1) % 4){ kl = floor(inter.x / L - 0.5), kr = ceil(inter.x / L - 0.5); while(cmp((kl+1)*L+L/2, inter.x) &lt; 0) kl++; while(cmp((kr-1)*L+L/2, inter.x) &gt; 0) kr--; if(kl != kr-1) puts(&quot;Something wrong4!&quot;); ll = Line(Point(kl*L+L/2, y), Vector(1, sqrt(3))); lr = Line(Point(kr*L+L/2, y), Vector(-1, sqrt(3))); } else{ kl = floor(inter.x / L), kr = ceil(inter.x / L); while(cmp((kl+1)*L, inter.x) &lt; 0) kl++; while(cmp((kr-1)*L, inter.x) &gt; 0) kr--; if(kl != kr-1) puts(&quot;Something wrong5!&quot;); ll = Line(Point(kl*L, y), Vector(1, sqrt(3))); lr = Line(Point(kr*L, y), Vector(-1, sqrt(3))); } Point interl = GetLineIntersection(ll, route), interr = GetLineIntersection(lr, route); if(cmp(interl.y, y) &gt;= 0 &amp;&amp; cmp(interl.y, y+sqrt(3)/2*L) &lt;= 0){ printf(&quot;%.8f\\n&quot;, Length(interl - P) / Length(v)); return; } else if(cmp(interr.y, y) &gt;= 0 &amp;&amp; cmp(interr.y, y+sqrt(3)/2*L) &lt;= 0){ printf(&quot;%.8f\\n&quot;, Length(interr - P) / Length(v)); return; } else puts(&quot;Something wrong6!&quot;); }}int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%lf%lf%lf%lf%lf%d&quot;, &amp;L, &amp;P.x, &amp;P.y, &amp;v.x, &amp;v.y, &amp;k); Point O(0, sqrt(3)/6*L); Vector PA = Point(-L/2, 0) - P, PB = Point(L/2, 0) - P, PC = Point(0, sqrt(3)/2*L) - P; Vector CA(-1, -sqrt(3)), CB(1, -sqrt(3)); if(ToTheLeft(PB, v) &amp;&amp; ToTheLeft(v, PC)){ v = Rotate(v, -2*PI/3); P = O + Rotate(P - O, -2*PI/3); } else if(ToTheLeft(PC, v) &amp;&amp; ToTheLeft(v, PA)){ v = Rotate(v, 2*PI/3); P = O + Rotate(P - O, 2*PI/3); }// cerr &lt;&lt; &quot;!&quot; &lt;&lt; P.x &lt;&lt; &quot; &quot; &lt;&lt; P.y &lt;&lt; &quot; &quot; &lt;&lt; v.x &lt;&lt; &quot; &quot; &lt;&lt; v.y &lt;&lt; endl; if(sgn(CA ^ v) &lt; 0) P.x = -P.x, v.x = -v.x; if(sgn(CA ^ v) &gt;= 0 &amp;&amp; sgn(v ^ CB) &gt;= 0) solve1(); else solve2(); } return 0;} 看到 std 之后：我果然又又又又做复杂了……二分答案，问题转化成已知时间内发生了多少次碰撞，与水平边有 $\\left\\lfloor\\frac{y}{\\frac{\\sqrt3}{2}L}\\right\\rfloor$ 个交点，与斜着的边的交点数旋转一下就好。 不过我的复杂度更优（这是我最后的倔强，哼！） 1009 Parentheses Matching首先把它本身已经匹配好的左右括号去掉——每一个右括号与尽可能靠右的左括号匹配，保证多出来的左括号尽可能靠前，原因稍后解释，实现用栈就好。 然后我们得到的序列一定长这样：一连串的右括号接上一连串的左括号，中间插入一些星。由于左括号前面的星对左括号没有影响，所以正如刚才所说，要让多出来的这些左括号靠前，更有可能匹配。 于是分段：一连串的右括号为一段，一连串的左括号为段，二者相互独立，分别求解。 对于右括号段，让尽可能前面的星变成左括号去匹配，这样保证字典序最小，用队列实现；对于左括号段，让尽可能后面的星变成右括号，反过来加队列就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n;char s[N], t[N];bool del[N];inline bool solve1(int l, int r){ queue&lt;int&gt; q; for(int i = l; i &lt;= r; i++){ if(del[i]) continue; if(s[i] == ')'){ if(q.empty()) return false; t[q.front()] = '('; q.pop(); } else if(s[i] == '*') q.push(i); else puts(&quot;Something wrong!&quot;); } return true;}inline bool solve2(int l, int r){ queue&lt;int&gt; q; for(int i = r; i &gt;= l; i--){ if(del[i]) continue; if(s[i] == '('){ if(q.empty()) return false; t[q.front()] = ')'; q.pop(); } else if(s[i] == '*') q.push(i); else puts(&quot;Something wrong!&quot;); } return true;}inline void initCASES(){ for(int i = 1; i &lt;= n; i++){ t[i] = '$'; del[i] = false; }}int main(){ for(read(T); T; T--){ scanf(&quot;%s&quot;, s+1); n = strlen(s+1); initCASES(); stack&lt;int&gt; stk; for(int i = 1; i &lt;= n; i++){ if(s[i] == '*') continue; else if(s[i] == '(') stk.push(i); else{ if(!stk.empty()){ del[stk.top()] = del[i] = true; stk.pop(); } } } int lst = 0, fst = n+1; for(int i = 1; i &lt;= n; i++){ if(del[i]) continue; if(s[i] == ')') lst = max(lst, i); if(s[i] == '(') fst = min(fst, i); } bool ok = true; if(lst &gt;= 1){ ok = solve1(1, lst); if(!ok){ puts(&quot;No solution!&quot;); continue; } } if(fst &lt;= n){ ok = solve2(fst, n); if(!ok){ puts(&quot;No solution!&quot;); continue; } } for(int i = 1; i &lt;= n; i++){ if(del[i]){ putchar(s[i]); continue; } if(s[i] == '*'){ if(t[i] != '$') putchar(t[i]); } else putchar(s[i]); } puts(&quot;&quot;); } return 0;}","link":"/blog-xcpc/2020/07/28/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第九场）","text":"比赛链接 1001 Tree（原本以为一定是最深的节点往根节点连边，但是不一定，因为贡献里还有子树大小这玩意儿。） 我们先计算出原树的答案。连边一定是从叶节点到根节点连边，连上后，那个叶节点的所有祖先节点都会给答案额外的贡献：$n$ 减去该节点子树大小。所以设 $f(i)$ 表示第 $i$ 个节点及其祖先对答案总的额外贡献，那么取最大即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 500005;int T, n, fa[N];vi edge[N];LL ans;LL sz[N], f[N];void dfs(int x, LL d){ sz[x] = 1; for(auto &amp;to : edge[x]) dfs(to, d+1), sz[x] += sz[to]; ans += sz[x];}LL mx;void dfs(int x){ f[x] = f[fa[x]] + n - sz[x]; mx = max(mx, f[x]); for(auto &amp;to : edge[x]) dfs(to);}inline void initCASES(){ ans = mx = 0; for(int i = 1; i &lt;= n; i++){ sz[i] = 0, fa[i] = 0; edge[i].clear(); }}int main(){ for(read(T); T; T--){ read(n); initCASES(); for(int i = 2; i &lt;= n; i++){ read(fa[i]); edge[fa[i]].pb(i); } dfs(1, 1); dfs(1); printf(&quot;%lld\\n&quot;, ans + mx); } return 0;} 1002 Absolute Math队友搞的，先放着占坑。 1003 Slime and Stones题解说： 通过找规律可得，所有的必败态为 $\\left(\\left\\lfloor\\frac{m(1-k+\\sqrt{k^2+2k+5})}{2}\\right\\rfloor,\\left\\lfloor\\frac{m(3+k+\\sqrt{k^2+2k+5})}{2}\\right\\rfloor\\right)$. 真是个骨骼清奇的规律啊……（别问我，我没看这题，我啥也不知道……） 1007 Game写个平衡树模拟即可。 （好久没写平衡树了，有点手生……呃……） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 200005;const LL INF = 1e16;int n;LL b[N];struct Splay{ int fa, son[2], size; LL val, sum, mn; void init(){ fa = son[0] = son[1] = size = 0; val = sum = mn = 0; }}tr[N];#define which(x,fa) (tr[fa].son[1] == x)int tot = 0, root = 0;inline void pushup(int x){ if(x){ tr[x].size = 1, tr[x].sum = tr[x].mn = tr[x].val; if(tr[x].son[0]){ tr[x].size += tr[tr[x].son[0]].size; tr[x].sum += tr[tr[x].son[0]].sum; tr[x].mn = min(tr[tr[x].son[0]].mn, tr[x].mn); } if(tr[x].son[1]){ tr[x].size += tr[tr[x].son[1]].size; tr[x].sum += tr[tr[x].son[1]].sum; tr[x].mn = min(tr[tr[x].son[1]].mn, tr[x].mn); } }}inline void rotate(int x, int dir){ // dir == 0: left, dir == 1: right int y = tr[x].fa, z = tr[y].fa, B = tr[x].son[dir]; tr[z].son[which(y,z)] = x; tr[x].fa = z; tr[x].son[dir] = y; tr[y].fa = x; tr[y].son[dir^1] = B; tr[B].fa = y; pushup(y); pushup(x);}inline void splay(int x, int goal){ // rotate x to the son of goal if(x == goal) return; while(tr[x].fa != goal){ int y = tr[x].fa, z = tr[y].fa, dir1 = which(x,y)^1, dir2 = which(y,z)^1; if(z == goal) rotate(x, dir1); else{ if(dir1 == dir2) rotate(y, dir2); else rotate(x, dir1); rotate(x, dir2); } } if(goal == 0) root = x;}inline int selectNode(int x){ // return id of x'th node on the tree int now = root; while(tr[tr[now].son[0]].size + 1 != x){ if(tr[tr[now].son[0]].size + 1 &gt; x) now = tr[now].son[0]; else{ x -= tr[tr[now].son[0]].size + 1; now = tr[now].son[1]; } } return now;}inline int findlast(int x, LL k){ // find the last node whose val &lt; k in 2nd ~ xth node on the tree splay(selectNode(1), 0); splay(selectNode(x+1), root); int now = tr[tr[root].son[1]].son[0]; int rk = 1; if(tr[now].mn &gt;= k) return -1; while(now &amp;&amp; tr[now].mn &lt; k){ if(tr[now].son[1] &amp;&amp; tr[tr[now].son[1]].mn &lt; k) rk += tr[tr[now].son[0]].size + 1, now = tr[now].son[1]; else if(tr[now].val &lt; k){ rk += tr[tr[now].son[0]].size + 1; break; } else if(tr[now].son[0] &amp;&amp; tr[tr[now].son[0]].mn &lt; k) now = tr[now].son[0]; } return rk; // rk: this node is rk'th node on the tree}inline LL getSum(int l, int r){ // return the sum of nodes from l'th to r'th node on the tree splay(selectNode(l-1), 0); splay(selectNode(r+1), root); int now = tr[tr[root].son[1]].son[0]; return tr[now].sum;}inline int del(int x){ // delete the x'th node on the tree splay(selectNode(x-1), 0); splay(selectNode(x+1), root); int now = tr[tr[root].son[1]].son[0]; tr[tr[root].son[1]].son[0] = 0; tr[now].fa = tr[now].size = 0; tr[now].son[0] = tr[now].son[1] = 0; tr[now].val = tr[now].sum = tr[now].mn = 0; pushup(tr[root].son[1]), pushup(root); return now;}inline void insert(int x, LL val, int id){ // insert val as the x'th node on the tree, using id as its id splay(selectNode(x-1), 0); splay(selectNode(x), root); tr[tr[root].son[1]].son[0] = id; tr[id].fa = tr[root].son[1]; tr[id].son[0] = tr[id].son[1] = 0; tr[id].size = 1; tr[id].val = tr[id].sum = tr[id].mn = val; pushup(tr[root].son[1]), pushup(root);}int build(int l, int r, int fa){ if(l &gt; r) return 0; int id = ++tot; tr[id].fa = fa, tr[id].size = 1; int mid = (l + r) &gt;&gt; 1; tr[id].val = tr[id].sum = tr[id].mn = b[mid]; tr[id].son[0] = build(l, mid - 1, id); tr[id].son[1] = build(mid + 1, r, id); pushup(id); return id;}bool first = false;void print(int x){ if(tr[x].son[0]) print(tr[x].son[0]); if(tr[x].val != -INF &amp;&amp; tr[x].val != INF){ if(!first) printf(&quot;%lld&quot;, tr[x].val), first = true; else printf(&quot; %lld&quot;, tr[x].val); } if(tr[x].son[1]) print(tr[x].son[1]);}inline void init(){ tot = root = 0; for(int i = 1; i &lt;= n + 2; i++) tr[i].init(); first = false;}int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ int q; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); init(); b[0] = -INF, b[n+1] = INF; for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;b[i]); root = build(0, n + 1, 0); while(q--){ int opt, x; LL y; scanf(&quot;%d&quot;, &amp;opt); if(opt == 1){ scanf(&quot;%d%lld&quot;, &amp;x, &amp;y); x++; if(y &gt; tr[selectNode(x)].val){ puts(&quot;0&quot;); continue; } int pos = findlast(x, y); if(pos == -1){ puts(&quot;0&quot;); continue; } printf(&quot;%lld\\n&quot;, getSum(pos+1, x) - 1ll*(y-1)*(x-pos)); LL newVal = tr[selectNode(pos+1)].val - y + 1 + tr[selectNode(pos)].val; int id = del(pos); insert(pos, newVal, id); id = del(pos+1); insert(x, y-1, id); } else{ scanf(&quot;%d&quot;, &amp;x); x++; printf(&quot;%lld\\n&quot;, tr[selectNode(x)].val); } } print(root); puts(&quot;&quot;); } return 0;}","link":"/blog-xcpc/2020/08/18/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E4%B9%9D%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第二场）","text":"比赛链接 收获 没有过不了的暴力，只有不敢打的暴力 1001 Total Eclipse1005 New Equipments1006 The Oculus1010 Lead of Wisdom还以为剪枝剪不了多少，结果还真能过…… >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 55;int T, n, k;inline LL func(LL a, LL b, LL c, LL d){ return (100 + a) * (100 + b) * (100 + c) * (100 + d);}struct Node{ LL a, b, c, d;};vector&lt;Node&gt; tp[N];LL sa[N], sb[N], sc[N], sd[N];LL ans;void dfs(int i, LL A, LL B, LL C, LL D){ if(i == k){ ans = max(ans, func(A, B, C, D)); return; } if(func(A + sa[i+1], B + sb[i+1], C + sc[i+1], D + sd[i+1]) &lt;= ans) return; if(tp[i+1].empty()) dfs(i+1, A, B, C, D); else{ for(auto &amp;k : tp[i+1]) dfs(i+1, A + k.a, B + k.b, C + k.c, D + k.d); }}int main(){ for(read(T); T; T--){ read(n, k); ans = -1; for(int i = 0; i &lt;= 50; i++){ tp[i].clear(); sa[i] = sb[i] = sc[i] = sd[i] = 0; } for(int i = 1; i &lt;= n; i++){ LL t, a, b, c, d; read(t, a, b, c, d); tp[t].push_back((Node){a, b, c, d}); } for(int i = 50; i &gt;= 1; i--){ LL suma = 0, sumb = 0, sumc = 0, sumd = 0; for(auto &amp;k : tp[i]){ suma += k.a; sumb += k.b; sumc += k.c; sumd += k.d; } sa[i] = sa[i+1] + suma; sb[i] = sb[i+1] + sumb; sc[i] = sc[i+1] + sumc; sd[i] = sd[i+1] + sumd; } dfs(0, 0, 0, 0, 0); printf(&quot;%lld\\n&quot;, ans); } return 0;}","link":"/blog-xcpc/2020/07/23/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第五场）","text":"比赛链接 收获 一些看似复杂的找规律题直接找一个恰当的数据结构模拟就好。 1001 Tetrahedron用等体积法求出 $h$ 和 $a,b,c$ 的关系（底面积用余弦定理+正弦定理）为：$$h=\\frac{abc}{\\sqrt{a^2b^2+b^2c^2+c^2a^2}}$$于是要求的是：$$\\frac{1}{h^2}=\\frac{a^2b^2+b^2c^2+c^2a^2}{a^2b^2c^2}=\\frac{1}{a^2}+\\frac{1}{b^2}+\\frac{1}{c^2}$$期望显然是：$$E\\left(\\frac{1}{h^2}\\right)=3\\cdot\\frac{\\sum\\limits_{k=1}^n\\frac{1}{k^2}}{n}$$预处理一下，回答即可。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 6000005;const LL MOD = 998244353;int T, n;LL sum[N];LL fpow(LL bs, LL idx){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int main(){ for(int i = 1; i &lt;= 6000000; i++) sum[i] = (fpow(1ll * i * i, MOD-2) + sum[i-1]) % MOD; for(read(T); T; T--){ read(n); printf(&quot;%lld\\n&quot;, 3ll * sum[n] % MOD * fpow(n, MOD-2) % MOD); } return 0;} 1003 Boring Game折叠 $k$ 次后展开，形成 $2^k$ 个格子，每一个格子建立一个链表。每一次折叠，就是把当前最左端的链表反转之后接到最右端的链表尾部、次左端的链表反转后接到次右端的链表尾部、……如此便得到下一阶段的链表。反复执行直到只剩下一个链表，按 $p$ 编号即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2005;int T, n, k;int val_col[N*405], ans[405][N], p[N*405];struct List{ int nxt, col; List(){ nxt = col = 0; }}a[N];int head[N], tail[N];void reverseList(int x){ int pre = 0, now = head[x]; while(now){ int nxt = a[now].nxt; a[now].nxt = pre; pre = now; now = nxt; } pre = head[x]; head[x] = tail[x]; tail[x] = pre;}inline void initCASES(){ for(int i = 1; i &lt;= (1 &lt;&lt; k); i++){ head[i] = tail[i] = 0; val_col[i] = 0; a[i].nxt = a[i].col = 0; }}int main(){ for(read(T); T; T--){ read(n, k); for(int i = 1; i &lt;= 2 * n * (1 &lt;&lt; k); i++) read(p[i]); initCASES(); for(int i = 1; i &lt;= (1 &lt;&lt; k); i++) head[i] = i, tail[i] = i, a[i].col = i; for(int len = (1 &lt;&lt; k); len &gt; 1; len &gt;&gt;= 1){ for(int l = (1 &lt;&lt; k) - len + 1, r = (1 &lt;&lt; k); l &lt; r; l++, r--){ reverseList(head[l]); a[tail[r]].nxt = head[l]; tail[r] = tail[l]; } } int now = head[(1&lt;&lt;k)], id = 2 * n * (1 &lt;&lt; k); while(now) val_col[id] = a[now].col, id -= 2 * n, now = a[now].nxt;// for(int id = 1; id &lt;= 2 * n * (1 &lt;&lt; k); id++)// printf(&quot;%d: %d\\n&quot;, id, val_col[id]); bool up = true; id = (1 &lt;&lt; k) * 2 * n; while(id){ int i = id; if(up){ for(int j = 2 * n; j &gt;= 1; j--) ans[j][val_col[i]] = p[id--]; } else{ for(int j = 1; j &lt;= 2 * n; j++) ans[j][val_col[i]] = p[id--]; } up ^= 1; } for(int i = 1; i &lt;= 2 * n; i++){ for(int j = 1; j &lt;= (1 &lt;&lt; k); j++){ printf(&quot;%d&quot;, ans[i][j]); if(i == 2 * n &amp;&amp; j == (1 &lt;&lt; k)) putchar('\\n'); else putchar(' '); } } } return 0;} 1007 Tree设 $dp[i][0/1]$ 表示以 $i$ 为根的子树内是否有 $&gt;k$ 的点的最大权值和，注意这个权值和要加上 $i$ 到父节点的边权，则： $dp[i][0]$ 等于最大的 $k-1$ 的子节点 $dp[sons][0]$ 之和加上到父节点的边权； $dp[i][1]$ 等于所有子节点 $dp[sons][0]$ 之和加上到父节点的边权，或者 $dp[i][0]$ 把某一个子节点从 $dp[son][0]$ 换成 $dp[son][1]$. 更新答案特别注意一下，除了所有 $dp[i][0],dp[i][1]$ 取 $\\max$ 之外，还有一种情形： 不取第 $i$ 个点向上到父节点的那条边，多取一个子节点。注意这个情形是没被 $dp$ 状态包含的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)const int N = 200005;int n, k;struct Edge{ int nxt, to; LL d;}edge[N&lt;&lt;1];int head[N], edgeNum, deg[N];void addEdge(int from, int to, LL d){ edge[++edgeNum] = (Edge){head[from], to, d}; head[from] = edgeNum; deg[to]++;}struct Node{ LL val; int id; bool operator &lt; (const Node &amp;A) const{ return val &gt; A.val; }};LL dp[N][2], ans;void DP(int x, int f, LL df){ dp[x][0] = dp[x][1] = df; vector&lt;Node&gt; v; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; DP(edge[i].to, x, edge[i].d); v.emplace_back((Node){dp[edge[i].to][0], edge[i].to}); dp[x][1] += dp[edge[i].to][0]; } int sz = v.size(); sort(v.begin(), v.end()); for(int i = 0; i &lt; min(sz, k - 1); i++) dp[x][0] += v[i].val; if(k &gt;= 2){ for(int i = 0; i &lt; sz; i++){ if(i &lt; k - 1) dp[x][1] = max(dp[x][1], dp[x][0] - v[i].val + dp[v[i].id][1]); else dp[x][1] = max(dp[x][1], dp[x][0] - v[k-2].val + dp[v[i].id][1]); } } else dp[x][1] = max(dp[x][1], df); LL res = dp[x][0] - df + (sz &gt;= k ? v[k-1].val : 0); ans = max(ans, res); for(int i = 0; i &lt; sz; i++){ if(i &lt; k) ans = max(ans, res - v[i].val + dp[v[i].id][1]); else ans = max(ans, res - v[k-1].val + dp[v[i].id][1]); }}inline void initCASES(){ edgeNum = 0; ans = 0; for(int i = 1; i &lt;= n; i++){ head[i] = deg[i] = 0; dp[i][0] = dp[i][1] = 0; }}int main(){ int T; for(read(T); T; T--){ read(n, k); initCASES(); for(int i = 1; i &lt; n; i++){ int u, v; LL d; read(u, v, d); addEdge(u, v, d), addEdge(v, u, d); } if(k == 0){ puts(&quot;0&quot;); continue; } int rt = 0; for(rt = 1; rt &lt;= n; rt++) if(deg[rt] == 1) break; DP(rt, 0, 0); for(int i = 1; i &lt;= n; i++) ans = max(ans, max(dp[i][0], dp[i][1])); printf(&quot;%lld\\n&quot;, ans); } return 0;} 1009 Paperfolding向上或向下折 $a$ 次，就会形成 $2^a$ 条折痕，分割出 $2^a+1$ 条横带；同理，向左或向右折 $b$ 次，就会形成 $2^b$ 条折痕，分割出 $2^b+1$ 条竖带；向上向下与向左向右的顺序不重要，只要向上或向下折 $a$ 次，向左或向右折 $b$ 次，答案就是 $(2^a+1)(2^b+1)$. 于是长度为 $n$ 的串的期望答案是：$$\\frac{\\sum\\limits_{i=0}^n\\binom{n}{i}2^i2^{n-i}(2^i+1)(2^{n-i}+1)}{4^n}$$$i$ 是枚举向上或向下折的次数，$\\binom{n}{i}$ 是从 $n$ 次操作中选 $i$ 次向上或向下折，$2^i$ 是每一次向上/向下折可以选择是向上还是向下，$2^{n-i}$ 是每一次向左/向右折可以选择是向左还是向右，$(2^i+1)(2^{n-i}+1)$ 就是这么折的答案，$4^n$ 是总折叠方案数。 化简上式：$$\\begin{align}\\frac{\\sum\\limits_{i=0}^n\\binom{n}{i}2^i2^{n-i}(2^i+1)(2^{n-i}+1)}{4^n}&amp;=\\frac{\\sum\\limits_{i=0}^n\\binom{n}{i}(2^n+2^i+2^{n-i}+1)}{2^n}\\&amp;=\\left[\\left(1+\\frac{1}{2^n}\\right)\\sum_{i=0}^n\\binom{n}{i}\\right]+\\frac{1}{2^{n-1}}\\sum_{i=0}^n\\binom{n}{i}2^i\\&amp;=2^n+1+\\frac{3^n}{2^{n-1}}\\end{align}$$问题解决。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 998244353;int T;LL n;inline LL fpow(LL bs, LL idx){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int main(){ for(read(T); T; T--){ read(n); if(n == 0) puts(&quot;4&quot;); else printf(&quot;%lld\\n&quot;, (fpow(2, n) + 1 + fpow(3, n) * fpow(fpow(2, n - 1), MOD - 2) % MOD) % MOD); } return 0;} 1012 Set1首先，前 $\\frac{n-1}{2}$ 个答案肯定是 $0$，我们考虑 $\\frac{n-1}{2}+i$ 这个数留下来的概率。 如果 $x=\\frac{n-1}{2}+i$ 留下来了，考虑大于 $x$ 的数，它们一定是与某个小于 $x$ 的数一起删掉的（否则 $x$ 作为最小数不会留下来），一共 $A_{x-1}^{n-x}$ 种方案；随后小于 $x$ 的数还有些剩下的数，它们进行两两匹配即可；考虑 $n$ 个数两两匹配的方案数，$f(n)=(n-1)f(n-2)$，即第一个数选后面一个数匹配再乘上剩下 $n-2$ 个数两两匹配的方案数，解得：$f(n)=(n-1)!!$. 所以小于 $x$ 的剩下的数两两匹配的方案数为 $(x-1-n+x-1)!!=(2x-2-n)!!=(2i-3)!!$. 综上，$x$ 留下的方案数为 $A_{x-1}^{n-x}(2i-3)!!$. （添加定义 $(-1)!!=1$ ）。 对每个数算出它留下的方案数，加起来得到总方案数，除一除即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 5000005;const LL MOD = 998244353;int T, n;LL fact2[N] = {1}, fact[N] = {1}, invfact[N] = {1};inline LL fpow(LL bs, LL idx){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int main(){ for(int i = 1; i &lt;= 5000000; i++){ fact[i] = fact[i-1] * i % MOD; invfact[i] = fpow(fact[i], MOD - 2); fact2[i] = fact2[i-1] * (2*i-1) % MOD; } for(read(T); T; T--){ read(n); vector&lt;LL&gt; ans(n+1); LL sum = 0; for(int i = 1; i &lt;= n / 2; i++) ans[i] = 0; for(int i = 1; i &lt;= n / 2 + 1; i++){ int x = n/2+i; ans[x] = fact[x-1] * invfact[2*x-n-1] % MOD * fact2[i-1] % MOD; (sum += ans[x]) %= MOD; } sum = fpow(sum, MOD - 2); for(int i = 1; i &lt;= n; i++) printf(&quot;%lld%c&quot;, ans[i] * sum % MOD, &quot; \\n&quot;[i == n]); } return 0;}","link":"/blog-xcpc/2020/08/05/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第六场）","text":"比赛链接 1001 Road To The 3rd Building显然，$$\\text{ANS}=\\frac{\\sum\\limits_{i=1}^n\\sum\\limits_{j=i}^n\\frac{1}{j-i+1}\\sum\\limits_{k=i}^ja_k}{\\sum\\limits_{i=1}^n\\sum\\limits_{j=i}^n1}=\\frac{\\sum\\limits_{i=1}^n\\sum\\limits_{j=i}^n\\frac{1}{j-i+1}\\sum\\limits_{k=i}^ja_k}{\\frac{n(n+1)}{2}}$$其中分子的化简如下：$$\\begin{align}\\sum_{i=1}^n\\sum_{j=i}^n\\frac{1}{j-i+1}\\sum_{k=i}^ja_k&amp;=\\sum_{i=1}^n\\sum_{l=1}^{n-i+1}\\frac{1}{l}\\sum_{k=i}^{i+l-1}a_k&amp;&amp;置;l=j-i+1\\&amp;=\\sum_{l=1}^n\\frac{1}{l}\\sum_{i=1}^{n-l+1}\\sum_{k=i}^{i+l-1}a_k&amp;&amp;求和号换序\\&amp;=\\sum_{l=1}^n\\frac{1}{l}\\sum_{k=1}^{n}\\sum_{i=\\max(1,k+1-l)}^{\\min(k,n-l+1)}a_k&amp;&amp;求和号换序\\&amp;=\\sum_{l=1}^n\\frac{1}{l}\\sum_{k=1}^n\\big[\\min(k,n-l+1)-\\max(1,k+1-l)+1\\big]a_k\\end{align}$$枚举 $l$，预处理之后分段计算 $k$ 即可。 时间复杂度：$O(n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;const LL MOD = 1e9+7;int n;LL a[N], sum[N], kak[N], inv[N];int main(){ inv[1] = 1; for(int i = 2; i &lt;= 200001; i++){ inv[i] = -(MOD / i) * inv[MOD % i]; ((inv[i] %= MOD) += MOD) %= MOD; } int T; for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++){ read(a[i]); sum[i] = (sum[i-1] + a[i]) % MOD; kak[i] = (kak[i-1] + i * a[i]) % MOD; } LL ans = 0; for(int l = 1; l &lt;= n; l++){ LL res = 0; int k1 = min(l, n - l + 1), k2 = max(l, n - l + 1); (res += kak[k1]) %= MOD; if(l &gt; n - l + 1) (res += (n - l + 1ll) * (sum[k2] - sum[k1]) % MOD) %= MOD; else if(l &lt; n - l + 1) (res += l * (sum[k2] - sum[k1]) % MOD) %= MOD; (res += (n + 1ll) * (sum[n] - sum[k2]) % MOD - (kak[n] - kak[k2]) % MOD) %= MOD; ((res %= MOD) += MOD) %= MOD; (res *= inv[l]) %= MOD; (ans += res) %= MOD; } ans = ans * inv[n] % MOD * inv[n+1] % MOD * 2ll % MOD; printf(&quot;%lld\\n&quot;, ans); } return 0;} 1002 Little Rabbit’s Equation模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int n, f[1005];char s[105];inline bool check(LL bs){ for(int i = 1; i &lt;= n; i++){ if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || s[i] == '=') continue; if(f[s[i]] &gt;= bs) return false; } LL a = 0, b = 0, c = 0; LL *t = &amp;a; int kind = 0; for(int i = 1; i &lt;= n; i++){ if(s[i] == '+'){ kind = 1; t = &amp;b; continue; } else if(s[i] == '-'){ kind = 2; t = &amp;b; continue; } else if(s[i] == '*'){ kind = 3; t = &amp;b; continue; } else if(s[i] == '/'){ kind = 4; t = &amp;b; continue; } else if(s[i] == '='){ t = &amp;c; continue; } (*t) = (*t) * bs + f[s[i]]; } if(kind == 1) return a + b == c; else if(kind == 2) return a - b == c; else if(kind == 3) return a * b == c; else if(kind == 4) return a == b * c; return false;}int main(){ for(int i = 0; i &lt;= 9; i++) f[i+'0'] = i; for(int i = 'A'; i &lt;= 'F'; i++) f[i] = i - 'A' + 10; while(scanf(&quot;%s&quot;, s+1) != EOF){ n = strlen(s+1); bool ok = false; for(int b = 2; b &lt;= 16; b++){ if(check(b)){ ok = true; printf(&quot;%d\\n&quot;, b); break; } } if(!ok) puts(&quot;-1&quot;); } return 0;} 1005 Fragrant numbers明天再写 1006 A Very Easy Graph Problem由于边权都是 $2^i$ 且互不相同，依据题目输入顺序，两个点之间的最短路就是它们一旦连通的时候的路径。也就是说，根据加的边做生成树即可。 接下来就是一个 $\\text{dp}$ 了，计算以 $i$ 为根的子树中黑白点的数量，据此计算每条边的贡献。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;const LL MOD = 1e9+7;LL power[N&lt;&lt;1] = {1};int n, m, a[N], sum[2];vector&lt;pii&gt; edge[N];int fa[N];int findfa(int x){ return fa[x] == x ? x : fa[x] = findfa(fa[x]); }void unionn(int x, int y){ fa[findfa(y)] = findfa(x); }int dp[N][2];LL ans;void dfs(int x, int f){ dp[x][a[x]] = 1; for(auto &amp;to : edge[x]){ if(to.first == f) continue; dfs(to.first, x); dp[x][0] += dp[to.first][0]; dp[x][1] += dp[to.first][1]; (ans += dp[to.first][0] * (sum[1] - dp[to.first][1]) % MOD * power[to.second] % MOD) %= MOD; (ans += dp[to.first][1] * (sum[0] - dp[to.first][0]) % MOD * power[to.second] % MOD) %= MOD; }}inline void initCASES(){ sum[0] = sum[1] = ans = 0; for(int i = 1; i &lt;= n; i++){ fa[i] = i; edge[i].clear(); dp[i][0] = dp[i][1] = 0; }}int main(){ for(int i = 1; i &lt;= 200000; i++) power[i] = power[i-1] * 2 % MOD; int T; for(read(T); T; T--){ read(n, m); initCASES(); for(int i = 1; i &lt;= n; i++) read(a[i]), sum[a[i]]++; for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); if(findfa(u) == findfa(v)) continue; unionn(u, v); edge[u].pb(mp(v, i)), edge[v].pb(mp(u, i)); } dfs(1, 0); printf(&quot;%lld\\n&quot;, ans); } return 0;} 1007 A Very Easy Math Problem$$\\begin{align}&amp;\\sum_{a_1=1}^n\\cdots\\sum_{a_x=1}^n\\left(\\prod_{j=1}^xa_j^k\\right)f(\\gcd(a_1,\\cdots,a_x))\\gcd(a_1,\\cdots,a_x)\\=&amp;\\sum_{a_1=1}^n\\cdots\\sum_{a_x=1}^n\\left(\\prod_{j=1}^xa_j^k\\right)\\mu^2(\\gcd(a_1,\\cdots,a_x))\\gcd(a_1,\\cdots,a_x)&amp;&amp;注意到;f=\\mu^2\\=&amp;\\sum_{d=1}^n\\sum_{a_1=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\cdots\\sum_{a_x=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}[\\gcd(a_1,\\cdots,a_x)=1]{\\left(a_1\\cdots a_x\\right)}^kd^{kx+1}\\mu^2(d)&amp;&amp;枚举;d=\\gcd(a_1,\\cdots,a_x)\\=&amp;\\sum_{d=1}^nd^{kx+1}\\mu^2(d)\\sum_{a_1=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\cdots\\sum_{a_x=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}(a_1\\cdots a_x)^k\\sum_{r\\mid\\gcd(a_1,\\cdots,a_x)}\\mu(r)&amp;&amp;\\epsilon=\\mu*1\\=&amp;\\sum_{d=1}^nd^{kx+1}\\mu^2(d)\\sum_{r=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}r^{kx}\\mu(r)\\sum_{a_1=1}^{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}\\cdots\\sum_{a_x=1}^{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}(a_1\\cdots a_x)^k&amp;&amp;求和号换序\\=&amp;\\sum_{d=1}^nd^{kx+1}\\mu^2(d)\\sum_{r=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}r^{kx}\\mu(r)\\left(\\sum_{i=1}^{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}i^k\\right)^x&amp;&amp;后面那一坨算出来\\=&amp;\\sum_{T=1}^nT^{kx}\\left(\\sum_{i=1}^{\\left\\lfloor\\frac{n}{T}\\right\\rfloor}i^k\\right)^x\\sum_{d\\mid T}d\\mu^2(d)\\mu\\left(\\frac{T}{d}\\right)&amp;&amp;令;T=rd\\end{align}$$ 推不动了，于是把 $\\sum\\limits_{d\\mid T}d\\mu^2(d)\\mu\\left(\\frac{T}{d}\\right)$ 这玩意儿单独拿出来，$O(nH(n))$预处理（可能可以线性筛预处理吧，但是没必要）。然后数论分块。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 1e9+7;const int N = 200005;int mu[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; mu[i] = -1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } }}inline LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int T;LL k, x;LL f[N], S[N], inv, g[N];int main(){ Euler(200000); read(T, k, x); for(int d = 1; d &lt;= 200000; d++) for(int i = d; i &lt;= 200000; i += d) (f[i] += d * mu[d] % MOD * mu[d] % MOD * mu[i / d] % MOD) %= MOD; for(int i = 1; i &lt;= 200000; i++){ S[i] = (S[i-1] + fpow(i, k * x % (MOD-1)) * f[i] % MOD) % MOD; g[i] = (g[i-1] + fpow(i, k)) % MOD; } while(T--){ LL ans = 0; LL n; read(n); for(LL l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); ans += ((S[r] - S[l-1]) % MOD + MOD) * fpow(g[n/l], x) % MOD; ans %= MOD; } printf(&quot;%lld\\n&quot;, ans); } return 0;} 1009 Divisibility真是巧了，前几天才看了这个问题。 根据九余数定理的推广，一个 $b$ 进制数的各个数位相加与它本身模 $x$ 同余的充要条件是：$b\\equiv1\\pmod x$. 所以这道题只需要判断是否 $b\\bmod x=1$ 即可。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL b, x;int main(){ for(read(T); T; T--){ read(b, x); if(b % x == 1) puts(&quot;T&quot;); else puts(&quot;F&quot;); } return 0;} 1010 Expectation对每一位运用 $\\textbf{Matrix-Tree Theorem}$ 计算这一位的生成树数量，这些数量按照二进制乘出来之后除以总的生成树数量即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 105;const int M = 20005;const LL MOD = 998244353;inline LL fpow(LL bs, LL idx){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}namespace LA{ int n; LL a[N][N], b[N]; void init(int nn){ n = nn; for(int i = 1; i &lt;= n; i++){ b[i] = 0; for(int j = 0; j &lt;= n; j++) a[i][j] = 0; } } LL det(){ // get determinant LL res = 1; int flag = 1; for(int j = 1; j &lt;= n; j++){ int r = j; for(int i = j + 1; i &lt;= n; i++) if(a[i][j] &gt; a[j][j]) r = i; if(r != j) swap(a[r], a[j]), flag = -flag; if(a[j][j] == 0) return 0; for(int i = 1; i &lt;= n; i++){ if(i == j) continue; LL div = a[i][j] * fpow(a[j][j], MOD-2) % MOD; for(int k = j; k &lt;= n; k++){ a[i][k] -= div * a[j][k] % MOD; ((a[i][k] %= MOD) += MOD) %= MOD; } } } for(int i = 1; i &lt;= n; i++) (res *= a[i][i]) %= MOD; return flag &gt; 0 ? res : MOD - res; }}int T, n, m;LL u[M], v[M], w[M];inline LL solve(int b){ LA::init(n-1); for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) LA::a[i][j] = 0; for(int i = 1; i &lt;= m; i++){ if(b == -1 || ((w[i] &gt;&gt; b) &amp; 1)){ LA::a[u[i]][v[i]]--, LA::a[v[i]][u[i]]--; LA::a[u[i]][u[i]]++, LA::a[v[i]][v[i]]++; } } for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; n; j++) ((LA::a[i][j] %= MOD) += MOD) %= MOD; return LA::det();}int main(){ for(read(T); T; T--){ read(n, m); for(int i = 1; i &lt;= m; i++) read(u[i], v[i], w[i]); LL ans = 0; for(int b = 31; b &gt;= 0; b--) ans = (ans * 2 + solve(b)) % MOD; LL tot = solve(-1); printf(&quot;%lld\\n&quot;, ans * fpow(tot, MOD-2) % MOD); } return 0;}","link":"/blog-xcpc/2020/08/07/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E5%85%AD%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第八场）","text":"比赛链接 1003 Clockwise or Counterclockwise签到。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)struct Point{ LL x, y;}p[10];int main(){ int T; for(read(T); T; T--){ read(p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y); p[1].x = p[2].x - p[1].x, p[1].y = p[2].y - p[1].y; p[2].x = p[3].x - p[2].x, p[2].y = p[3].y - p[2].y; if(p[1].x * p[2].y - p[1].y * p[2].x &gt; 0) puts(&quot;Counterclockwise&quot;); else puts(&quot;Clockwise&quot;); } return 0;} 1006 Fluctuation Limit第 $i$ 个范围浮动 $k$ 之后与第 $i+1$ 个范围取交得到第 $i+1$ 的新范围，如此更新直到第 $n$ 个，若该过程中出现空集则无法构造。构造这个序列只需从后往前任取合法范围内一个值即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n;LL k, l[N], r[N];int main(){ for(read(T); T; T--){ read(n, k); for(int i = 1; i &lt;= n; i++) read(l[i], r[i]); LL nowl = l[1], nowr = r[1]; bool ok = true; for(int i = 2; i &lt;= n; i++){ nowl -= k, nowr += k; nowl = max(nowl, l[i]), nowr = min(nowr, r[i]); if(nowl &gt; nowr){ ok = false; break; } l[i] = nowl, r[i] = nowr; } if(!ok) puts(&quot;NO&quot;); else{ puts(&quot;YES&quot;); vector&lt;LL&gt; ans(n+5); for(int i = n; i &gt;= 1; i--){ ans[i] = l[i]; if(i == 1) break; nowl = ans[i] - k, nowr = ans[i] + k; l[i-1] = max(l[i-1], nowl), r[i-1] = min(r[i-1], nowr); if(l[i-1] &gt; r[i-1]) puts(&quot;Something wrong&quot;); } for(int i = 1; i &lt;= n; i++) printf(&quot;%lld%c&quot;, ans[i], &quot; \\n&quot;[i==n]); } } return 0;} 1008 Hexagon就找规律……偶数在每一个格子都能拐，奇数有一个没法拐。偶数就以 $R=2$ 为中心，向四周两排两排地扩；奇数就以 $R=3$ 为中心，向四周两排两排地扩。 1009 Isomorphic Strings枚举因数 $k$，暴力把所有循环同构字串哈希出来，暴力判断。 这时限卡的，啧啧啧。。。（比赛的时候队友用 pdbs 里面的 hash_table 代替 map 卡过去的，奇怪的知识增加了～） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 5000005;const int MOD[3] = {10000019, 5000011, 7000061};int power[3][N], base = 233; // hash value of string s[1...i] is stored in h[i]int h[3][N];inline int getSubstring(int l, int r, int _){ // get hash value of s[l...r] if(l &gt; r) return 0; int res = (h[_][r] - 1ll * h[_][l-1] * power[_][r - l + 1] % MOD[_]) % MOD[_]; res %= MOD[_]; if(res &lt; 0) res += MOD[_]; return res;}int T, n;char s[N], t[N];int b[10000100], id;inline bool check(int _, int k){ id++; for(int i = 1; i &lt;= k; i++){ int tmp = (1ll * getSubstring(i, k, _) * power[_][i-1] % MOD[_] + getSubstring(1, i-1, _)) % MOD[_]; tmp %= MOD[_]; if(tmp &lt; 0) tmp += MOD[_]; b[tmp] = id; } for(int i = 1; i &lt;= n; i += k) if(b[getSubstring(i, i + k - 1, _)] != id) return false; return true;}void solve(){ read(n); scanf(&quot;%s&quot;, s+1); for(int _ = 0; _ &lt;= 2; _++) for(int i = 1; i &lt;= n; i++) h[_][i] = (1ll * h[_][i-1] * base % MOD[_] + s[i]) % MOD[_]; for(int i = 1; i &lt; n; i++){ if(n % i) continue; bool tag = true; for(int _ = 0; _ &lt;= 2; _++){ if(!check(_, i)){ tag = false; break; } } if(tag) return puts(&quot;Yes&quot;), void(); } puts(&quot;No&quot;);}int main(){ for(int _ = 0; _ &lt;= 2; _++){ power[_][0] = 1; for(int i = 1; i &lt;= 5000000; i++) power[_][i] = (1ll * power[_][i-1] * base) % MOD[_]; } for(read(T); T; T--) solve(); return 0;}","link":"/blog-xcpc/2020/08/13/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E5%85%AB%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第十场）","text":"比赛链接 1003 Mine Sweeper如果 $S\\leqslant 24$，在一排被交替摆放即可。如果 $S&gt;24$，类似如下摆放：$$\\begin{matrix}&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot\\&amp;\\cdot&amp;\\text{X}&amp;\\cdot&amp;\\text{X}&amp;\\cdot&amp;\\text{X}&amp;\\cdot&amp;\\text{X}&amp;\\cdot\\&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot\\&amp;\\cdot&amp;\\text{X}&amp;\\cdot&amp;\\text{X}&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot\\&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot\\&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot\\&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot\\&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\cdot&amp;\\text{X}&amp;\\text{X}&amp;\\text{X}\\\\end{matrix}$$孤立的 $\\text{X}$ 提供 $8$ 的贡献，右下角连续的 $\\text{X}$ 提供 $3$ 的贡献（最右端是 $2$，最左端是 $4$，平均一下还是 $3$）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ int T; for(read(T); T; T--){ int S; read(S); if(S &lt;= 24){ printf(&quot;%d %d\\n&quot;, 1, S+1); for(int i = 1; i &lt;= S + 1; i++) putchar(&quot;.X&quot;[i&amp;1]); puts(&quot;&quot;); continue; } int a, b; for(b = 0; ; b++){ if((S - 3 * b) % 8 == 0){ a = (S - 3 * b) / 8; break; } } char g[30][30]; for(int i = 1; i &lt;= 25; i++) for(int j = 1; j &lt;= 25; j++) g[i][j] = '.'; int cnt = 0; for(int i = 2; i &lt;= 25; i += 2){ for(int j = 2; j &lt;= 25; j += 2){ g[i][j] = 'X', cnt++; if(cnt == a) break; } if(cnt == a) break; } for(int j = 1; j &lt;= b; j++) g[25][25-j+1] = 'X'; printf(&quot;%d %d\\n&quot;, 25, 25); for(int i = 1; i &lt;= 25; i++){ for(int j = 1; j &lt;= 25; j++) putchar(g[i][j]); puts(&quot;&quot;); } } return 0;} 1004 Permutation Counting设 $dp[i][j]$ 表示填了前 $i$ 个数，第 $i$ 个数目前排名为 $j$ 的方案数。那么：$$dp[i][j] = \\begin{cases}\\sum\\limits_{k=1}^{j-1}dp[i-1][k]&amp;b_i=0\\\\sum\\limits_{k=j}^{i-1}dp[i-1][k]&amp;b_i=1\\end{cases}$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int MOD = 1e9+7;int dp[5005][5005];int main(){ int T; for(read(T); T; T--){ int n; read(n); dp[1][1] = 1; for(int i = 2; i &lt;= n; i++){ int b, sum = 0; read(b); if(b == 0){ for(int j = 1; j &lt;= i; j++){ dp[i][j] = sum; sum = (sum + dp[i-1][j]) % MOD; } } else{ for(int j = i; j &gt;= 1; j--){ sum = (sum + dp[i-1][j]) % MOD; dp[i][j] = sum; } } } int ans = 0; for(int i = 1; i &lt;= n; i++) ans = (ans + dp[n][i]) % MOD; printf(&quot;%d\\n&quot;, ans); } return 0;} 1010 Tic-Tac-Toe-Nim枚举第一轮拿走的两堆，现在还剩下 $7$ 堆。不妨假设拿走的是 $(1,1)$ 和 $(2,2)$，那么剩下的所有堆中，除了 $(3,3)$ 可以拿光，其他堆的策略是拿到 $1$，因为其他任何一堆拿光就输了，所以这就是 $7$ 个堆、其中 $6$ 堆石子个数等于原数减一的 $\\textbf{Nim}$ 游戏，判断异或和是否等于 $0$ 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int a[5][5];int main(){ int T; for(read(T); T; T--){ for(int i = 0; i &lt; 3; i++) for(int j = 0; j &lt; 3; j++) read(a[i][j]); int ans = 0; for(int i = 0; i &lt; 9; i++){ int x1 = i / 3, y1 = i % 3; bool ok = true; for(int j = 0; j &lt; 9; j++){ int x2 = j / 3, y2 = j % 3, x, y; if(x1 == x2 || y1 == y2) continue; for(x = 0; x == x1 || x == x2; x++); for(y = 0; y == y1 || y == y2; y++); int xorsum = 0; for(int k = 0; k &lt; 9; k++){ if(k == i || k == j) continue; xorsum ^= a[k/3][k%3] - 1 + ((k / 3 == x) &amp;&amp; (k % 3 == y)); } if(!xorsum){ ok = false; break; } } ans += ok; } printf(&quot;%d\\n&quot;, ans); } return 0;} 1011 Task Scheduler除了 $k=0$ 是 $12\\cdots n$，其他情况按照 $t$ 从大到小排序。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)struct Node{ int t, id; bool operator &lt; (const Node &amp;A) const{ return t == A.t ? id &lt; A.id : t &gt; A.t; }}a[105];int main(){ int T; for(read(T); T; T--){ int n, m, k; read(n, m, k); for(int i = 1; i &lt;= n; i++) read(a[i].t), a[i].id = i; if(k == 0){ for(int i = 1; i &lt;= n; i++) printf(&quot;%d%c&quot;, i, &quot; \\n&quot;[i==n]); continue; } sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i++) printf(&quot;%d%c&quot;, a[i].id, &quot; \\n&quot;[i==n]); } return 0;}","link":"/blog-xcpc/2020/08/20/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E5%8D%81%E5%9C%BA%EF%BC%89/"},{"title":"2020杭电多校（第四场）","text":"比赛链接 收获 学到了一个神奇的建图——$x$ 坐标和 $y$ 坐标分两边，连线就是 $(x,y)$ 这个点。 1002 Blow up the Enemy暴力枚举就好。比较谁赢就比较杀死对方时间的长短。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int T, n, a[N], d[N];inline double calc(int i, int j){ int t = 100 / a[i]; while(t * a[i] &lt; 100) t++; int win = (t - 1) * d[i]; t = 100 / a[j]; while(t * a[j] &lt; 100) t++; int lose = (t - 1) * d[j]; if(win &gt; lose) return 0; else if(win &lt; lose) return 1; return 0.5;}int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i], d[i]); vector&lt;double&gt; p(n+5); double mx = 0; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++) p[i] += calc(i, j); mx = max(mx, p[i]); } printf(&quot;%.8f\\n&quot;, mx / n); } return 0;} 1003 Contest of Rope Pulling转化问题为：$n+m$ 个物品，每个物品描述为 $(w_i,v_i)$，求 $\\sum w_i=0$ 下 $\\sum v_i$ 的最大值。 这是一个 $01$ 背包问题，$dp[i][j]=\\max(dp[i-1][j],dp[i-1][j-w_i]+v_i)$，但是直接做是 $O(n\\sum w_i)=O(10^9)$ 的，会 TLE。 由于最后我们要的答案是 $dp[n][0]$，所以 $dp$ 过程中，第二维越大，就越不大可能拉回来了。所以我们随机搞一搞，设一个上界 $T$，不考虑 $j&gt;T$ 或 $j&lt;T$ 的情况。这一随机处理的可行性依赖于：随机排序后，序列前缀和的最大值足够小（小于 $T$）。具体证明看题解吧，我也不会啊～ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2005;int T, n, m;struct Node{ LL w, v;}a[N];int main(){ srand(time(NULL)); for(read(T); T; T--){ read(n, m); for(int i = 1; i &lt;= n + m; i++){ read(a[i].w, a[i].v); if(i &gt; n) a[i].w = -a[i].w; } random_shuffle(a+1, a+n+m+1); LL lim = sqrt(n + m) * 1000 * 2; vector&lt; vector&lt;LL&gt; &gt; dp(2, vector&lt;LL&gt;(2*lim+1, -1e14)); dp[0][0+lim] = dp[1][0+lim] = 0; int now = 0; for(int i = 1; i &lt;= n + m; i++, now ^= 1) for(int j = -lim; j &lt;= lim; j++) if(j - a[i].w &lt;= lim &amp;&amp; j - a[i].w &gt;= -lim) dp[now ^ 1][j+lim] = max(dp[now][j+lim], dp[now][j-a[i].w+lim] + a[i].v); printf(&quot;%lld\\n&quot;, dp[now][0+lim]); } return 0;} 另外，在 $dp$ 的过程中决定 for 的范围也能卡过去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2005;int T, n, m;struct Node{ LL w, v;}a[N];int main(){ srand(time(NULL)); for(read(T); T; T--){ read(n, m); for(int i = 1; i &lt;= n + m; i++) read(a[i].w, a[i].v); int lim1 = 0; for(int i = 1; i &lt;= n; i++) lim1 += a[i].w; vector&lt;LL&gt; f(lim1+5, -1e14); f[0] = 0; lim1 = 0; for(int i = 1; i &lt;= n; i++){ lim1 += a[i].w; for(int j = lim1; j &gt;= a[i].w; j--) f[j] = max(f[j], f[j-a[i].w] + a[i].v); } int lim2 = 0; for(int i = n+1; i &lt;= n+m; i++) lim2 += a[i].w; vector&lt;LL&gt; g(lim2+5, -1e14); g[0] = 0; lim2 = 0; for(int i = n+1; i &lt;= n+m; i++){ lim2 += a[i].w; for(int j = lim2; j &gt;= a[i].w; j--) g[j] = max(g[j], g[j-a[i].w] + a[i].v); } LL ans = 0; for(int i = min(lim1, lim2); i &gt;= 0; i--) ans = max(ans, f[i] + g[i]); printf(&quot;%lld\\n&quot;, ans); } return 0;} 1004 Deliver the Cake每个点拆成左手、右手两个点，跑最短路即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200500;const int M = 800005;const LL INF = 1e16;struct Edge{ int nxt, to; LL dis;}edge[M&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, LL dis){ edge[++edgeNum] = (Edge){head[from], to, dis}; head[from] = edgeNum;}inline void ae(int from, int to, LL dis){ addEdge(from, to, dis), addEdge(to, from, dis);}namespace SP{ int n; LL dis[N]; void dijkstra(int s){ for(int i = 1; i &lt;= n; i++) dis[i] = INF; priority_queue&lt; pair&lt;LL, int&gt; &gt; q; dis[s] = 0; q.push(make_pair(-dis[s], s)); while(!q.empty()){ auto cur = q.top(); q.pop(); if(-cur.first &gt; dis[cur.second]) continue; for(int i = head[cur.second]; i; i = edge[i].nxt){ if(dis[edge[i].to] &gt; dis[cur.second] + edge[i].dis){ dis[edge[i].to] = dis[cur.second] + edge[i].dis; q.push(make_pair(-dis[edge[i].to], edge[i].to)); } } } }}int T, n, m, s, t, x;char c[N];int main(){ for(read(T); T; T--){ read(n, m, s, t, x); edgeNum = 0; for(int i = 1; i &lt;= 2 * n + 2; i++) head[i] = 0; scanf(&quot;%s&quot;, c+1); for(int i = 1; i &lt;= m; i++){ int u, v; LL d; read(u, v, d); if(c[u] == 'L'){ if(c[v] == 'L') ae(u, v, d); else if(c[v] == 'R') ae(u, v+n, d+x); else ae(u, v, d), ae(u, v+n, d+x); } else if(c[u] == 'R'){ if(c[v] == 'R') ae(u+n, v+n, d); else if(c[v] == 'L') ae(u+n, v, d+x); else ae(u+n, v, d+x), ae(u+n, v+n, d); } else if(c[u] == 'M'){ if(c[v] == 'L') ae(u, v, d), ae(u+n, v, d+x); else if(c[v] == 'R') ae(u, v+n, d+x), ae(u+n, v+n, d); else ae(u, v, d), ae(u, v+n, d+x), ae(u+n, v, d+x), ae(u+n, v+n, d); } } int S = 2 * n + 1, T = 2 * n + 2; addEdge(S, s, c[s] == 'R' ? INF : 0), addEdge(S, s+n, c[s] == 'L' ? INF : 0); addEdge(t, T, c[t] == 'R' ? INF : 0), addEdge(t+n, T, c[t] == 'L' ? INF : 0); SP::n = 2 * n + 2; SP::dijkstra(S); printf(&quot;%lld\\n&quot;, SP::dis[T]); } return 0;} 1005 Equal Sentences为了满足题目要求，我们发现我们能做的操作只能是相邻两数进行交换。 于是设 $dp[i]$ 是前 $i$ 个数的方案数，那么： 若 $s_i=s_{i-1}$，$dp[i]=dp[i-1]$； 若 $s_i\\neq s_{i-1}$，$dp[i]=dp[i-1]+dp[i-2]$. 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;const LL MOD = 1e9+7;int n;string s[N];int main(){ int T; for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; vector&lt;LL&gt; dp(n+5); dp[0] = dp[1] = 1; for(int i = 2; i &lt;= n; i++){ if(s[i] == s[i-1]) dp[i] = dp[i-1]; else dp[i] = (dp[i-1] + dp[i-2]) % MOD; } printf(&quot;%lld\\n&quot;, dp[n]); } return 0;} 1007 Go Running在一条线上跑来跑去的很混乱，我们自然想到把 $(t_i,x_i)$ 画到二维直角坐标系里，那么问题转化成：用最少的斜上/斜下 $45^\\circ$ 直线穿过所有点。斜着很难受，我们转换一下坐标系 $\\begin{cases}x’=x+y\\y’=y-x\\end{cases}$ 就把问题变成了：用最少的平行于坐标轴的线穿过所有点。 这可以转换成二分图——横坐标和纵坐标是二分图两部分，$x$ 向 $y$ 连边表示 $(x,y)$ 这个点，而二分图的点表示平行于 $y$ 或 $x$ 轴的直线。那么问题转化成了：选出最少的点覆盖所有边，就是二分图最小点覆盖问题，根据 $\\textbf{Konig}$ 定理，等价于二分图最大流问题。 注意：这道题 $\\textbf{Dinic}$ 必须要用当前弧优化，否则会 TLE。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 500005;const int INF = 1e9;namespace FLOW{ int s, t, n; struct Edge{ int nxt, to, flow; }edge[N&lt;&lt;2]; int head[N], edgeNum = 1, cur[N]; void addEdge(int from, int to, int flow){ edge[++edgeNum] = (Edge){head[from], to, flow}; head[from] = edgeNum; } bool inq[N]; int dep[N], curArc[N]; bool bfs(){ for(int i = 1; i &lt;= n; i++) dep[i] = INF, inq[i] = 0, curArc[i] = head[i]; queue&lt;int&gt; q; q.push(s); inq[s] = 1; dep[s] = 0; while(!q.empty()){ int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt){ if(dep[edge[i].to] &gt; dep[cur] + 1 &amp;&amp; edge[i].flow){ dep[edge[i].to] = dep[cur] + 1; if(!inq[edge[i].to]){ q.push(edge[i].to); inq[edge[i].to] = 1; } } } } if(dep[t] != INF) return 1; return 0; } int dfs(int x, int minFlow){ int flow = 0; if(x == t) return minFlow; for(int i = curArc[x]; i; i = edge[i].nxt){ curArc[x] = i; if(dep[edge[i].to] == dep[x] + 1 &amp;&amp; edge[i].flow){ flow = dfs(edge[i].to, min(minFlow, edge[i].flow)); if(flow){ edge[i].flow -= flow; edge[i^1].flow += flow; return flow; } } } return 0; } int Dinic(){ int maxFlow = 0, flow = 0; while(bfs()){ while(flow = dfs(s, INF)) maxFlow += flow; } return maxFlow; } void init(int ss, int tt, int nn){ s = ss, t = tt, n = nn; edgeNum = 1; for(int i = 1; i &lt;= n; i++) head[i] = 0; }}int T, n, l[N], r[N];struct Point{ int x, y;}p[N];int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++){ int x, y; read(x, y); p[i].x = x + y, p[i].y = y - x; } for(int i = 1; i &lt;= n; i++) l[i] = p[i].x, r[i] = p[i].y; sort(l+1, l+n+1); int lenl = unique(l+1, l+n+1) - (l+1); sort(r+1, r+n+1); int lenr = unique(r+1, r+n+1) - (r+1); FLOW::init(1, 2, lenl + lenr + 2); for(int i = 1; i &lt;= lenl; i++) FLOW::addEdge(1, i+2, 1), FLOW::addEdge(i+2, 1, 0); for(int i = 1; i &lt;= lenr; i++) FLOW::addEdge(i+lenl+2, 2, 1), FLOW::addEdge(2, i+lenl+2, 0); for(int i = 1; i &lt;= n; i++){ p[i].x = lower_bound(l+1, l+lenl+1, p[i].x) - l; p[i].y = lower_bound(r+1, r+lenr+1, p[i].y) - r; FLOW::addEdge(p[i].x+2, p[i].y+lenl+2, 1), FLOW::addEdge(p[i].y+lenl+2, p[i].x+2, 0); } printf(&quot;%d\\n&quot;, FLOW::Dinic()); } return 0;} 1011 Kindergarten Physics出题人耍我们呐……在题设范围内，小球动不了多少，直接输出 $d$ 就行了…… 123456789#include&lt;bits/stdc++.h&gt;int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ int d; scanf(&quot;%*d%*d%d%*d&quot;, &amp;d); printf(&quot;%d\\n&quot;, d); } return 0;}","link":"/blog-xcpc/2020/07/30/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第一场）","text":"比赛链接 收获 $n=50$ 的数据量考虑一下网络流 F Infinite String Comparision有一个 $\\textbf{Periodicity Lemma}$：如果一个字符串 $S$ 有长度为 $p$ 的循环节和长度为 $q$ 的循环节，并且 $p+q\\leq\\left|S\\right|+\\gcd(p,q)$，那么 $\\gcd(p,q)$ 也是 $S$ 的一个循环节。 因此，我们只需要判断 $i&lt;\\left|a\\right|+\\left|b\\right|-\\gcd(\\left|a\\right|,\\left|b\\right|)$ 时是否有 $a_i=b_i$。 关于 $\\textbf{Periodicity Lemma}$ 的一些资料：link1 link2 link3 >folded1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int gcd(int a, int b){ return b == 0 ? a : gcd(b, a % b); }char a[N], b[N];int main(){ while(scanf(&quot;%s%s&quot;, a, b) != EOF){ int lena = strlen(a), lenb = strlen(b); int mark = -1; for(int i = 0; i &lt; lena + lenb - gcd(lena, lenb); i++){ if(a[i % lena] != b[i % lenb]){ mark = i; break; } } if(mark == -1) puts(&quot;=&quot;); else if(a[mark % lena] &lt; b[mark % lenb]) puts(&quot;&lt;&quot;); else puts(&quot;&gt;&quot;); } return 0;} 接下来是一个及其优美的做法： 不妨设 $\\left|a\\right|\\leq\\left|b\\right|$，那么 $a[1…lena]$ 和 $b[1…lena]$ 不等答案显然；现在 $a[1…lena]=b[1…lena]$，接下来需要比较 $b[lena+1]$ 和 $a[1]$，但由于 $a[1…lena]=b[1…lena]$，相当于比较 $b[lena+1]$ 和 $b[1]$，同理往后推，可以得到一个非常简洁的结论：直接比较 $a+b$ 和 $b+a$ 即可。 >folded123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ string a, b; while(cin &gt;&gt; a &gt;&gt; b){ string A = a + b, B = b + a; if(A &lt; B) puts(&quot;&lt;&quot;); else if(A == B) puts(&quot;=&quot;); else puts(&quot;&gt;&quot;); } return 0;} J Easy Integration直接分部积分一波：$$\\begin{align}\\int_0^1\\left(x-x^2\\right)^n\\mathrm dx&amp;=\\int_0^1x^n(1-x)^n\\mathrm dx=\\int_0^1(1-x)^n\\mathrm d\\frac{x^{n+1}}{n+1}\\&amp;=\\frac{1}{n+1}\\left[(1-x)^nx^{n+1}\\bigg|_0^1+n\\int_0^1x^{n+1}(1-x)^{n-1}\\mathrm dx\\right]&amp;&amp;分部积分\\&amp;=\\frac{n}{n+1}\\int_0^1x^{n+1}(1-x)^{n-1}\\mathrm dx\\&amp;=\\cdots&amp;&amp;不断实施分部积分\\&amp;=\\frac{(n!)^2}{(2n+1)!}\\end{align}$$ 另外，上式其实是 $\\mathbf{Beta}$ 函数的特例：$$\\text{B}(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}\\mathrm dx$$ >folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 998244353;inline LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int n;LL fact[2000005], invfact[2000005];int main(){ fact[0] = 1; for(int i = 1; i &lt;= 2000000; i++){ fact[i] = fact[i-1] * i % MOD; invfact[i] = fpow(fact[i], MOD - 2); } while(scanf(&quot;%d&quot;, &amp;n) != EOF) printf(&quot;%lld\\n&quot;, fact[n] * fact[n] % MOD * invfact[2*n+1] % MOD); return 0;}","link":"/blog-xcpc/2020/07/15/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第三场）","text":"比赛链接 收获 若排列 $p$ 满足 $p_{p_i}=i$，那么 $p$ 是由序列 ${1,2,\\cdots,n}$ 选出 $\\frac{n}{2}$ 对两两交换得到的 类似于合并两个 vector 的操作时考虑按秩合并 A Clam and Fish贪心，只要有鱼就一定捕，因为捕蛤蜊最后还是要用来换鱼，不如现在就捕，所以就只需要考虑没有鱼的情况。没有鱼的情况下，遇到蛤蜊就先存起来，遇到没有蛤蜊的池塘，如果有库存的蛤蜊就用，到最后剩下一些蛤蜊，说明这些蛤蜊捕一半就够了，另一半用来诱鱼。 A.cpp >folded12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2000005;int T, n;char s[N];int main(){ for(read(T); T; T--){ read(n); scanf(&quot;%s&quot;, s+1); int ans = 0, tot = 0; for(int i = 1; i &lt;= n; i++){ if(s[i] &gt;= '2') ans++; else if(s[i] == '1') tot++; else if(tot &gt; 0) tot--, ans++; } ans += tot / 2; printf(&quot;%d\\n&quot;, ans); } return 0;} B Classical String Problem根据题设变换，任意时刻这个字符串一定是从某一位置开始循环填 $s_1,s_2,\\cdots,s_n$ 的形式，因此只需要记录好 $s_1$ 在当前时刻的位置即可。 B.cpp >folded12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2000005;int n, q, x;char s[N], opt[2];int main(){ scanf(&quot;%s&quot;, s+1); n = strlen(s+1); int pos = 1; for(read(q); q; q--){ scanf(&quot;%s%d&quot;, opt, &amp;x); if(opt[0] == 'M'){ if(x &lt; 0) x += n; if(x &gt; pos) pos += n; pos -= x; } else if(opt[0] == 'A'){ if(x &lt; pos) x += n; putchar(s[x - pos + 1]); puts(&quot;&quot;); } } return 0;} C Operation Love把凸包的边长搞出来，如果逆时针方向 $9$ 后面是 $8$ 或者顺时针方向 $9$ 后面是 $6$，那么就是右手；否则左手。 值得注意的是，这道题的精度开低点就够了。 P.S. 根本不用求出凸包……但是复制粘贴模板不香吗（大雾 C.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-4;const double PI = 4 * atan2(1, 1);const double INF = 1e16;inline int sgn(double x){ if(fabs(x) &lt; eps) return 0; else if(x &gt; 0) return 1; else return -1;}inline int cmp(double x, double y){ return sgn(x-y); }double rand01(){ return rand() / (double)RAND_MAX; }double randeps(){ return (rand01() - 0.5) * eps; }//------------------------------------ Vector &amp; Point ------------------------------------//struct Vector{ double x, y; Vector() {} Vector(double x, double y):x(x), y(y){} void read(){ scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector(A.x + B.x, A.y + B.y); }Vector operator - (Vector A, Vector B){ return Vector(A.x - B.x, A.y - B.y); }Vector operator * (double k, Vector A){ return Vector(k * A.x, k * A.y); }Vector operator * (Vector A, double k){ return k * A; }Vector operator / (Vector A, double k){ return Vector(A.x / k, A.y / k); }bool operator &lt; (const Vector &amp;A, const Vector &amp;B){ return cmp(A.x, B.x) == 0 ? cmp(A.y, B.y) &lt; 0 : cmp(A.x, B.x) &lt; 0;}bool operator &gt; (const Vector &amp;A, const Vector &amp;B){ return B &lt; A; }bool operator == (const Vector &amp;A, const Vector &amp;B){ return (cmp(A.x, B.x) == 0) &amp;&amp; (cmp(A.y, B.y) == 0); }bool operator != (const Vector &amp;A, const Vector &amp;B){ return !(A == B); }// dot productdouble operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; }// cross productdouble operator ^ (Vector A, Vector B){ return A.x * B.y - A.y * B.x; }double Length(Vector A){ return sqrt(A * A); }// test if vector(bc) is to the left of (ab)bool ToTheLeft(Point A, Point B, Point C){ return sgn((B - A) ^ (C - B)) &gt; 0; }// test if vector B is to the left of vector Abool ToTheLeft(Vector A, Vector B){ return sgn(A ^ B) &gt; 0; }//------------------------------------------------------------------------------////------------------------------------ Convex Hull ------------------------------------//void ConvexHull(int n, Point p[], Point sta[], int &amp;staid){ // there're n points stored in p[], the points on convex hull will be saved in sta[] sort(p+1, p+n+1); n = unique(p+1, p+n+1) - (p+1); staid = 0; for(int i = 1; i &lt;= n; i++){ // points on edge // while(staid &gt; 1 &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt; 0) staid--; // no points on edge while(staid &gt; 1 &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt;= 0) staid--; sta[++staid] = p[i]; } int k = staid; for(int i = n-1; i &gt;= 1; i--){ // points on edge // while(staid &gt; k &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt; 0) staid--; // no points on edge while(staid &gt; k &amp;&amp; sgn((sta[staid]-sta[staid-1]) ^ (p[i]-sta[staid-1])) &lt;= 0) staid--; sta[++staid] = p[i]; } if(n &gt; 1) staid--;}//-------------------------------------------------------------------------------------------//Point p[50], ch[50];double len[50], _len[50];int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ for(int i = 1; i &lt;= 20; i++) p[i].read(); int n = 0; ConvexHull(20, p, ch, n); ch[0] = ch[6]; memset(len, 0, sizeof len); memset(_len, 0, sizeof _len); for(int i = 1; i &lt;= n; i++) len[i] = Length(ch[i] - ch[i-1]); int id = n; int pos = 1; for(pos = 1; pos &lt;= n; pos++) if(cmp(len[pos], 9) == 0) break; for(int i = 1; i &lt;= n; i++){ _len[i] = len[pos]; pos++; if(pos &gt; n) pos = 1; } bool counter = ToTheLeft(ch[2] - ch[1], ch[3] - ch[2]); if(counter &amp;&amp; cmp(_len[2], 8) == 0) puts(&quot;right&quot;); else if(!counter &amp;&amp; cmp(_len[2], 6) == 0) puts(&quot;right&quot;); else puts(&quot;left&quot;); } return 0;} D Points Construction Problem首先，$m&gt;4n$ 或者 $m$ 是奇数无解。其次，$m$ 的下限是将 $n$ 个黑点组成尽可能方正的矩形缺一个角的形式后的匹配数（例如，$n=11$ 就是一个 $3\\times4$ 的矩形缺一个角的形式，此时 $m_\\min=14$），当 $m$ 小于这个下限时无解。其他情况有解。 考虑有解时如何构造。我们可以从 $m_\\min$ 开始，即刚才所说的“尽可能方正的矩形缺角”。每次从里面拆出来一个点丢到很远的地方，那么分情况我们的匹配数会 $+2$ 或 $+4$（一列一列地丢，如果丢某个点后这一列刚好丢完，那么匹配数 $+2$；否则 $+4$；另外只有一列的时候是 $+2$）。一直丢到匹配数 $\\geqslant m$ 的时候，如果是等于，那么我们找到了一个解；如果是大于，只可能是大 $2$，所以取一个丢出去的点加到矩形旁边就好。 D.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int T, n, m;int main(){ for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(m &amp; 1 || m &gt; 4 * n){ puts(&quot;No&quot;); continue; } int sql = sqrt(n), sqr = sql; if(sql * sqr &lt; n) sqr++; if(sql * sqr &lt; n) sql++; int out = 0, now = 2 * (sql + sqr); if(now &gt; m){ puts(&quot;No&quot;); continue; } puts(&quot;Yes&quot;); int extra = n - sql * (sqr - 1); for(int i = sqr; i &gt;= 1; i--){ if(now &gt;= m) break; for(int j = (i == sqr ? extra : sql); j &gt;= 1; j--){ if(now &gt;= m) break; if(j == 1 &amp;&amp; now &lt; m) out++, now += 2; else if(now &lt; m) out++, now += i == 1 ? 2 : 4; } } int col = (n - out) / sql; extra = n - out - col * sql; for(int i = 1; i &lt;= col; i++) for(int j = 1; j &lt;= sql; j++) printf(&quot;%d %d\\n&quot;, i, j); for(int j = 1; j &lt;= extra; j++) printf(&quot;%d %d\\n&quot;, col + 1, j); if(now &gt; m) printf(&quot;%d %d\\n&quot;, 0, 1), out--; for(int i = 1; i &lt;= out; i++) printf(&quot;%d %d\\n&quot;, i * 2 - 1, 100000000); } return 0;} E Two Matchings这道题需要转换一长串。。。首先 $p_{p_i}=i$ 意味着 $p$ 序列是由序列 ${1,2,\\cdots,n}$ 选出 $\\frac{n}{2}$ 对两两交换得到的，而 $p$ 和 $q$ 是 combinable 的意味着得到 $p$ 和 $q$ 的时候不能选出相同的一对。又 $\\left|a_i-a_{p_i}\\right|$ 其实是选出来的一对数的差的绝对值，故 $p$ 序列的代价 $\\frac{1}{2}\\sum\\limits_{i=1}^n\\left|a_i-a_{p_i}\\right|$ 其实就是选出来的所有对的差的绝对值之和。 于是题意转化成了：给定 $a$ 数组，找两种不同的配对方式（所谓不同，要求没有任何一对数同时出现在两个配对方式中），使得两种配对方式的代价和最小。一种配对方式的代价是所有数对的差的绝对值之和。 显然，我们要找的两种配对方式就是代价最小的和次小的两种配对方式。我们可能会怀疑把最小的配对方式代价增大、而次小的配对方式代价减小是否可行，但是这样答案不会更优：因为把更改了最小的配对方式的那些点拿出来，它们在次小配对方式中一定以最小的代价配对的，于是我们只需要把它们在两个配对方式中交换，就回到了最小配对方式。 代价最小的配对方式很简单，即 ${(a_i,a_{i+1})\\mid i=2k+1}$，考虑差分序列即可证明。问题主要是代价次小的配对方式。 为了不和最小匹配方式有相同的数对，当 $n=4$ 时，我们只有一种配对方式（其实是两种，但是本质相同），同样的，当 $n=6$ 时，我们也只有一种配对方式；而当 $n\\geqslant8$ 时，我们就可以从 $n-4$ 和 $n-6$ 分两种方式转移了，所以这就是一个 $\\text{dp}$。$\\text{dp}$ 求出次小配对方式后，两代价相加即是答案。 E.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;const LL INF = 1e16;int T, n;LL a[N];int main(){ for(read(T); T; T--){ read(n); LL ans = 0; for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i += 2) ans += a[i+1] - a[i]; if(n == 4){ ans += a[4] + a[3] - a[2] - a[1]; printf(&quot;%lld\\n&quot;, ans); continue; } else if(n == 6){ ans += a[6] + a[5] - a[4] + a[3] - a[2] - a[1]; printf(&quot;%lld\\n&quot;, ans); continue; } vector&lt;LL&gt; dp(n+5, INF); dp[4] = a[4] + a[3] - a[2] - a[1]; dp[6] = a[6] + a[5] - a[4] + a[3] - a[2] - a[1]; for(int i = 8; i &lt;= n; i += 2){ dp[i] = min(dp[i], dp[i-4] + a[i] + a[i-1] - a[i-2] - a[i-3]); dp[i] = min(dp[i], dp[i-6] + a[i] + a[i-1] - a[i-2] + a[i-3] - a[i-4] - a[i-5]); } printf(&quot;%lld\\n&quot;, ans + dp[n]); } return 0;} F Fraction Construction Problem 若 $(a,b)\\neq1$，设 $g=\\gcd(a,b)$，那么构造 $\\frac{\\frac{a}{g}+1}{\\frac{b}{g}}-\\frac{1}{\\frac{b}{g}}=\\frac{a}{b}$ 即可； 若 $(a,b)=1$ 且 $b$ 只有不多于一种质因子，那么不可能。因为：设 $b=p^k$，那么通分后分母 $df=b=p^k$，但是题设 $d,f&lt;b$，所以不可能； 若 $(a.b)=1$ 且 $b$ 可分解为两个互质的数的乘积，那我们就设 $d$ 和 $f$ 是这两个互质的因子，即 $df=b$。于是通分后分子有：$cf-de=a$，已知 $d,f,a$，解 $c,e$，扩欧即可。 F.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2000005;bool notP[N];int pList[N], pID;void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0) break; } }}int gcd(int a, int b){ return b == 0 ? a : gcd(b, a % b); }int exgcd(int a, int b, LL &amp;x, LL &amp;y){ // solve ax+by=gcd(a,b) if(b == 0){ x = 1, y = 0; return a; } int d = exgcd(b, a % b, x, y); LL t = x; x = y, y = t - a / b * y; return d;}int T;LL a, b;int main(){ Euler(2000000); for(read(T); T; T--){ read(a, b); LL g = gcd(a, b); if(g != 1){ printf(&quot;%lld %lld %lld %lld\\n&quot;, a / g + 1, b / g, 1ll, b / g); continue; } int d = 1, f = 1; LL c = 0, e = 0; int cnt = 0; for(int i = 1; pList[i] * pList[i] &lt;= b; i++){ if(b % pList[i] == 0) cnt++; int &amp;w = d == 1 ? d : f; while(b % pList[i] == 0){ b /= pList[i]; w *= pList[i]; } } if(b &gt; 1) cnt++, f *= b; if(cnt &lt;= 1){ puts(&quot;-1 -1 -1 -1&quot;); continue; } exgcd(f, d, c, e); e = -e; if(c &lt; 0 || e &lt; 0){ LL k = max(-c / d, -e / f) + 1; while(c + k * d &lt; 0 || e + k * f &lt; 0) k++; c += k * d, e += k * f; } c *= a, e *= a; printf(&quot;%lld %d %lld %d\\n&quot;, c, d, e, f); } return 0;} G Operating on a Graph对每个点维护一个 vector&lt;int&gt; bd，存储与以该点为代表元素的 group 相邻而不属于这个 group 的点。每次操作就模拟一下，把与 $o$ 点相邻的 group 的所有 vector 合并起来，注意按秩合并避免超时。 G.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 800005;int T, n, m;int fa[N];int findfa(int x){ return x == fa[x] ? x : fa[x] = findfa(fa[x]); }inline void unionn(int x, int y){ fa[findfa(y)] = findfa(x); }int main(){ for(read(T); T; T--){ read(n, m); vector&lt;vi&gt; bd(n+1, vector&lt;int&gt;()); for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); u++, v++; bd[u].pb(v), bd[v].pb(u); } int q; for(read(q); q; q--){ int o; read(o); o++; if(o != findfa(o)) continue; vi tmp = bd[o]; bd[o].clear(); for(auto p : tmp){ p = findfa(p); if(p == o) continue; unionn(o, p); if(bd[p].size() &gt; bd[o].size()) swap(bd[o], bd[p]); for(auto &amp;k : bd[p]) bd[o].pb(k); bd[p].clear(); } } for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, findfa(i) - 1); puts(&quot;&quot;); } return 0;} L Problem L is the Only Lovely Problem签到题 L.cpp >folded1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)char s[20];int main(){ scanf(&quot;%s&quot;, s+1); int n = strlen(s+1); for(int i = 1; i &lt;= n; i++) if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] += 'a' - 'A'; if(s[1] == 'l' &amp;&amp; s[2] == 'o' &amp;&amp; s[3] == 'v' &amp;&amp; s[4] == 'e' &amp;&amp; s[5] == 'l' &amp;&amp; s[6] == 'y') puts(&quot;lovely&quot;); else puts(&quot;ugly&quot;); return 0;}","link":"/blog-xcpc/2020/07/18/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%89%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第七场）","text":"比赛链接 AB Mask Allocation不妨设 $n&lt;m$，我们先把 $m$ 个 $n$ 放好，然后发现，前 $\\left\\lfloor\\frac{m}{n}\\right\\rfloor\\times n$ 个数字不需要动了，它们能形成 $n$ 个 $\\left\\lfloor\\frac{m}{n}\\right\\rfloor$；还剩下 $m\\bmod n$ 个 $n$，要把他们分成 $n$ 个 $m\\bmod n$，这就是子问题了，递归就好。复杂度等同于欧几里得算法。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)vi solve(int n, int m){ if(n &gt; m) swap(n, m); if(n == 0) return vi(); vi res; for(int i = 1; i &lt;= m / n; i++) for(int j = 1; j &lt;= n; j++) res.pb(n); vi tmp = solve(n, m % n); if(res.size() &lt; tmp.size()) swap(res, tmp); for(auto &amp;k : tmp) res.pb(k); return res;}int main(){ int T, n, m; for(read(T); T; T--){ read(n, m); vi ans = solve(n, m); sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); printf(&quot;%d\\n&quot;, (int)ans.size()); for(auto &amp;k : ans) printf(&quot;%d &quot;, k); puts(&quot;&quot;); } return 0;} D Fake News有个结论，$\\sum\\limits_{k=1}^nk^2$ 是一个完全平方数 $\\iff$ $n=1$ 或 $n=24$. 不过我们怎么可能知道这个结论呢…… 我们是这样做的：$\\sum\\limits_{k=1}^nk^2=\\frac{n(n+1)(2n+1)}{6}$，注意到 $n,n+1,2n+1$ 两两互质，所以要使原式是完全平方数，就必须在除掉 $6$ 之后，三个数本身就是完全平方数。 证明：$n,n+1,2n+1$ 两两互质。 证：$n,n+1$ 互质是大家都知道的；设 $\\gcd(n,2n+1)=g$，$n=ag,;2n+1=bg$，那么 $(b-2a)g=1$，只能是 $g=1$；设 $\\gcd(n+1,2n+1)=g$，$n+1=ag,;2n+1=bg$，那么 $(2a-b)g=1$，只能是 $g=1$。证毕。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL n;int main(){ for(read(T); T; T--){ read(n); LL a = n, b = n + 1, c = 2 * n + 1; if(a % 2 == 0) a /= 2; else b /= 2; if(a % 3 == 0) a /= 3; else if(b % 3 == 0) b /= 3; else c /= 3; LL sqa = sqrt(a), sqb = sqrt(b), sqc = sqrt(c); if(sqa * sqa == a &amp;&amp; sqb * sqb == b &amp;&amp; sqc * sqc == c) puts(&quot;Fake news!&quot;); else puts(&quot;Nobody knows it better than me!&quot;); } return 0;} H Dividing只要一个数是 $k$ 的倍数或者 $\\bmod k$ 余 $1$，那么它就会被统计。 所以我们要算的就是：$\\sum\\limits_{k=1}^K\\sum\\limits_{i=1}^N[k\\mid i;或;k\\mid i-1]$. 推一下：$$\\begin{align}\\sum_{k=1}^K\\sum_{i=1}^N[k\\mid i;或;k\\mid i-1]&amp;=\\sum_{k=2}^K\\sum_{i=1}^N[k\\mid i]+\\sum_{k=2}^K\\sum_{i=1}^N[k\\mid i-1]+N&amp;&amp;注意;k=1;有重复，所以单独拿出来计算\\&amp;=\\sum_{k=2}^K\\sum_{i=1}^N[k\\mid i]+\\sum_{k=2}^K\\sum_{i=1}^{N-1}[k\\mid i]+N+K-1&amp;&amp;i=0;也单独统计\\&amp;=\\sum_{k=2}^K\\left\\lfloor\\frac{N}{k}\\right\\rfloor+\\sum_{k=2}^K\\left\\lfloor\\frac{N-1}{k}\\right\\rfloor+N+K-1\\end{align}$$这就是数论分块的裸题了。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 1e9+7;int main(){ LL n, k; read(n, k); LL ans = 0; for(LL l = 2, r; l &lt;= k; l = r + 1){ if(n / l == 0) r = k; else r = min(k, n / (n / l)); (ans += (r - l + 1) * (n / l) % MOD) %= MOD; } n--; for(LL l = 2, r; l &lt;= k; l = r + 1){ if(n / l == 0) r = k; else r = min(k, n / (n / l)); (ans += (r - l + 1) * (n / l) % MOD) %= MOD; } (ans += n + k) %= MOD; printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/08/02/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%83%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第二场）","text":"比赛链接 收获 一定要注意 corner cases $40000$ 的数据量考虑一下 bitset 平面图最小割 $\\implies$ 对偶图最短路 区间 $[L,R]$ 及其移动可以尝试看成点 $(L,R)$ 及其移动 A All with Pairs把所有后缀的 $\\text{hash}$ 值都存下来，枚举每一个字符串的前缀，设 $cnt_i$ 表示与 $s[1…i]$ 相同的后缀数量。但是我们发现同一个串可能会给不同的 $cnt_i$ 有贡献，例如给出两个 $aba$，那么考虑其中一个 $aba$ 时，另一个 $aba$ 的后缀 $a$ 会给 $cnt_1$ 贡献，后缀 $aba$ 会给 $cnt_3$ 贡献，我们只想要保留对 $i$ 最大的 $cnt_i$ 的贡献。假设一个字符串对 $cnt_i,cnt_j$ 均有贡献，其中 $j&lt;i$，这意味着长度为 $j$ 的后缀是长度为 $i$ 的后缀的公共前后缀。联想到 $\\textbf{KMP}$ 算法的 $\\text{next}$ 数组，只需要 $cnt_{\\text{next[i]}}-=cnt_i$ 即可消除重复贡献的情况。 A.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;#define pb(x) emplace_back(x)const int LEN = 1000005;ULL base = 233, power[LEN] = {1};void Hash(vector&lt;ULL&gt; &amp;h, char s[]){ int len = (int)strlen(s+1); h[1] = s[1]; for(int i = 2; i &lt;= len; i++) h[i] = h[i-1] * base + s[i];}ULL getSubstring(vector&lt;ULL&gt; &amp;h, int l, int r){ // get hash value of s[l...r] return h[r] - h[l-1] * power[r - l + 1];}void getFail(vector&lt;int&gt; &amp;fail, char t[], int lent){ int i = 1, j = 0; fail[1] = 0; while(i &lt;= lent){ if(!j || t[i] == t[j]) fail[++i] = ++j; else j = fail[j]; }}const LL MOD = 998244353;const int N = 100005;int n, len[N], cnt[LEN];char s[LEN];LL ans;vector&lt;ULL&gt; H[N];vector&lt;int&gt; fail[N];map&lt;ULL, int&gt; m;int main(){ for(int i = 1; i &lt;= 1000000; i++) power[i] = power[i-1] * base; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%s&quot;, s+1); len[i] = strlen(s+1); H[i].resize(len[i]+5); Hash(H[i], s); for(int j = 1; j &lt;= len[i]; j++) m[getSubstring(H[i], j, len[i])]++; fail[i].resize(len[i]+5); getFail(fail[i], s, len[i]); } for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= len[i]; j++){ cnt[j] = m[getSubstring(H[i], 1, j)]; cnt[fail[i][j+1]-1] -= cnt[j]; } for(int j = 1; j &lt;= len[i]; j++){ (ans += 1ll * cnt[j] * j % MOD * j % MOD) %= MOD; cnt[j] = 0; } } printf(&quot;%lld\\n&quot;, ans); return 0;} B Boundary比赛时因为没考虑 corner cases 而贡献了 7 发罚时，吸取了惨烈的教训。 枚举点，与原点构成一条弦，根据圆周角定理，和这两个点在同一个圆上的所有点的圆周点相同或互补，于是我们可以把其他点的圆周角算出来（右侧的角用 $\\pi$ 减掉，相当于把点全放到左侧去），统计相同角的个数即可。 一定注意 $n=1$ 以及 $n=2$ 但是共线等 corner cases！ 复杂度：$O(n^2\\lg n)$ B.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-14;const double PI = 4 * atan2(1, 1);const int N = 2005;inline int sgn(double x){ if(fabs(x) &lt; eps) return 0; else if(x &gt; 0) return 1; else return -1;}inline int cmp(double x, double y){ return sgn(x-y); }//------------------------------------ Vector &amp; Point ------------------------------------//struct Vector{ double x, y; Vector() {} Vector(double x, double y):x(x), y(y){} void read(){ scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector(A.x + B.x, A.y + B.y); }Vector operator - (Vector A, Vector B){ return Vector(A.x - B.x, A.y - B.y); }bool operator &lt; (const Vector &amp;A, const Vector &amp;B){ return cmp(A.x, B.x) == 0 ? cmp(A.y, B.y) &lt; 0 : cmp(A.x, B.x) &lt; 0;}// dot productdouble operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; }// cross productdouble operator ^ (Vector A, Vector B){ return A.x * B.y - A.y * B.x; }// angle between two vectors, in [0,PI]double Angle(Vector A, Vector B){ return atan2(fabs(A ^ B), A * B); }//------------------------------------------------------------------------------//int n, ans = 1;Point p[N];int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) p[i].read(); for(int i = 1; i &lt;= n; i++){ vector&lt;double&gt; a; for(int j = 1; j &lt;= n; j++){ if(j == i) continue; if(sgn(p[i] ^ p[j]) == 0) continue; Vector v1 = p[i] - p[j], v2 = Point(0, 0) - p[j]; double ang = Angle(v1, v2); if(sgn(p[i] ^ p[j]) &lt; 0) ang = PI - ang; a.push_back(ang); } sort(a.begin(), a.end()); int sz = a.size(); int res = 0; for(int k = 0; k &lt; sz; k++){ int j = k; while(j+1 &lt; sz &amp;&amp; cmp(a[j+1], a[k]) == 0) j++; res = max(res, j - k + 1); k = j; } ans = max(ans, res + 1); } printf(&quot;%d\\n&quot;, ans); return 0;} C Cover the Tree链的形式显然是从一个叶子到另一个叶子，所以答案至少是 $\\left\\lceil\\frac{s}{2}\\right\\rceil$. 解法看上去很神奇：选取一个非叶子节点作为根进行 $dfs$，得到叶子节点的 $dfs$ 序，连接第 $i$ 和第 $\\frac{s}{2}+i$ 个叶子节点即可（$i\\leq\\frac{s}{2}$）。 这是可以证明的：假设这条边“覆盖”着 $[l,r]$ 的叶子，如果 $l&gt;\\frac{s}{2}$，那么它一定被 $l-\\frac{s}{2}\\to l$ 的链覆盖；如果 $r\\leq\\frac{s}{2}$，那么它一定被 $r\\to r+\\frac{s}{2}$ 覆盖；否则，它一定被 $1\\to1+\\frac{s}{2}$ 或者 $\\frac{s}{2}\\to s$ 覆盖。 C.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, deg[N], rt;vi edge[N];vi leaf;void dfs(int x, int f){ if(deg[x] == 1) leaf.pb(x); for(auto &amp;to : edge[x]){ if(to == f) continue; dfs(to, x); }}int main(){ read(n); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); deg[u]++, deg[v]++; } if(n == 1) return puts(&quot;0&quot;), 0; if(n == 2) return puts(&quot;1&quot;), puts(&quot;1 2&quot;), 0; for(rt = 1; rt &lt;= n; rt++) if(deg[rt] != 1) break; dfs(rt, 0); int sz = leaf.size(); printf(&quot;%d\\n&quot;, (sz + 1) / 2); for(int i = 0; i &lt; sz / 2; i++) printf(&quot;%d %d\\n&quot;, leaf[i], leaf[i + sz / 2]); if(sz &amp; 1) printf(&quot;%d %d\\n&quot;, leaf[sz-1], leaf[0]); return 0;} D Duration签到题，把两个时间换算成秒，相减取绝对值即可。 D.cpp >folded123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int h, m, s;int main(){ scanf(&quot;%d:%d:%d&quot;, &amp;h, &amp;m, &amp;s); int a = h * 3600 + m * 60 + s; scanf(&quot;%d:%d:%d&quot;, &amp;h, &amp;m, &amp;s); int b = h * 3600 + m * 60 + s; printf(&quot;%d&quot;, abs(a - b)); return 0;} F Fake Maxpooling注意 $k$ 是固定的，一个 $k\\times k$ 子矩阵在平移的时候可以用单调队列搞定。预处理的时候也用单调队列。 另外，直接算 $A$ 数组是 $O(nm\\lg n)$ 的，实测用递归 $\\gcd$ 会 $\\text{TLE}$，循环 $\\gcd$ 可过。不过用下面这种方式计算 $A$ 数组是 $O(nm)$ 的（出题人的方式）： >folded12345for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(!GCD[i][j]) for(int k = 1; k * i &lt;= n &amp;&amp; k * j &lt;= m; k++) GCD[k * i][k * j] = k, A[k * i][k * j] = i * j * k; 其实就是记忆化。 复杂度：$O(nm)$ F.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x) int gcd(int a, int b){ int r = a % b; while(r) a = b, b = r, r = a % b; return b;} const int N = 5005; int n, m, k, g[N][N], p[N][N];queue&lt;pii&gt; q; void _push(int val, int pos){ while(!q.empty() &amp;&amp; q.front().first &lt;= val) q.pop(); q.push(mp(val, pos));} int main(){ read(n, m, k); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) g[i][j] = i / gcd(i, j) * j; for(int j = 1; j &lt;= m; j++){ while(!q.empty()) q.pop(); for(int i = 1; i &lt;= k; i++) _push(g[i][j], i); p[1][j] = q.front().first; for(int i = 2; i &lt;= n - k + 1; i++){ _push(g[i+k-1][j], i+k-1); while(q.front().second &lt; i) q.pop(); p[i][j] = q.front().first; } } LL ans = 0; for(int i = 1; i &lt;= n - k + 1; i++){ while(!q.empty()) q.pop(); for(int j = 1; j &lt;= k; j++) _push(p[i][j], j); ans += q.front().first; for(int j = 2; j &lt;= m - k + 1; j++){ _push(p[i][j+k-1], j+k-1); while(q.front().second &lt; j) q.pop(); ans += q.front().first; } } printf(&quot;%lld\\n&quot;, ans); return 0;} G Greater and Greater$40000$ 的数据量要联想到 bitset。 首先对每个 $A_i$ 求一个长度为 $m$ 的 bitset $S_i$，其中 $S_i[j]$ 表示 $A_i$ 能否干掉 $B_j$。例如：样例中 $A={1,4,2,8,5,7},,B={2,3,3}$，以 $A_3=2$ 为例，它的 $S_3=100$，因为 $2$ 可以干掉 $B_1$，但不能干掉 $B_2,B_3$。 为了计算所有的 $S_i$，注意到，如果把 $A$ 数组排序，那么后一个数字的 bitset 是在前一个数字的 bitset 的基础上，把某些 $0$ 改成 $1$ 得到的，因此，$S_i$ 最多有 $m$ 种。我在代码中把具有相同的 bitset 的 $A_i$ 都映射到同一个 bitset 上，这样保证时间复杂度和空间复杂度都是 $O\\left(\\frac{m^2}{32}\\right)$. （否则会爆空间） 随后设 $n$ 个长度为 $m$ 的 bitset $cur_i$，其中 $cur_i[j]$ 表示从 $A_i$ 开始的连续 $m-j+1$ 个数能否干掉 $B$ 的后 $m-j+1$ 个数（为什么是 $m-j+1$ 这个奇怪的数字，其实是为了后面的式子简便）。仍以样例为例：$cur_2=001$，因为 ${4,2,8}$ 不能干掉 ${2,3,3}$，${4,2}$ 不能干掉 ${3,3}$，${4}$ 可以干掉 ${3}$；同理，$cur_3=100$ 等等。 为了计算 $cur_i$，我们寻找递推式。以 $cur_2$ 为例，$cur_2[1]$ 可以看作是比较 ${2,8}$ 和 ${3,3}$ 后再比较 ${4}$ 和 ${2}$，也即是 $cur_2[1]=cur_3[2]\\text{ &amp; }S_2[1]$；$cur_2[2]$ 可以看作是比较 ${2}$ 和 ${3}$ 后比较 ${4}$ 和 ${2}$，也即是 $cur_2[2]=cur_3[3]\\text{ &amp; }S_2[2]$；$cur_2[3]$ 可以看作是比较 ${4}$ 和 ${2}$，为了统一递推式，不妨设 $cur_3[4]=1$，那么就有 $cur_2[3]=cur_3[4]\\text{ &amp; }S_2[3]$。综上，我们可以归纳出 $cur_i$ 的递推式：$cur_i=((cur_{i+1}\\text{&gt;&gt;}1)\\text{ &amp; }S_i)\\text{ | }I_{m+1}$，其中 $I_{m+1}$ 表示仅第 $m+1$ 位置 $1$ 的 bitset。 答案就是统计有多少个 $cur_i$ 的 $cur_i[1]=1$。 G.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 150005;int n, m, ans, func[N], id;struct Node{ int val, pos;}a[N];struct Nodeb{ int val, pos; bool operator &lt; (const Nodeb &amp;A) const{ return val == A.val ? pos &lt; A.pos : val &lt; A.val; }}b[N];bitset&lt;40002&gt; s[40002], cur;int main(){ read(n, m); for(int i = 1; i &lt;= n; i++) read(a[i].val), a[i].pos = i; for(int i = 1; i &lt;= m; i++) read(b[i].val), b[i].pos = i; sort(a+1, a+n+1, [&amp;](const Node &amp;A, const Node &amp;B){ return A.val &lt; B.val; }); sort(b+1, b+m+1, [&amp;](const Nodeb &amp;A, const Nodeb &amp;B){ return A.val &lt; B.val; }); for(int i = 1, j = 1; i &lt;= n; i++){ int jj = upper_bound(b+1, b+m+1, (Nodeb){a[i].val, 100000000}) - b; if(j == jj){ func[a[i].pos] = id; continue; } id++; s[id] = s[id-1]; func[a[i].pos] = id; for(int k = j; k &lt; jj; k++) s[id].set(b[k].pos); j = jj; } sort(a+1, a+n+1, [&amp;](const Node &amp;A, const Node &amp;B){ return A.pos &lt; B.pos; }); cur.set(m+1); for(int i = n; i &gt;= 1; i--){ cur = ((cur &gt;&gt; 1) &amp; s[func[i]]); cur.set(m+1); ans += cur.test(1); } printf(&quot;%d\\n&quot;, ans); return 0;} H Happy Triangle对于一个询问，分类讨论： 若 $x$ 是最大边，则寻找 $x$ 的前驱 $p$（非严格）和它的前驱的前驱 $pp$（非严格），若 $p+pp&gt;x$，那么可形成三角形； 若 $x$ 是中间边，则寻找 $x$ 的前驱 $p$ （非严格）和它的后继 $q$（非严格），若 $p+x&gt;q$，那么可形成三角形； 若 $x$ 是最小边，则为了形成三角形，我们需要找到 $b&gt;a&gt;x$ 且 $b-a&lt;x$ 的一对数 $a,b$，即需要在大于 $x$ 的数值中找到相邻的最小差值 $d$，如果 $d&lt;x$，那么可以形成三角形。 为了完成上述操作，我是离线之后上值域线段树，值域线段树叶子节点内存储该数与其非严格前驱的差值，非叶子节点维护子树的最小差值。 值得注意的一点是，这里的差值是非严格前驱，所以在添加或删除一个数之后，要数一数还剩多少个数，然后分类讨论修改这个差值。 附：值域线段树找严格前驱和后继的代码： >folded1234567891011121314151617181920LL getPre(int id, int pos){ if(tr[id].size == 0) return -INF; if(tr[id].l == tr[id].r) return tr[id].l == pos ? -INF : tr[id].l; if(pos &lt;= mid){ LL t = getPre(lid, pos); return t == pos ? -INF : t; } else{ LL t = getPre(rid, pos); if(t == -INF) t = getPre(lid, pos); return t == pos ? -INF : t; }}LL getSuc(int id, int pos){ if(tr[id].size == 0) return INF; if(tr[id].l == tr[id].r) return tr[id].l == pos ? INF : tr[id].l; if(pos &gt; mid){ LL t = getSuc(rid, pos); return t == pos ? INF : t; } else{ LL t = getSuc(lid, pos); if(t == INF) t = getSuc(rid, pos); return t == pos ? INF : t; }} H.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL INF = 1e14;const int N = 200005;struct segTree{ int l, r, cnt, size; LL mndiff;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ tr[id].mndiff = min(tr[lid].mndiff, tr[rid].mndiff); tr[id].size = tr[lid].size + tr[rid].size;}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].mndiff = INF; tr[id].cnt = tr[id].size = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid), build(rid, mid+1, r); pushup(id);}int add_del(int id, int pos, int val){ // val == 1(add) or -1(delete) or 0(query for cnt) // return how many elements left in pos if(tr[id].l == tr[id].r){ tr[id].cnt += val; tr[id].size += val; return tr[id].cnt; } if(pos &lt;= mid) return add_del(lid, pos, val); else return add_del(rid, pos, val); pushup(id);}void modify(int id, int pos, LL val){ if(tr[id].l == tr[id].r){ tr[id].mndiff = val; return; } if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); pushup(id);}LL getPre(int id, int pos){ if(tr[id].size == 0) return -INF; if(tr[id].l == tr[id].r) return tr[id].l == pos ? -INF : tr[id].l; if(pos &lt;= mid){ LL t = getPre(lid, pos); return t == pos ? -INF : t; } else{ LL t = getPre(rid, pos); if(t == -INF) t = getPre(lid, pos); return t == pos ? -INF : t; }}LL getSuc(int id, int pos){ if(tr[id].size == 0) return INF; if(tr[id].l == tr[id].r) return tr[id].l == pos ? INF : tr[id].l; if(pos &gt; mid){ LL t = getSuc(rid, pos); return t == pos ? INF : t; } else{ LL t = getSuc(lid, pos); if(t == INF) t = getSuc(rid, pos); return t == pos ? INF : t; }}LL query(int id, int l, int r){ if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].mndiff; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else return min(query(lid, l, mid), query(rid, mid+1, r));}int q, op[N], x[N], t[N];map&lt;LL, LL&gt; func;int main(){ // freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;H.out&quot;, &quot;w&quot;, stdout); func[-INF] = -INF, func[INF] = INF; scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= q; i++){ scanf(&quot;%d%d&quot;, &amp;op[i], &amp;x[i]); t[++t[0]] = x[i]; } sort(t+1, t+t[0]+1); int len = unique(t+1, t+t[0]+1) - (t+1), mx = 0; for(int i = 1; i &lt;= q; i++){ int tmp = lower_bound(t+1, t+len+1, x[i]) - t; func[tmp] = x[i], x[i] = tmp, mx = max(mx, tmp); } mx++; build(1, 1, mx); for(int i = 1; i &lt;= q; i++){ if(op[i] == 1){ int cnt = add_del(1, x[i], 1); LL pre = getPre(1, x[i]), suc = getSuc(1, x[i]); if(cnt == 1){ if(suc != INF &amp;&amp; add_del(1, suc, 0) == 1) modify(1, suc, func[suc] - func[x[i]]); modify(1, x[i], func[x[i]] - func[pre]); } else if(cnt &gt;= 2) modify(1, x[i], 0); } else if(op[i] == 2){ int cnt = add_del(1, x[i], -1); LL pre = getPre(1, x[i]), suc = getSuc(1, x[i]); if(cnt == 0){ modify(1, x[i], INF); if(suc != INF &amp;&amp; add_del(1, suc, 0) == 1) modify(1, suc, func[suc] - func[pre]); } else if(cnt == 1) modify(1, x[i], func[x[i]] - func[pre]); } else{ int cnt = add_del(1, x[i], 0); if(cnt &gt;= 2){ puts(&quot;Yes&quot;); continue; } LL pre = -INF, ppre = -INF; if(cnt == 1) pre = x[i], ppre = getPre(1, x[i]); else{ pre = getPre(1, x[i]); if(pre == -INF) ppre = -INF; else{ if(add_del(1, pre, 0) &gt;= 2) ppre = pre; else ppre = getPre(1, pre); } } if(func[pre] + func[ppre] &gt; func[x[i]]){ puts(&quot;Yes&quot;); continue; } LL suc = getSuc(1, x[i]); if(func[pre] + func[x[i]] &gt; func[suc]){ puts(&quot;Yes&quot;); continue; } puts(query(1, x[i] + 1, mx) &lt; func[x[i]] ? &quot;Yes&quot; : &quot;No&quot;); } } return 0;} I Interval把区间 $[l,r]$ 看成直角坐标下的点 $(l,r)$，则原题转化成了网格图的最小割问题，等价于最大流问题。 然而这个图的大小显然不适合跑网络流，但是受到“狼抓兔子”的启发，我们可以把平面图的最小割问题转化为其对偶图的最短路问题，于是 $\\textbf{dijkstra}$ 搞定。 I.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 300005;const LL INF = 1e16;struct Edge{ int nxt, to; LL dis;}edge[5000005];int head[N], edgeNum;void addEdge(int from, int to, LL dis){ edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;}struct Node{ LL dis; int num; bool operator &lt; (const Node &amp;a) const{ return a.dis &lt; dis; }};LL dis[N];bool inS[N];void dijkstra(int s, int n){ priority_queue&lt;Node&gt; q; for(int i = 1; i &lt;= n; i++) dis[i] = INF; dis[s] = 0; q.push( (Node){0, s} ); while(!q.empty()){ Node cur = q.top(); q.pop(); if(inS[cur.num]) continue; inS[cur.num] = 1; for(int i = head[cur.num]; i; i = edge[i].nxt){ if((LL)dis[edge[i].to] &gt; (LL)dis[cur.num] + edge[i].dis){ dis[edge[i].to] = dis[cur.num] + edge[i].dis; q.push( (Node){dis[edge[i].to], edge[i].to} ); } } }}int n, m;bool b[505][505];inline int get(int x, int y){ return (x - 1) * (n - 1) + y;}int main(){ read(n, m); int st = n * n + 1, ed = n * n + 2; for(int i = 1; i &lt;= m; i++){ int l, r, c; char dir[2]; scanf(&quot;%d%d%s%d&quot;, &amp;l, &amp;r, dir, &amp;c); if(dir[0] == 'L'){ if(r == n) addEdge(get(l, r-1), ed, c), addEdge(ed, get(l, r-1), c); else addEdge(get(l, r-1), get(l, r), c), addEdge(get(l, r), get(l, r-1), c); } else{ if(l == 1) addEdge(st, get(l, r-1), c), addEdge(get(l, r-1), st, c); else addEdge(get(l-1, r-1), get(l, r-1), c), addEdge(get(l, r-1), get(l-1, r-1), c); } } dijkstra(st, n * n + 2); if(dis[ed] == INF) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;, dis[ed]); return 0;} J Just Shuffle比赛时思路方向是对的，后续没想出来，有所收获。 我们可以根据 $A$ 数组将原排列拆成一个个环，而我们只需要在每个环上转动 $1$ 次就行了。设第 $i$ 个环大小为 $r_i$，我们想要寻找的 $P$ 排列是按照上述规则转动 $x_i$ 次后的一个映射，即按照 $P$ 转 $1$ 次等价于转 $x_i$ 次。那么按照 $P$ 转 $k$ 次等价于转了 $kx_i$ 次，我们希望 $kx_i\\bmod r_i=1$，即 $kx_i\\equiv1\\pmod {r_i}$，也即 $x_i\\equiv k^{-1}\\pmod {r_i}$，所以求求逆元，那么 $P$ 映射就是 $A$ 映射转 $x_i$ 次的结果，这道题就搞定了。 J.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int exgcd(int a, int b, int &amp;x, int &amp;y){ if(b == 0){ x = 1; y = 0; return a; } int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;}const int N = 100005;int n, k, a[N], ans[N];bool vis[N];int main(){ read(n, k); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= n; i++){ if(vis[i]) continue; vi org, _org; int now = i; while(!vis[now]){ vis[now] = true; org.pb(now); _org.pb(now); now = a[now]; } int ri = _org.size(); int x, y; exgcd(k, ri, x, y); ((x %= ri) += ri) %= ri; while(x--) for(auto &amp;t : _org) t = a[t]; for(int i = 0; i &lt; ri; i++) ans[org[i]] = _org[i]; } for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); return 0;} K Keyboard Free大佬博客 固定 $A$ 点后，答案不变。现在让 $B$ 点和 $C$ 点在圆上运动。 假设 $B$ 点固定住，此时可知如图所示的角 $\\alpha$ 和 $O$ 到直线 $AB$ 的距离 $h$，那么 $C$ 到直线 $AB$ 的期望距离为：$$\\begin{align}\\bar d&amp;=\\frac{\\int_\\alpha^{\\pi-\\alpha}(r_3\\sin\\theta-h)\\mathrm d\\theta+2\\int_0^\\alpha(h-r_3\\sin\\theta)\\mathrm d\\theta+\\int_0^\\pi(h+r_3\\sin\\theta)\\mathrm d\\theta}{2\\pi}\\&amp;=\\frac{2r_3\\cos\\alpha-h(\\pi-2\\alpha)+2h\\alpha+2r_3\\cos\\alpha-2r_3+h\\pi+2r_3}{2\\pi}\\&amp;=\\frac{2r_3\\cos\\alpha+2h\\alpha}{\\pi}\\end{align}$$于是。三角形期望面积为：$$\\bar S=\\frac{\\bar d\\cdot\\left|AB\\right|}{2}=\\frac{(r_3\\cos\\alpha+h\\alpha)\\left|AB\\right|}{\\pi}$$取 $1000$ 个 $B$ 即可。 K.cpp >folded12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const double PI = acos(-1);int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ double r1, r2, r3; scanf(&quot;%lf%lf%lf&quot;, &amp;r1, &amp;r2, &amp;r3); if(r1 &gt; r2) swap(r1, r2); if(r2 &gt; r3) swap(r2, r3); if(r1 &gt; r3) swap(r1, r3); double res = 0; for(int i = 1; i &lt;= 1000; i++){ double phi = 2 * PI / 1000.0 * i - PI / 10000; double AB = sqrt(r1 * r1 + r2 * r2 - 2 * r1 * r2 * cos(phi)); double h = r1 * r2 * sin(phi) / AB; double alpha = asin(h / r3); res += (r3 * cos(alpha) + alpha * h) / PI * AB; } printf(&quot;%.1f\\n&quot;, res / 1000.0); } return 0;}","link":"/blog-xcpc/2020/07/15/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第九场）","text":"比赛链接 A Groundhog and 2-Power Representation讨厌的模拟，递归+高精度。 然而 $\\text{python}$ 表示一行解决问题。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)struct BigNum{ vector&lt;int&gt; a; // a[n-1]...a[1]a[0] int neg; BigNum(){ a.clear(); neg = 1; } explicit BigNum(const string &amp;s){ a.clear(); int len = s.length(); for(int i = 0; i &lt; len; i++) a.pb(s[len-i-1] - '0'); } explicit BigNum(LL num){ a.clear(); do{ a.pb(num % 10); num /= 10; }while(num); } BigNum operator = (const string &amp;s){ return *this = BigNum(s); } BigNum operator = (LL num){ return *this = BigNum(num); } bool operator &lt; (const BigNum &amp;b) const{ if(a.size() != b.a.size()) return a.size() &lt; b.a.size(); for(int i = a.size() - 1; i &gt;= 0; i--) if(a[i] != b.a[i]) return a[i] &lt; b.a[i]; return false; } bool operator &gt; (const BigNum &amp;b) const{ return b &lt; *this; } bool operator &lt;= (const BigNum &amp;b) const{ return !(*this &gt; b); } bool operator &gt;= (const BigNum &amp;b) const{ return !(*this &lt; b); } bool operator != (const BigNum &amp;b) const{ return (*this &gt; b) || (*this &lt; b); } bool operator == (const BigNum &amp;b) const{ return !(*this &lt; b) &amp;&amp; !(*this &gt; b); } BigNum operator + (const BigNum &amp;b) const{ BigNum C; int x = 0; for(int i = 0, g = 0; ; i++){ if(g == 0 &amp;&amp; i &gt;= a.size() &amp;&amp; i &gt;= b.a.size()) break; x = g; if(i &lt; a.size()) x += a[i]; if(i &lt; b.a.size()) x += b.a[i]; C.a.pb(x % 10); g = x / 10; } return C; } BigNum operator - (const BigNum &amp;b) const{ BigNum C; BigNum A = *this; BigNum B = b; if(A &lt; B) C.neg = -1, swap(A, B); C.a.resize(A.a.size()); for(int i = 0; ; i++){ if(i &gt;= A.a.size() &amp;&amp; i &gt;= B.a.size()) break; if(i &gt;= B.a.size()) C.a[i] = A.a[i]; else C.a[i] = A.a[i] - B.a[i]; } for(int i = 0; ; i++){ if(i &gt;= C.a.size()) break; if(C.a[i] &lt; 0){ C.a[i] += 10; C.a[i+1]--; } } while(C.a.size() &gt; 1 &amp;&amp; C.a.back() == 0) C.a.pop_back(); return C; } BigNum operator * (const BigNum &amp;b) const{ BigNum C; C.a.resize(a.size() + b.a.size()); for(int i = 0; i &lt; a.size(); i++){ int g = 0; for(int j = 0; j &lt; b.a.size(); j++){ C.a[i+j] += a[i] * b.a[j] + g; g = C.a[i+j] / 10; C.a[i+j] %= 10; } C.a[i+b.a.size()] = g; } while(C.a.size() &gt; 1 &amp;&amp; C.a.back() == 0) C.a.pop_back(); return C; } BigNum operator / (const LL &amp;b) const{ BigNum C; C = *this; for(int i = C.a.size() - 1; i &gt;= 0; i--){ if(i) C.a[i-1] += C.a[i] % b * 10; C.a[i] /= b; } while(C.a.size() &gt; 1 &amp;&amp; C.a.back() == 0) C.a.pop_back(); return C; } BigNum operator / (const BigNum &amp;b) const{ BigNum L, R, ans, t; L = 0ll; R = *this; ans = 0ll; t = 1ll; while(L &lt;= R){ BigNum mid = (L + R) / 2; if((mid * b) &gt; (*this)) R = mid - t; else L = mid + t, ans = mid; } return ans; } BigNum operator % (const LL &amp;b) const{ BigNum B; B = b; return (*this) - (*this) / b * B; } BigNum operator % (const BigNum &amp;b) const{ return (*this) - (*this) / b * b; } BigNum operator += (const BigNum &amp;b){ *this = *this + b; return *this; } BigNum operator -= (const BigNum &amp;b){ *this = *this - b; return *this; } BigNum operator *= (const BigNum &amp;b){ *this = *this * b; return *this; } BigNum operator /= (const LL &amp;b){ *this = *this / b; return *this; } BigNum operator /= (const BigNum &amp;b){ *this = *this / b; return *this; }};ostream&amp; operator &lt;&lt; (ostream &amp;out, const BigNum &amp;b){ string res; if(b.neg == -1) res += '-'; for(int i = b.a.size() - 1; i &gt;= 0; i--) res += b.a[i] + '0'; return out &lt;&lt; res;}istream&amp; operator &gt;&gt; (istream &amp;in, BigNum &amp;b){ string str; if(in &gt;&gt; str) b = str; return in;}const int N = 30005;int ans[N], p[N];char s[N], t[N];LL get(int l, int r){ if(l == r) return s[l] - '0'; LL res = 0; for(int i = l; i &lt;= r; i++){ if(s[i] == '('){ res += pow(2, get(i+1, p[i]-1)); i = p[i]; } } return res;}int main(){ scanf(&quot;%s&quot;, t+1); int tlen = strlen(t+1); int len = 0; for(int i = 1; i &lt;= tlen; i++){ if(t[i] == '2' &amp;&amp; t[i+1] != '(') s[++len] = '2', s[++len] = '(', s[++len] = '1', s[++len] = ')'; else s[++len] = t[i]; } stack&lt;int&gt; stk; for(int i = 1; i &lt;= len; i++){ if(s[i] == '(') stk.push(i); else if(s[i] == ')') p[stk.top()] = i, stk.pop(); } for(int i = 1; i &lt;= len; i++){ if(s[i] == '('){ ans[get(i+1, p[i]-1)]++; i = p[i]; } } BigNum res(0); BigNum base(1); for(int i = 0; i &lt;= 600; i++, base = base * BigNum(2)) res = res + BigNum(ans[i]) * base; cout &lt;&lt; res &lt;&lt; endl; return 0;} 1print(eval(input().replace('(', '**('))) E Groundhog Chasing Death把 $x,y$ 分解质因数，考虑每一个质因子对答案的贡献。 设枚举的质因子为 $p$，$x$ 中含有 $\\alpha$ 个 $p$，$y$ 中含有 $\\beta$ 个 $p$，那么 $p$ 对答案的贡献是 $p$ 的 $\\sum\\limits_{i=a}^b\\sum\\limits_{j=c}^d\\min(i\\alpha,j\\beta)$ 次方。枚举 $i\\alpha$ 和 $j\\beta$ 作为最小值，可以 $O(1)$ 地计算贡献，记得不要重复计算 $i\\alpha=j\\beta$ 的情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 998244353;LL a, b, c, d, x, y;map&lt;int, int&gt; xx, yy;inline LL fpow(LL bs, LL idx){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int main(){ read(a, b, c, d, x, y); vector&lt;int&gt; factors; for(int i = 2; i * i &lt;= x; i++){ if(x % i == 0) factors.pb(i); while(x % i == 0) x /= i, xx[i]++; } if(x &gt; 1) factors.pb(x), xx[x]++; for(int i = 2; i * i &lt;= y; i++){ if(y % i == 0) factors.pb(i); while(y % i == 0) y /= i, yy[i]++; } if(y &gt; 1) factors.pb(y), yy[y]++; sort(factors.begin(), factors.end()); factors.erase(unique(factors.begin(), factors.end()), factors.end()); LL ans = 1; for(auto &amp;p : factors){ LL res = 0; LL alpha = xx[p], beta = yy[p]; if(alpha == 0 || beta == 0) continue; for(LL i = a; i &lt;= b; i++){ LL j = i * alpha / beta; while(j * beta &lt; i * alpha) j++; j = max(j, c); if(d - j + 1 &gt; 0) (res += (d - j + 1) * alpha % (MOD - 1) * i) %= (MOD - 1); } for(LL j = c; j &lt;= d; j++){ LL i = j * beta / alpha + 1; i = max(i, a); if(b - i + 1 &gt; 0) (res += (b - i + 1) * beta % (MOD - 1) * j) %= (MOD - 1); } (ans *= fpow(p, res)) %= MOD; } printf(&quot;%lld\\n&quot;, ans); return 0;} F Groundhog Looking Dowdy把所有衣服拿出来按 dowdiness 排序，因为求的是最小极差，所以选取衣服是连续的一段，因此尺取即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2000005;int n, m, cnt[N], k, tot;struct Node{ int val, day; bool operator &lt; (const Node &amp;A) const{ return val &lt; A.val; }}a[N];int main(){ read(n, m); for(int i = 1; i &lt;= n; i++){ int ki; for(read(ki); ki; ki--){ int val; read(val); a[++tot] = (Node){val, i}; } } sort(a+1, a+tot+1); int ans = 1e9; for(int l = 1, r = 0; l &lt;= tot; l++){ while(r &lt; tot &amp;&amp; k &lt; m){ r++; if(cnt[a[r].day] == 0) k++; cnt[a[r].day]++; if(k &gt;= m) ans = min(ans, a[r].val - a[l].val); } cnt[a[l].day]--; if(cnt[a[l].day] == 0) k--; if(k &gt;= m) ans = min(ans, a[r].val - a[l].val); } printf(&quot;%d\\n&quot;, ans); return 0;} G Groundhog Playing Scissors思路明明和题解一模一样，结果比赛的时候总是 WA。 旋转多边形换成旋转直线，那么直线其实是一个圆的所有切线。设圆与多边形相交于两点，可以想象，在一定范围内这两点始终在特定的两条边上移动——这些范围就是用所有多边形的顶点做圆的切线之后划分出来的范围。每一个范围内，切出来的线段长度是下凸的，三分找到最小值，然后左右两边二分找距离等于 $L$ 的角度，即可得到这个范围内哪些角度满足线段长度 $\\leqslant L$。如何得到两个交点移动的特定两条边呢？注意直线再旋转的过程中，这两条边也在逆时针旋转，所以两个指针移动即可；判定是否需要更换边用范围正中的那条线判断。 然而现在只过了 $75%$ 的数据。。。 I The Crime-solving Plan of Groundhog可以证明，答案就是取最小的正整数，乘上其他数从小到大排列起来（当然第一个数不能是 $0$）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 400005;int T, n, a[N];int ans[N];int main(){ for(read(T); T; T--){ read(n); vector&lt;int&gt; b(10); for(int i = 1; i &lt;= n; i++){ read(a[i]); b[a[i]]++; } int now = 0; for(int i = 1; i &lt;= n; i++){ while(!b[now]) now++; a[i] = now, b[now]--; } int pos = 0; for(pos = 2; pos &lt;= n; pos++) if(a[pos] != 0 &amp;&amp; a[pos-1] != 0) break; a[1] = a[pos-1], a[2] = a[pos]; for(int i = 3; i &lt;= pos; i++) a[i] = 0; for(int i = 2; i &lt;= n; i++) ans[i-1] = a[i]; int x = 0; for(int i = n-1; i &gt;= 1; i--){ ans[i] = ans[i] * a[1] + x; x = ans[i] / 10; ans[i] %= 10; } ans[0] = x; pos = 0; while(!ans[pos]) pos++; for(int i = pos; i &lt;= n-1; i++) printf(&quot;%d&quot;, ans[i]); puts(&quot;&quot;); } return 0;} J The Escape Plan of Groundhog这种题都是枚举上下边界，然后枚举右边界，统计合法左边界数目。 这道题也是这样，我们把 $0$ 换成 $-1$，做二维前缀和（那么和数就代表了桌子比空位多了多少）。在我们扫右边界的过程中，如果这一列全是 $1$，也就是说它可以作为右边界，那么把它的前缀和和加到桶里，而它作为右边界对答案的贡献可以在这之前在桶里面查询。当然注意，合法矩形的上下边界必须是连续的 $1$，所以一旦不满足该条件就把桶清空。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int n, m, a[N][N], sum[N][N];int buc[N*N];vi v;LL ans;inline int get(int u, int d, int l, int r){ if(u &gt; d || l &gt; r) return 0; return sum[d][r] - sum[u-1][r] - sum[d][l-1] + sum[u-1][l-1];}int main(){ read(n, m); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ read(a[i][j]); if(a[i][j] == 0) a[i][j] = -1; sum[i][j] = a[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]; } } for(int u = 1; u &lt;= n; u++){ for(int d = u + 1; d &lt;= n; d++){ for(auto &amp;k : v) buc[k] = 0; v.clear(); for(int p = 1; p &lt;= m; p++){ if(a[u][p] == -1 || a[d][p] == -1){ for(auto &amp;k : v) buc[k] = 0; v.clear(); } else if(get(u, d, p, p) == d - u + 1){ int s = get(u+1, d-1, 1, p-1); ans += buc[s-1+500000] + buc[s+500000] + buc[s+1+500000]; buc[get(u+1, d-1, 1, p)+500000]++; v.pb(get(u+1, d-1, 1, p)+500000); } } } } printf(&quot;%lld\\n&quot;, ans); return 0;} K The Flee Plan of Groundhog以 $n$ 为根，我们很容易得到 Groundhog 在 $t$ 时刻的位置，接下来他有两种走法，要么直接往现在的子树里找最深的一条路跑，要么往上走一些边，再往子树里最深的一条路跑，枚举往上走的边数，每次 $O(1)$ 计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, t;vi edge[N];int fa[N], dep[N], mxlen[N];void dfs(int x, int f, int depth){ fa[x] = f, dep[x] = depth, mxlen[x] = 0; for(auto &amp;to : edge[x]){ if(to == f) continue; dfs(to, x, depth+1); mxlen[x] = max(mxlen[x], mxlen[to] + 1); }}inline int calc(int x, int dis){ if(mxlen[x] &gt;= dis) return dis; else return (dis - mxlen[x] + 1) / 2 + mxlen[x];}int main(){ read(n, t); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); } dfs(n, 0, 0); int now = 1; while(now != n &amp;&amp; t--) now = fa[now]; int pos = now; int ans = (dep[pos] + 1) / 2; for(int d = 0; now; now = fa[now], d++){ if(dep[pos] &lt;= d * 3) break; ans = max(ans, calc(now, dep[pos] - d * 3)); } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/08/08/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B9%9D%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第五场）","text":"比赛链接 收获 比赛要把所有题都看一遍——即便是那些很少人过的题（队友最后 10min 才发现会做 $A$ 题……） 学会了一个求 $\\text{MST}$ 的新姿势——$\\textbf{Boruvka}$ 算法 A Portal先鸽一会儿…… B Graph设 $dis[i]$ 表示 $i$ 号节点到根的路径上所有权值的异或，那么连上的边 $(u,v)$ 的权值等于形成的环中其它边的异或值，也就等于 $dis[u]\\text{ XOR }dis[v]$，所以问题转化为：$n$ 个值，两两连边的权值为 $dis[a]\\text{ XOR }dis[b]$，求最小生成树。 这就和 $\\text{CF888G}$ 一毛一样啊……采用 $\\textbf{Boruvka}$ 算法的思想，在 $\\text{Trie}$ 树上进行合并。 B.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int INF = 2e9;const int N = 100005;int n, dis[N];LL ans;vector&lt;pii&gt; edge[N];void dfs(int x, int f, int xorval){ dis[x] = xorval; for(auto &amp;to : edge[x]){ if(to.first == f) continue; dfs(to.first, x, xorval ^ to.second); }}inline int get(int val, int k){ return (val &gt;&gt; k) &amp; 1; }struct Trie{ int son[2], val; Trie(){ son[0] = son[1] = 0, val = -1; }}tr[N*20];int tot;void insert(int val){ int now = 0; for(int i = 30; i &gt;= 0; i--){ if(!tr[now].son[get(val, i)]) tr[now].son[get(val, i)] = ++tot; now = tr[now].son[get(val, i)]; } tr[now].val = val;}int getMin(int now, int val, int k){ if(k == -1) return tr[now].val ^ val; if(!tr[now].son[get(val, k)]) return getMin(tr[now].son[!get(val, k)], val, k-1); else return getMin(tr[now].son[get(val, k)], val, k-1);}void dfs(int now, vi &amp;v){ if(tr[now].val != -1){ v.pb(tr[now].val); return; } if(tr[now].son[0]) dfs(tr[now].son[0], v); if(tr[now].son[1]) dfs(tr[now].son[1], v);}void getAns(int x, int dep){ if(tr[x].son[0]) getAns(tr[x].son[0], dep - 1); if(tr[x].son[1]) getAns(tr[x].son[1], dep - 1); if(tr[x].son[0] &amp;&amp; tr[x].son[1]){ vi v; dfs(tr[x].son[0], v); int mn = 2e9; for(auto &amp;val : v){ int res = getMin(tr[x].son[1], val, dep - 1); mn = min(mn, res | (1 &lt;&lt; dep)); } ans += mn; }}int main(){ read(n); for(int i = 1; i &lt; n; i++){ int u, v, w; read(u, v, w); u++, v++; edge[u].pb(mp(v, w)), edge[v].pb(mp(u, w)); } dfs(1, 0, 0); for(int i = 1; i &lt;= n; i++) insert(dis[i]); getAns(0, 30); printf(&quot;%lld\\n&quot;, ans); return 0;} C Easy队友做的，生成函数。 D Drop Voicing题目可以转换成：一次操作为任意选一个数插入到任意一个位置，求最少多少次操作使序列有序（可以是转动后有序）。 可以预想到，把最长上升子序列求出来，其他数插入到该在的位置是最好的方案，操作数为 $n$ 减去 $\\text{LIS}$ 的长度。由于可以转动，我们需要求转出来的 $n$ 个序列的 $\\text{LIS}$。 复杂度：$O(n^2\\lg n)$ D.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 505;int dp[N];int LIS(int n, vector&lt;int&gt; &amp;a){ memset(dp, 0, sizeof dp); // dp[i]: a substring whose length is i ends at dp[i] int len = 0; for(int i = 1; i &lt;= n; i++){ if(a[i] &gt;= dp[len]) dp[++len] = a[i]; else{ int p = upper_bound(dp+1, dp+len+1, a[i]) - dp; dp[p] = a[i]; } } return len;}int n, p[N];int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(p[i]); int ans = 1e9; for(int i = 1; i &lt;= n; i++){ vi t(n+5); int tid = 0; for(int j = i; j &lt;= n; j++) t[++tid] = p[j]; for(int j = 1; j &lt; i; j++) t[++tid] = p[j]; ans = min(ans, n - LIS(n, t)); } printf(&quot;%d\\n&quot;, ans); return 0;} E Bogo Sort根据 $p$ 序列可以得到若干个环，答案就是所有环的长度的 $\\text{lcm}$。需要高精度。 E.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define pb(x) push_back(x)#define mp(x, y) make_pair(x, y)const int N = 100005;int n, p[N], a[N], mx;bool vis[N];struct BigNum{ vector&lt;int&gt; a; // a[n-1]...a[1]a[0] int neg; BigNum(){ a.clear(); neg = 1; } explicit BigNum(const string &amp;s){ a.clear(); int len = s.length(); for(int i = 0; i &lt; len; i++) a.pb(s[len-i-1] - '0'); } explicit BigNum(LL num){ a.clear(); do{ a.pb(num % 10); num /= 10; }while(num); } BigNum operator = (const string &amp;s){ return *this = BigNum(s); } BigNum operator = (LL num){ return *this = BigNum(num); } bool operator &lt; (const BigNum &amp;b) const{ if(a.size() != b.a.size()) return a.size() &lt; b.a.size(); for(int i = a.size() - 1; i &gt;= 0; i--) if(a[i] != b.a[i]) return a[i] &lt; b.a[i]; return false; } bool operator &gt; (const BigNum &amp;b) const{ return b &lt; *this; } bool operator &lt;= (const BigNum &amp;b) const{ return !(*this &gt; b); } bool operator &gt;= (const BigNum &amp;b) const{ return !(*this &lt; b); } bool operator != (const BigNum &amp;b) const{ return (*this &gt; b) || (*this &lt; b); } bool operator == (const BigNum &amp;b) const{ return !(*this &lt; b) &amp;&amp; !(*this &gt; b); } BigNum operator + (const BigNum &amp;b) const{ BigNum C; int x = 0; for(int i = 0, g = 0; ; i++){ if(g == 0 &amp;&amp; i &gt;= a.size() &amp;&amp; i &gt;= b.a.size()) break; x = g; if(i &lt; a.size()) x += a[i]; if(i &lt; b.a.size()) x += b.a[i]; C.a.pb(x % 10); g = x / 10; } if(C.a.size() &gt; n) C.a.resize(n); return C; } BigNum operator * (const BigNum &amp;b) const{ BigNum C; C.a.resize(a.size() + b.a.size()); for(int i = 0; i &lt; a.size(); i++){ int g = 0; for(int j = 0; j &lt; b.a.size(); j++){ if(i + j &gt;= n) break; C.a[i+j] += a[i] * b.a[j] + g; g = C.a[i+j] / 10; C.a[i+j] %= 10; } if(i + b.a.size() &lt; n) C.a[i+b.a.size()] = g; } while(C.a.size() &gt; 1 &amp;&amp; C.a.back() == 0) C.a.pop_back(); if(C.a.size() &gt; n) C.a.resize(n); return C; } BigNum operator += (const BigNum &amp;b){ *this = *this + b; return *this; } BigNum operator *= (const BigNum &amp;b){ *this = *this * b; return *this; }};ostream&amp; operator &lt;&lt; (ostream &amp;out, const BigNum &amp;b){ string res; if(b.neg == -1) res += '-'; for(int i = b.a.size() - 1; i &gt;= 0; i--) res += b.a[i] + '0'; return out &lt;&lt; res;}istream&amp; operator &gt;&gt; (istream &amp;in, BigNum &amp;b){ string str; if(in &gt;&gt; str) b = str; return in;}int main(){ // freopen(&quot;E_data.in&quot;, &quot;r&quot;, stdin); std::ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i], mx = max(mx, p[i]); for(int i = 1; i &lt;= n; i++){ int now = i, len = 0; if(vis[now]) continue; while(!vis[now]){ vis[now] = true; len++; now = p[now]; } for(int i = 2; 1ll * i * i &lt;= len; i++){ if(len % i) continue; int cnt = 0; while(len % i == 0) len /= i, cnt++; a[i] = max(a[i], cnt); } if(len &gt; 1) a[len] = max(a[len], 1); } BigNum ans(1ll); for(int i = 1; i &lt;= mx; i++) for(int j = 1; j &lt;= a[i]; j++) ans *= BigNum(i); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;} F DPS签到题，注意开 long long（为此 WA 了两发，呜呜呜～） F.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 105;int n;LL d[N], mxd = -1, s[N];int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(d[i]); mxd = max(mxd, d[i]); } for(int i = 1; i &lt;= n; i++){ s[i] = 50ll * d[i] / mxd; while(s[i] * mxd &lt; 50ll * d[i]) s[i]++; putchar('+'); for(int k = 1; k &lt;= s[i]; k++) putchar('-'); putchar('+'); puts(&quot;&quot;); putchar('|'); for(int k = 1; k &lt; s[i]; k++) putchar(' '); if(s[i] &gt; 0) putchar(d[i] == mxd ? '*' : ' '); putchar('|'); printf(&quot;%lld\\n&quot;, d[i]); putchar('+'); for(int k = 1; k &lt;= s[i]; k++) putchar('-'); putchar('+'); puts(&quot;&quot;); } return 0;} I Hard Math Problem答案就是 $\\frac{2}{3}$，构造如下：$$\\begin{matrix}&amp;&amp;&amp;1&amp;\\cdots\\&amp;&amp;1&amp;3&amp;1&amp;1&amp;\\cdots\\&amp;1&amp;2&amp;1&amp;1&amp;3&amp;1\\1&amp;3&amp;1&amp;1&amp;2&amp;1\\2&amp;1&amp;1&amp;3&amp;1&amp;\\end{matrix}$$ I.py >folded1print(0.666667)","link":"/blog-xcpc/2020/07/25/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第八场）","text":"比赛链接 G Game SET出题人表示直接暴力就好…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 505;int n;string s;int p[N][10];inline bool check(int i, int j, int k){ for(int l = 1; l &lt;= 4; l++){ if(p[i][l] &amp;&amp; p[j][l] &amp;&amp; p[k][l]){ if(p[i][l] != p[j][l] &amp;&amp; (p[i][l] == p[k][l] || p[j][l] == p[k][l])) return false; if(p[j][l] != p[k][l] &amp;&amp; (p[j][l] == p[i][l] || p[k][l] == p[i][l])) return false; if(p[k][l] != p[i][l] &amp;&amp; (p[k][l] == p[j][l] || p[i][l] == p[j][l])) return false; } } return true;}inline void solve(int T){ if(n &lt;= 2){ printf(&quot;Case #%d: -1\\n&quot;, T); return; } for(int i = 1; i &lt;= n; i++){ for(int j = i + 1; j &lt;= n; j++){ for(int k = j + 1; k &lt;= n; k++){ if(check(i, j, k)){ printf(&quot;Case #%d: %d %d %d\\n&quot;, T, i, j, k); return; } } } } printf(&quot;Case #%d: -1\\n&quot;, T);}inline int f(string t){ if(t == &quot;one&quot;) return 1; if(t == &quot;two&quot;) return 2; if(t == &quot;three&quot;) return 3; if(t == &quot;diamond&quot;) return 1; if(t == &quot;oval&quot;) return 2; if(t == &quot;squiggle&quot;) return 3; if(t == &quot;solid&quot;) return 1; if(t == &quot;striped&quot;) return 2; if(t == &quot;open&quot;) return 3; if(t == &quot;red&quot;) return 1; if(t == &quot;green&quot;) return 2; if(t == &quot;purple&quot;) return 3; if(t == &quot;*&quot;) return 0;}int main(){ int CASES = 0; int T; for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; s; string t; int cnt = 0; for(int j = 0; j &lt; s.size(); j++){ if(s[j] == '[') t.clear(); else if(s[j] == ']') p[i][++cnt] = f(t); else t += s[j]; } } solve(++CASES); } return 0;} I Interesting Computer Game把每个数字看成点，一对数看成边，则形成一个含若干连通分量的图。若一个连通分量中含有环，则其大小加入答案；否则，其大小减一加入答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, a[N], b[N], t[N];int fa[N], sz[N];bool loop[N];int findfa(int x){ return x == fa[x] ? x : fa[x] = findfa(fa[x]); }void unionn(int x, int y){ x = findfa(x), y = findfa(y); fa[y] = x; loop[x] |= loop[y]; sz[x] += sz[y];}int main(){ int CASES = 0; int T; for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= (n &lt;&lt; 1); i++) fa[i] = i, loop[i] = false, sz[i] = 1; t[0] = 0; for(int i = 1; i &lt;= n; i++){ read(a[i], b[i]); t[++t[0]] = a[i], t[++t[0]] = b[i]; } sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++){ a[i] = lower_bound(t+1, t+t[0]+1, a[i]) - t; b[i] = lower_bound(t+1, t+t[0]+1, b[i]) - t; if(findfa(a[i]) == findfa(b[i])) loop[findfa(a[i])] = true; else unionn(a[i], b[i]); } int ans = 0; for(int i = 1; i &lt;= t[0]; i++){ if(fa[i] != i) continue; ans += loop[i] ? sz[i] : sz[i] - 1; } printf(&quot;Case #%d: %d\\n&quot;, ++CASES, ans); } return 0;} K Kabaleo Lite先把 $b$ 削成不增的，然后在前缀和最大处取完，如此不断进行即可。 这道题居然丧心病狂地卡 long long，要用 __int128…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n;LL a[N], b[N];void print(__int128 x){ if(!x) return; if(x &lt; 0) putchar('-'), x = -x; print(x / 10); putchar(x % 10 + '0');}int main(){ int CASES = 0; int T; for(read(T); T; T--){ read(n); b[0] = 1e5; priority_queue&lt; pair&lt;LL, int&gt; &gt; q; for(int i = 1; i &lt;= n; i++){ read(a[i]), a[i] += a[i-1]; q.push(mp(a[i], i)); } for(int i = 1; i &lt;= n; i++) read(b[i]), b[i] = min(b[i-1], b[i]); int pt = n; __int128 ans = 0; LL val = 0, cnt = 0; while(1){ while(!q.empty() &amp;&amp; (q.top().second &gt; pt || b[q.top().second] &lt;= cnt)) q.pop(); if(q.empty()) break; pt = q.top().second, val = q.top().first; q.pop(); ans += (__int128)val * (b[pt] - cnt); cnt = b[pt]; } printf(&quot;Case #%d: %lld &quot;, ++CASES, cnt), print(ans), puts(&quot;&quot;); } return 0;}","link":"/blog-xcpc/2020/08/08/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%85%AB%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第十场）","text":"比赛链接 A Permutation打了个表，发现一直乘 $2$，不行就乘 $3$，然后继续一直乘 $2$…… 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1000005;int T, p;int main(){ for(read(T); T; T--){ read(p); int now = 1; vi ans; bool ok = true; vector&lt;bool&gt; b(p); ans.pb(now); b[now] = true; while(ans.size() &lt; p - 1){ if(b[now*2% p] &amp;&amp; b[now*3%p]){ ok = false; break; } if(b[now*2%p]) now = now*3%p; else now = now*2%p; ans.pb(now); b[now] = true; } if(!ok) puts(&quot;-1&quot;); else{ for(auto &amp;k : ans) printf(&quot;%d &quot;, k); puts(&quot;&quot;); } } return 0;} E Game二分答案，把大于二分的答案的列往右推。 事实上，再进一步思考的话可以发现，答案就是 $\\max\\left{\\left\\lceil\\frac{\\sum_{i=1}^ka_i}{k}\\right\\rceil\\right}$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, a[N], b[N];bool check(int h){ LL vacant = 0, extra = 0; for(int i = 1; i &lt;= n; i++) b[i] = a[i]; for(int i = n; i &gt;= 1; i--){ if(b[i] &lt;= h) continue; int pt = i; while(pt &gt;= 1){ if(b[pt] &lt;= h) vacant += h - b[pt]; else extra += b[pt] - h; if(extra &lt;= vacant){ extra = 0, vacant = 0; break; } pt--; } if(pt == 0) return false; i = pt; } return true;}int main(){ for(read(T); T; T--){ read(n); int l = 1, r = 0; for(int i = 1; i &lt;= n; i++){ read(a[i]); r = max(r, a[i]); } while(l &lt; r){ int mid = 1ll * (l + r) / 2; if(check(mid)) r = mid; else l = mid + 1; } printf(&quot;%d\\n&quot;, l); } return 0;} J Identical Trees设 $dp[i][j]$ 表示第一棵树的以 $i$ 节点为根的子树和第二棵树的以 $j$ 节点为根的子树的最少更改次数，转移时考虑所有子节点的匹配，就是一个二分图最大权匹配问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef unsigned long long ULL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2005;const int M = 1000005;const LL INF = 1e14;bool notP[N];int pList[N], pID;void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0) break; } }}namespace KM{ int n; LL w[N][N]; int matchx[N], matchy[N]; LL lx[N], ly[N]; LL slack[N]; bool visx[N], visy[N]; queue&lt;int&gt; q; int pre[N]; bool check(int cur){ visy[cur] = true; if(matchy[cur]){ if(!visx[matchy[cur]]){ q.push(matchy[cur]); visx[matchy[cur]] = true; } return false; } while(cur) swap(cur, matchx[matchy[cur] = pre[cur]]); return true; } void bfs(int s){ fill(visx, visx+n+1, false); fill(visy, visy+n+1, false); fill(slack, slack+n+1, INF); while(!q.empty()) q.pop(); q.push(s), visx[s] = true; while(1){ while(!q.empty()){ int cur = q.front(); q.pop(); for(int i = 1; i &lt;= n; i++){ LL diff = lx[cur] + ly[i] - w[cur][i]; if(!visy[i] &amp;&amp; diff &lt;= slack[i]){ slack[i] = diff; pre[i] = cur; if(diff == 0) if(check(i)) return; } } } LL delta = INF; for(int i = 1; i &lt;= n; i++) if(!visy[i] &amp;&amp; slack[i]) delta = min(delta, slack[i]); for(int i = 1; i &lt;= n; i++){ if(visx[i]) lx[i] -= delta; if(visy[i]) ly[i] += delta; else slack[i] -= delta; } while(!q.empty()) q.pop(); for(int i = 1; i &lt;= n; i++) if(!visy[i] &amp;&amp; !slack[i] &amp;&amp; check(i)) return; } } void solve(){ fill(matchx, matchx+n+1, 0); fill(matchy, matchy+n+1, 0); fill(ly, ly+n+1, 0); for(int i = 1; i &lt;= n; i++){ lx[i] = 0; for(int j = 1; j &lt;= n; j++) lx[i] = max(lx[i], w[i][j]); } for(int i = 1; i &lt;= n; i++) bfs(i); }}int n, fax[N], fay[N], rtx, rty;vi edgex[N], edgey[N];int szx[N], szy[N];ULL valx[N], valy[N];void dfs(int x, vi edge[], int sz[], ULL val[]){ sz[x] = 1, val[x] = 1; for(auto &amp;to : edge[x]){ dfs(to, edge, sz, val); sz[x] += sz[to]; val[x] += pList[sz[to]] * val[to]; }}LL dp[N][N];LL solve(int x, int y){ if(valx[x] != valy[y]) return INF; if(dp[x][y] != -1) return dp[x][y]; dp[x][y] = x != y; int sz = edgex[x].size(); if(sz == 0) return dp[x][y]; for(int i = 0; i &lt; sz; i++) for(int j = 0; j &lt; sz; j++) dp[edgex[x][i]][edgey[y][j]] = solve(edgex[x][i], edgey[y][j]); KM::n = sz; for(int i = 1; i &lt;= sz; i++) for(int j = 1; j &lt;= sz; j++) KM::w[i][j] = -INF; for(int i = 0; i &lt; sz; i++) for(int j = 0; j &lt; sz; j++) KM::w[i+1][j+1] = -dp[edgex[x][i]][edgey[y][j]]; KM::solve(); for(int i = 1; i &lt;= sz; i++) dp[x][y] += -KM::w[i][KM::matchx[i]]; return dp[x][y];}int main(){ memset(dp, -1, sizeof dp); Euler(2000); read(n); for(int i = 1; i &lt;= n; i++){ read(fax[i]); if(!fax[i]) rtx = i; else edgex[fax[i]].pb(i); } for(int i = 1; i &lt;= n; i++){ read(fay[i]); if(!fay[i]) rty = i; else edgey[fay[i]].pb(i); } dfs(rtx, edgex, szx, valx), dfs(rty, edgey, szy, valy); printf(&quot;%lld\\n&quot;, solve(rtx, rty)); return 0;}","link":"/blog-xcpc/2020/08/10/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%8D%81%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第六场）","text":"比赛链接 收获 给定一个排列 $p_i$，从 $i$ 向 $p_i$ 连边可以形成若干环。和排列相关的题可以这样想一下。 A African Sort留坑，待补 B Binary Vector每次加入的向量都不属于之前的向量空间，故 $f_n=\\prod\\limits_{i=0}^{n-1}\\left(1-\\frac{2^i}{2^n}\\right)=\\frac{\\prod\\limits_{i=0}^{n-1}(2^n-2^i)}{2^{n^2}}$。易得递推式：$f_n=f_{n-1}\\cdot\\frac{2^n-1}{2^n}$。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 1e9 + 7;const LL inv2 = 500000004;const int N = 2e7+5;int T, n;LL f[N], inv = inv2;int main(){ f[1] = 5e8+4; for(int i = 2; i &lt;= 2e7; i++){ (inv *= inv2) %= MOD; f[i] = (f[i-1] * (1 - inv) % MOD + MOD) % MOD; } for(int i = 2; i &lt;= 2e7; i++) f[i] ^= f[i-1]; for(read(T); T; T--){ read(n); printf(&quot;%lld\\n&quot;, f[n]); } return 0;} C Combination of Physics and Maths又做麻烦了…… 首先，如果选出的矩形有多列，那么一定可以把它分开，分出的一部分答案不会更差。证明：设 $\\frac{a}{b}\\leqslant\\frac{c}{d}$，那么 $\\frac{a}{b}\\leqslant\\frac{a+c}{b+d}\\leqslant\\frac{c}{d}$。所以答案是一列。 枚举这一列的最下面的数字，把它上面的所有数字都选上，更新答案。 复杂度：$O(Tnm)$ 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 205;int T, n, m;LL a[N][N], colSum[N][N];int main(){ for(read(T); T; T--){ read(n, m); for(int j = 1; j &lt;= m; j++) colSum[0][j] = 0; double ans = 0; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ read(a[i][j]); colSum[i][j] = colSum[i-1][j] + a[i][j]; ans = max(ans, 1.0 * colSum[i][j] / a[i][j]); } } printf(&quot;%.8f\\n&quot;, ans); } return 0;} E Easy Construction$n$ 个数的和要满足条件，所以 $\\frac{n(n+1)}{2}\\bmod n=k$。 当 $n$ 是奇数时，一定有 $k=0$，所以构造 ${n,1,n-1,2,n-2,\\dots}$； 当 $n$ 是偶数时，$\\frac{n(n+1)}{2}\\equiv k\\pmod n\\iff n(n+1)\\equiv 2k\\pmod n\\iff k=\\frac{n}{2}$，所以构造 $\\left{n,\\frac{n}{2},1,n-1,2,n-2,\\cdots\\right}$。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int n, k;int main(){ read(n, k); if(n * (n + 1) / 2 % n != k) return puts(&quot;-1&quot;), 0; if(n &amp; 1){ printf(&quot;%d &quot;, n); for(int i = 1; i &lt;= n / 2; i++) printf(&quot;%d %d &quot;, i, n - i); puts(&quot;&quot;); } else{ printf(&quot;%d %d &quot;, n, n / 2); for(int i = 1; i &lt; n / 2; i++) printf(&quot;%d %d &quot;, i, n - i); puts(&quot;&quot;); } return 0;} G Grid Coloring$n=1,k=1,k\\nmid 2n(n+1)$ 的情况无解，其余情况可以构造。 一种简单的构造方法是：轮换着用颜色按顺序涂水平边和竖直边。这样做相当于把格子涂成了阶梯状。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, k;int main(){ for(read(T); T; T--){ read(n, k); if(2 * n * (n + 1) % k){ puts(&quot;-1&quot;); continue; } if(n == 1 || k == 1){ puts(&quot;-1&quot;); continue; } int now = 0; vi vert; for(int i = 1; i &lt;= n + 1; i++){ for(int j = 1; j &lt;= n; j++){ now = now % k + 1; printf(&quot;%d &quot;, now); } puts(&quot;&quot;); if(i &lt;= n){ for(int j = 1; j &lt;= n + 1; j++){ now = now % k + 1; vert.pb(now); } } } for(int i = 0; i &lt;= n; i++){ for(int j = i; j &lt; n * (n + 1); j += n + 1) printf(&quot;%d &quot;, vert[j]); puts(&quot;&quot;); } } return 0;} H Harmony Pairs一个无比暴力的数位 $\\text{dp}$。 设 $dp[i,j,0/1,0/1/2]$ 表示“从高到低考虑前 $i$ 位数，$S(A)$ 和 $S(B)$ 之差为 $j$，$B$ 是否顶住上界，$A$ 和 $B$ 的关系是什么”的数有多少，然后暴力枚举 $A$ 和 $B$ 第 $i$ 位的数字进行转移。 复杂度：$O(n^2\\cdot 10^3)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 1e9 + 7;int n;char s[105];LL dp[105][2005][2][3];int main(){ scanf(&quot;%s&quot;, s+1); n = strlen(s+1); dp[0][1000][1][0] = 1; for(int i = 1; i &lt;= n; i++){ for(int j = -900; j &lt;= 900; j++){ for(int A = 0; A &lt;= 9; A++){ for(int B = 0; B &lt;= 9; B++){ int diff = j + A - B; if(diff &lt; -900 || diff &gt; 900) continue; if(A == B) (dp[i][diff+1000][0][0] += dp[i-1][j+1000][0][0]) %= MOD; else if(A &lt; B) (dp[i][diff+1000][0][1] += dp[i-1][j+1000][0][0]) %= MOD; else (dp[i][diff+1000][0][2] += dp[i-1][j+1000][0][0]) %= MOD; (dp[i][diff+1000][0][1] += dp[i-1][j+1000][0][1]) %= MOD; (dp[i][diff+1000][0][2] += dp[i-1][j+1000][0][2]) %= MOD; if(B &gt; (s[i]-'0')) continue; if(B == s[i]-'0'){ if(A == B) (dp[i][diff+1000][1][0] += dp[i-1][j+1000][1][0]) %= MOD; else if(A &lt; B) (dp[i][diff+1000][1][1] += dp[i-1][j+1000][1][0]) %= MOD; (dp[i][diff+1000][1][1] += dp[i-1][j+1000][1][1]) %= MOD; } else{ if(A == B) (dp[i][diff+1000][0][0] += dp[i-1][j+1000][1][0]) %= MOD; else if(A &lt; B) (dp[i][diff+1000][0][1] += dp[i-1][j+1000][1][0]) %= MOD; else (dp[i][diff+1000][0][2] += dp[i-1][j+1000][1][0]) %= MOD; (dp[i][diff+1000][0][1] += dp[i-1][j+1000][1][1]) %= MOD; (dp[i][diff+1000][0][2] += dp[i-1][j+1000][1][2]) %= MOD; } } } } } LL res = 0; for(int d = 1; d &lt;= 900; d++){ res += dp[n][d+1000][0][0] + dp[n][d+1000][0][1] + dp[n][d+1000][1][0] + dp[n][d+1000][1][1]; res %= MOD; } printf(&quot;%lld\\n&quot;, res); return 0;} J Josephus Transform这道题的关键在与求出一次 $k$ 约瑟夫变换的置换数组，这之后置换 $x$ 次可以快速幂完成。 设上一次取出的数当时从左往右数第 $p$ 个，现在还剩 $c$ 个数，那么这次取出的数是从 $p$ 开始数 $k$ 个，对 $c$ 取模，即第 $(p+k-1-1)\\bmod c+1$ 个数。可以用线段树完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, m, k, x;struct segTree{ int l, r, sz;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].sz = tr[lid].sz + tr[rid].sz;}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; if(l == r){ tr[id].sz = 1; return; } build(lid, l, mid), build(rid, mid+1, r); pushup(id);}void del(int id, int pos){ if(tr[id].l == tr[id].r){ tr[id].sz--; return; } if(pos &lt;= mid) del(lid, pos); else del(rid, pos); pushup(id);}int queryKth(int id, int k){ if(tr[id].l == tr[id].r) return tr[id].l; if(tr[lid].sz &gt;= k) return queryKth(lid, k); else return queryKth(rid, k - tr[lid].sz);}vi get(){ vi res(n+1); int p = 1, c = n; build(1, 1, n); for(int i = 1; i &lt;= n; i++){ res[i] = queryKth(1, (p + k - 2) % c + 1); del(1, res[i]); p = (p + k - 2) % c + 1, c--; } return res;}inline vi trans(vi a, vi b){ vi res(n+1); for(int i = 1; i &lt;= n; i++) res[i] = a[b[i]]; return res;}inline void fpow(vi &amp;res, vi bs, int idx){ while(idx){ if(idx &amp; 1) res = trans(res, bs); bs = trans(bs, bs); idx &gt;&gt;= 1; }}int main(){ read(n, m); vi a(n+1); for(int i = 1; i &lt;= n; i++) a[i] = i; while(m--){ read(k, x); vi t = get(); fpow(a, t, x); } for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); puts(&quot;&quot;); return 0;} K K-Bag我的做法很玄学，虽然过了，但是不知道正确性到底咋样…… 我先遍历所有数，对每个相同的数从小到大进行编号，但是编号不小于已经编过的号。举例说明：${2,3,2,1,3,3,2,1}$ 的编号是 $1,1,2,2,2,3,3,3$，其中，第三个数字 $2$ 是第二次出现的，所以编号为 $2$ ，第四个数字 $1$ 虽然是第一次出现，但是我们已经有编号为 $2$ 的数了，所以从 $2$ 开始编。其实这样做本质就是把序列给划分了，为判断是否是一个合法的划分，只需要判断除了首尾两段以外，其他编号相同的连续一段长度是否等于 $k$。 但是这样做完会被 $\\text{Hack}$，例如：${2,3,1,3,2,3,2,1,3,2}$ 的编号是 $1,1,1,2,2,3,3,3,4,4$，编号为 $2$ 的长度只有 $2$，会被判断成 NO。究其原因，是因为第三个数 $1$ 本应被划分到后面的段（即本应编为 $2$），却在这里被往前划了。未解决这个问题，我就……呃……从后往前修正一下编号，比如这个 $1$ 的下一个 $1$ 编号是 $3$，所以我就把它编号改成 $3-1=2$，然后就过了……（虽然看上去很不对的样纸） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x) const int N = 500005; int T, n, k, a[N], tag[N], t[N]; bool check(){ for(int i = 1; i &lt;= n; i++){ int j = i; while(j &lt; n &amp;&amp; tag[j+1] == tag[i]) j++; if(j - i + 1 != k) if(i != 1 &amp;&amp; j != n) return false; i = j; } return true;}int main(){ for(read(T); T; T--){ read(n, k); for(int i = 1; i &lt;= n; i++){ read(a[i]); t[i] = a[i]; tag[i] = 0; } sort(t+1, t+n+1); int len = unique(t+1, t+n+1) - (t+1); for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(t+1, t+len+1, a[i]) - t; int mxtag = 0; vi pre(n+5); bool ok = true; for(int i = 1; i &lt;= n; i++){ if(a[i] &gt; k || a[i] &lt; 1){ ok = false; break; } tag[i] = max(mxtag, pre[a[i]] + 1); pre[a[i]] = tag[i]; mxtag = max(mxtag, tag[i]); } if(!ok){ puts(&quot;NO&quot;); continue; } ok = check(); if(ok){ puts(&quot;YES&quot;); continue; } vi suc(n+5); for(int i = n; i &gt;= 1; i--){ if(!suc[a[i]]) suc[a[i]] = tag[i]; else tag[i] = --suc[a[i]]; } ok = check(); if(ok){ puts(&quot;YES&quot;); continue; } else puts(&quot;NO&quot;); } return 0;}","link":"/blog-xcpc/2020/07/27/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%85%AD%E5%9C%BA%EF%BC%89/"},{"title":"2020牛客暑期多校训练营（第四场）","text":"比赛链接 收获 队员之间的信息传递损失可能是卡题的缘由 B Basic Gcd Problem答案其实就是 $c^{p(n)}$，其中 $p(n)$ 表示 $n$ 的质因数个数（要重复统计，例如 $p(12)=p(2\\times2\\times3)=3$）。 $p(n)$ 自然可以先线性筛得到素数，再分解 $n$ 计算；但是还可以更快的直接改一改线性筛就可以了。详见代码。 B.cpp >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x) const int N = 1000005; bool notP[N];int pList[N], pID, pf[N];void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i, pf[i] = 1; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; pf[i * pList[j]] = pf[i] + 1; if(i % pList[j] == 0) break; } }} const LL MOD = 1e9+7; inline LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;} int T;LL n, c; int main(){ Euler(1000000); for(read(T); T; T--){ read(n, c); printf(&quot;%lld\\n&quot;, fpow(c, pf[n])); } return 0;} F Finding the Order假设 $a&lt;b$（否则交换一下并打个标记），那么 $AC,AD$ 一定形如下图（$D$ 在另一侧是对称的，只用考虑一侧）： 找到 $A$ 关于 $D$ 的对称位置，那么如上图，我们得到了三个区域： 如果 $d\\leqslant b$，$B$ 在第二个区域 否则，$d&gt;b$，$B$ 可能在第一个或者第三个区域 若 $c&gt;d$，$B$ 在第三个区域 否则，$B$ 在第一个区域 没错，我又做复杂了，根据两边之和大于第三边，判断一下 $AD+BC&gt;AC+BD$ 就好了。呜呜呜～ F.cpp >folded1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, a, b, c, d;int main(){ for(read(T); T; T--){ read(a, b, c, d); bool sw = false, ABCD = true; if(a &gt; b) sw = true, swap(a, b), swap(c, d); if(d &lt;= b) ABCD = true; else{ if(d &gt; c) ABCD = false; else ABCD = true; } ABCD ^= sw; if(ABCD) puts(&quot;AB//CD&quot;); else puts(&quot;AB//DC&quot;); } return 0;} H Harder Gcd Problem题目要求即将 ${1,2,\\cdots,n}$ 两两配成不互质的数对，问最多配成多少对并给出一种方案。 先说一下我的做法： 将所有数质因数分解，$a={p_1}^{k_1}{p_2}^{k_2}\\cdots{p_r}^{k_r}$，这道题中 $k_1,k_2,\\cdots,k_r$ 并不是重点，所以可以置 $a:=a’=p_1p_2\\cdots p_r$，并记录下它的不同质因数个数 $r$。容易想到的是，一个数不同的质因数越多，它就越可能去跟别人匹配，所以我们把 ${1,2,\\cdots,n}$ 以 $r$ 为第一关键字，以 $a’$ 为第二关键字排序后，从前往后依次考虑还没有匹配的数，用它后面第一个能与它匹配的数去匹配。 实现上，注意 $2e5$ 范围内的数最多有 $6$ 个不同的质因数，所以可以对每个质数开一个队列，存储哪些数有这个质因子（这些队列的大小总和不超过 $6\\times2e5$），注意存储的顺序是按照排序后的顺序。那么枚举到一个待匹配的数，就找它的质因子的那些队列（最多 $6$ 个队列），选排序后位置最靠前的和它匹配即可。 然后是另外的一个构造做法： 首先，大于 $\\frac{n}{2}$ 的质数是不可能匹配的，然后再把 $1$ 去掉，剩下的数两两匹配是答案的理论上界，而事实上这个上界是可以构造出来的。 从大到小考虑小于 $\\frac{n}{2}$ 的那些质数，如果它们及其倍数 $p,2p,\\cdots,kp$ 是偶数个就全部匹配（当然去除已匹配的），否则单出一个 $2p$；这样匹配完之后剩下的数都是 $2$ 的倍数，随便匹配即可。 H.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;bool notP[N];int pList[N], pID;void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0) break; } }}struct Node{ int num, cnt; int val; bool operator &lt; (const Node &amp;A) const{ return cnt == A.cnt ? val &lt; A.val : cnt &lt; A.cnt; }}a[N];vector&lt;int&gt; fac[N];inline void preprocess(){ Euler(200000); for(int i = 2; i &lt;= 200000; i++){ int n = i; for(int j = 1; pList[j] * pList[j] &lt;= n; j++){ if(n % pList[j] == 0) fac[i].pb(pList[j]); while(n % pList[j] == 0) n /= pList[j]; } if(n &gt; 1) fac[i].pb(n); }}int T, n;int main(){ preprocess(); for(read(T); T; T--){ read(n); vector&lt; queue&lt;int&gt; &gt; b(n+5, queue&lt;int&gt;()); vector&lt;bool&gt; tag(n+5); vector&lt;pii&gt; ans; vi pos(n+5); for(int i = 1; i &lt;= n; i++){ a[i].num = i, a[i].cnt = fac[i].size(); a[i].val = 1; for(auto &amp;factor : fac[i]) a[i].val *= factor; } sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i++) pos[a[i].num] = i; for(int i = 1; i &lt;= n; i++) for(auto &amp;factor : fac[a[i].num]) b[factor].push(a[i].num); for(int i = 1; i &lt;= n; i++){ if(tag[a[i].num]) continue; tag[a[i].num] = true; bool ok = false; int mnpos = 1e9, mark = 0; for(auto &amp;factor : fac[a[i].num]){ while(!b[factor].empty() &amp;&amp; tag[b[factor].front()]) b[factor].pop(); if(b[factor].empty()) continue; if(mnpos &gt; pos[b[factor].front()]){ mnpos = pos[b[factor].front()]; mark = factor; } } if(mark == 0) continue; tag[b[mark].front()] = true; ans.pb(mp(a[i].num, b[mark].front())); b[mark].pop(); } printf(&quot;%d\\n&quot;, (int)ans.size()); for(auto &amp;res : ans) printf(&quot;%d %d\\n&quot;, res.first, res.second); } return 0;} 构造做法（好写很多）： H2.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;bool notP[N];int pList[N], pID;void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0) break; } }}int main(){ Euler(200000); int T, n; for(read(T); T; T--){ read(n); vector&lt;pii&gt; ans; vector&lt;bool&gt; tag(n+5); vi rem; int pt = 0; for(pt = 1; pList[pt] * 2 &lt;= n; pt++); pt--; for(int i = pt; i &gt;= 2; i--){ vi v; for(int k = 1; k * pList[i] &lt;= n; k++) if(!tag[k*pList[i]] &amp;&amp; k != 2) v.pb(k); for(int k = 0; k + 1 &lt; v.size(); k += 2){ ans.pb(mp(v[k]*pList[i], v[k+1]*pList[i])); tag[v[k]*pList[i]] = tag[v[k+1]*pList[i]] = true; } if(v.size() &amp; 1){ ans.pb(mp(v.back()*pList[i], 2*pList[i])); tag[v.back()*pList[i]] = tag[2*pList[i]] = true; } else rem.pb(2*pList[i]); } for(int i = 1; i * 2 &lt;= n; i++) if(!tag[i*2]) rem.pb(i*2); sort(rem.begin(), rem.end()); rem.erase(unique(rem.begin(), rem.end()), rem.end()); for(int i = 0; i + 1 &lt; rem.size(); i += 2) ans.pb(mp(rem[i], rem[i+1])); printf(&quot;%d\\n&quot;, (int)ans.size()); for(auto &amp;k : ans) printf(&quot;%d %d\\n&quot;, k.first, k.second); } return 0;}","link":"/blog-xcpc/2020/07/20/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%9C%BA%EF%BC%89/"},{"title":"[AtCoder ABC159F] Knapsack for All Segments","text":"题目链接 Solution这种题首先肯定是转换视角：假设 $A_i\\cdots A_j\\cdots A_k$ 是和为 $S$ 的序列，则它对答案的贡献为 $i\\cdot(n-k+1)$. 于是对于所有在 $A_k$ 结束的和为 $S$ 的序列：$$A_{i_1}\\cdots A_{j_1}\\cdots A_k\\A_{i_2}\\cdots A_{j_2}\\cdots A_k\\\\cdots\\A_{i_r}\\cdots A_{j_r}\\cdots A_k$$它们对答案的贡献为 $(i_1+i_2+\\cdots+i_r)\\cdot(n-k+1)$. 所以我们想枚举结束点 $k$，计算和为 $S$ 且在 $A_k$ 结束的序列的第一个元素的位置之和，即上式第一个括号的值。考虑 $dp$： dp 状态：$dp[k][s]$ 表示在 $A_k$ 结束的序列的第一个元素的位置之和。 转移方程：$dp[k][s] = \\sum\\limits_{i=1}^{k-1}dp[i][s-a[k]]$，特别地，$dp[k][a[k]] = k$. 转移顺序：由转移方程可知，顺序枚举即可 边界条件：无 复杂度：$O(NS)$ Code123456789101112131415161718192021222324252627282930313233343536#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 3005;const LL MOD = 998244353;int n;LL S, a[N], dp[N][N], ans, sum[N][N];int main(){ read(n, S); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int k = 1; k &lt;= n; k++){ (dp[k][a[k]] += k) %= MOD; for(int s = a[k] + 1; s &lt;= S; s++) (dp[k][s] += sum[k-1][s-a[k]]) %= MOD; for(int s = 0; s &lt;= S; s++) sum[k][s] = (sum[k-1][s] + dp[k][s]) % MOD; } for(int i = 1; i &lt;= n; i++) (ans += dp[i][S] * (n - i + 1) % MOD) %= MOD; printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/03/22/AtCoder-ABC159F-Knapsack-for-All-Segments/"},{"title":"[AtCoder ABC154F] Many Many Paths","text":"题目链接 Solution设 $g(x,y)=\\sum\\limits_{i=0}^x\\sum\\limits_{j=0}^y f(i,j)$，即 $f(x,y)$ 的二维前缀和，则答案用二维前缀和的性质加加减减一下即可。问题转化为如何 $O(n)$ 求解 $g(x,y)$. 容易知道的是：$f(x,y)=C_{x+y}^x=\\frac{(x+y)!}{x!\\cdot y!}$，该式在预处理阶乘后配合逆元 $O(\\lg MOD)$ 可求。 我们还需要用到一个性质：$\\sum\\limits_{i=0}^r f(i,c)=f(0,c)+f(1,c)+\\cdots+f(r,c)=f(r,c+1)$，想象走的路线就很容易证明了。 （事实上，上式即 $C_{c}^0+C_{c+1}^1+\\cdots+C_{c+r}^r=C_{c+r+1}^{r}$，可反复运用帕斯卡恒等式证明） 于是，$g(x,y)=\\sum\\limits_{j=0}^y\\sum\\limits_{i=0}^x f(i,j)=\\sum\\limits_{j=0}^yf(x,j+1)=\\sum\\limits_{k=1}^{y+1}f(x,k)$，$O(n)$ 循环即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1000005;const LL MOD = 1e9+7;LL r1, c1, r2, c2, fac[N&lt;&lt;1];LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; idx &gt;&gt;= 1; (bs *= bs) %= MOD; } return res;}inline LL inv(LL x){ return fpow(x, MOD - 2); }inline LL C(LL x, LL y){ return fac[x] * inv(fac[y]) % MOD * inv(fac[x-y]) % MOD; }inline LL getVal(LL r, LL c){ LL res = 0; for(int i = 1; i &lt;= c + 1; i++) (res += C(r + i, i)) %= MOD; return res % MOD;}int main(){ fac[0] = 1; for(int i = 1; i &lt;= 2e6+100; i++) fac[i] = (fac[i-1] * (LL)i) % MOD; read(r1, c1, r2, c2); LL ans = getVal(r2, c2) - getVal(r1-1, c2) - getVal(r2, c1-1) + getVal(r1-1, c1-1); ((ans %= MOD) += MOD) %= MOD; printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/02/15/AtCoder-ABC154F-Many-Many-Paths/"},{"title":"CCPC-2020 秦皇岛站记录","text":"总第109，铜牌第37……CCPC首铜，XCPC第二块铜牌…… 第一场CCPC没能旅游成，呜呜呜～～～ A. A Greeting from Qinhuangdao签到。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int a, int b){ return b == 0 ? a : gcd(b, a % b); }int main(){ int T, CASES = 0; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ int r, b; scanf(&quot;%d%d&quot;, &amp;r, &amp;b); int up = r * (r - 1) / 2; int dn = (r + b) * (r + b - 1) / 2; int g = gcd(up, dn); up /= g, dn /= g; printf(&quot;Case #%d: %d/%d\\n&quot;, ++CASES, up, dn); } return 0;} C. Cameraman这是一道假题……然而我比赛时没想到那一层，顺理成章地认为 Bob 就在 Alex 的位置，于是沿着出题人的思路做了（还写了一堆 bug……最后时刻调出来的） E. Exam Results把所有分数从小到大排序，枚举最大分，问题可以转化成求区间内不重复的数的数量，拿一个 cnt 数组计数即可。然而，最开始我们忽略了一点，就是枚举的这个最大分之前，每一个数都至少得出现一次，否则是不能计入答案的！因为这个送了 2 发罚时，唉。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 400005;int n, p;struct Node{ int id, val; bool operator &lt; (const Node &amp;A) const{ return val &lt; A.val; }}a[N];int sum = 0, presum = 0;int cnt[N], precnt[N];int main(){ int T, CASES = 0; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;p); sum = presum = 0; for(int i = 1; i &lt;= n; i++) cnt[i] = precnt[i] = 0; for(int i = 1; i &lt;= n; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); a[i*2-1] = (Node){i, u}; a[i*2] = (Node){i, v}; } sort(a+1, a+n*2+1); int ans = 0; for(int i = 1, j = 1; i &lt;= n * 2; i++){ if(cnt[a[i].id] == 0) sum++; cnt[a[i].id]++; if(precnt[a[i].id] == 0) presum++; precnt[a[i].id]++; while(a[j].val * 100ll &lt; a[i].val * 1ll * p){ cnt[a[j].id]--; if(cnt[a[j].id] == 0) sum--; j++; } if(presum == n) ans = max(ans, sum); } printf(&quot;Case #%d: %d\\n&quot;, ++CASES, ans); } return 0;} F. Friendly Group容易发现，对于一个连通分量，要么不选它（贡献为 $0$），要么把里面的点全选上（贡献为边数减点数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef vector&lt;int&gt; vi;#define pb(x) emplace_back(x)const int N = 300005;int n, m, deg[N];vi edge[N];bool vis[N];int degSum, verSum;void dfs(int x){ degSum += deg[x], verSum++; vis[x] = true; for(auto &amp;to : edge[x]) if(!vis[to]) dfs(to);}int main(){ int T, CASES = 0; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int ans = 0; for(int i = 1; i &lt;= n; i++){ edge[i].clear(); vis[i] = false; deg[i] = 0; } for(int i = 1; i &lt;= m; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); edge[u].pb(v), edge[v].pb(u); deg[u]++, deg[v]++; } for(int i = 1; i &lt;= n; i++){ if(vis[i]) continue; degSum = verSum = 0; dfs(i); ans += max(0, degSum / 2 - verSum); } printf(&quot;Case #%d: %d\\n&quot;, ++CASES, ans); } return 0;} G. Good Number喜闻乐见的推式子时间：$$\\sum_{i=1}^n\\left[\\left\\lfloor \\sqrt[k]{i}\\right\\rfloor\\mid i\\right]=\\sum_{d=1}^\\sqrt[k]{n} \\sum_{i=d^k}^{\\min(n,(d+1)^k-1)}[d\\mid i]=\\sum_{d=1}^{\\sqrt[k]{n}}\\left\\lfloor\\frac{\\min(n,(d+1)^k-1)}{d}\\right\\rfloor-\\left\\lfloor\\frac{d^k-1}{d}\\right\\rfloor$$所以特判掉 $k=1$ 后，枚举 $d$ 即可。 然而因为大指数的快速幂 WA 了很久，后来急中生智才想到取对数判断…… 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n, k;inline LL fpow(LL bs, LL idx){ LL res = 1; while(idx){ if(idx &amp; 1) res *= bs; bs *= bs; idx &gt;&gt;= 1; } return res;}int main(){ int T, CASES = 0; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); printf(&quot;Case #%d: &quot;, ++CASES); if(k == 1){ printf(&quot;%lld\\n&quot;, n); continue; } int ans = 0; for(int d = 1; k * log(d) &lt;= log(n); d++){ LL t = fpow(d + 1, k) - 1; if(k * log(d+1) &gt; log(n+1)) t = n; ans += t / d - (fpow(d, k) - 1) / d; } printf(&quot;%d\\n&quot;, ans); } return 0;} K. Kingdom’s Power一个比赛时没发现的贪心性质：如果一个军队遍历了整颗树，那它一定是按照子树高度从小到大遍历的，于是对子树排序后，考虑每一个点的军队来源——要么是从根节点直接下来的，要么是从前一颗子树的最深处上来的。所以比较两种方案的代价，选小者即可。 隔壁大一队伍用了一个树形 $\\text{dp}$ 过的这道题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define pb(x) emplace_back(x)#define mp(x, y) make_pair(x, y)const int N = 1000005;int n, ans;vector&lt;int&gt; edge[N];int dep[N], h[N];bool ex[N];void dfs(int x, int f, int depth){ dep[x] = depth; for(auto &amp;to : edge[x]){ if(to == f) continue; dfs(to, x, depth + 1); h[x] = max(h[x], h[to] + 1); }}void dfs(int x, int f){ int pre = -1; for(auto &amp;to : edge[x]){ if(to == f) continue; if(pre == -1 || h[pre] + 2 &gt; dep[to]){ // get an army from root if(ex[x]) ans++, ex[x] = false; else ans += dep[to]; } else // get an army from previous subtree ans += h[pre] + 2; ex[to] = true; pre = to; dfs(to, x); }}int main(){ int T, CASES = 0; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d&quot;, &amp;n); ans = 0; for(int i = 1; i &lt;= n; i++){ dep[i] = h[i] = 0; ex[i] = false; edge[i].clear(); } for(int i = 2; i &lt;= n; i++){ int f; scanf(&quot;%d&quot;, &amp;f); edge[f].pb(i), edge[i].pb(f); } dfs(1, 0, 0); for(int i = 1; i &lt;= n; i++) sort(edge[i].begin(), edge[i].end(), [&amp;](int a, int b){ return h[a] &lt; h[b]; }); dfs(1, 0); printf(&quot;Case #%d: %d\\n&quot;, ++CASES, ans); } return 0;}","link":"/blog-xcpc/2020/11/02/CCPC-2020-%E7%A7%A6%E7%9A%87%E5%B2%9B%E7%AB%99%E8%AE%B0%E5%BD%95/"},{"title":"CCPC-2020 威海站记录","text":"第一块银牌留念！ 继秦皇岛站打铜过后，终于有所进步了。接下来的日子里继续冲！ A. Golden Spirit毫无疑问先把 $2n$ 个老人全运到对面去，假设人刚开始在 $A$ 岸，那么 $2nt$ 的时间后现在人仍在 $A$ 岸。现在，如果第一个到达 $A$ 岸的人（已经休息了 $2nt-t$ 时间）已经休息好了（$2nt-t\\geqslant x$），那么再花 $2nt$ 的时间吧所有人运回对面即可；否则有两种选择，要么在 $A$ 岸等待第一个到达 $A$ 岸的人休息好，要么走到 $B$ 岸等第一个到 $B$ 岸的人休息好，二者取 $\\min$ 即可。 （刚开始想成了 $2nt$ 时间后人在 $B$ 岸，贡献了全场我队唯一一发罚时。。。） 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;ULL n, x, t;int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%llu%llu%llu&quot;, &amp;n, &amp;x, &amp;t); if(x+2*t &lt;= 2*n*t) printf(&quot;%llu\\n&quot;, 4*n*t); else{ ULL ans = x+2*t+2*n*t; if(x &gt;= 2ll*n*t) ans = min(ans, x+2*n*t+t); else ans = min(ans, t+4*n*t); printf(&quot;%llu\\n&quot;, ans); } } return 0;} C. Recontre只需注意到一个极其重要的性质：树上三个点到某点的最短距离之和等于三个点两两距离之和的一半。 于是问题变成了在树上取两个点，求期望长度。这个及其套路地考虑边的贡献可以轻松解决。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n;int sz[N][4];vector&lt; pair&lt;int, LL&gt; &gt; edge[N];void dfs(int x, int f){ for(auto &amp;to : edge[x]){ if(to.first == f) continue; dfs(to.first, x); sz[x][1] += sz[to.first][1]; sz[x][2] += sz[to.first][2]; sz[x][3] += sz[to.first][3]; }}double ans;int k[4];void calc(int x, int f, int a, int b){ for(auto &amp;to : edge[x]){ if(to.first == f) continue; ans += 1.0 * to.second * sz[to.first][a]*(sz[1][b]-sz[to.first][b]) / k[a] / k[b]; calc(to.first, x, a, b); }}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++){ int u, v; LL w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); edge[u].pb(mp(v, w)); edge[v].pb(mp(u, w)); } for(int j = 1; j &lt;= 3; j++){ scanf(&quot;%d&quot;, &amp;k[j]); for(int i = 1; i &lt;= k[j]; i++){ int u; scanf(&quot;%d&quot;, &amp;u); sz[u][j]++; } } dfs(1, 0); calc(1, 0, 1, 2); calc(1, 0, 2, 1); calc(1, 0, 1, 3); calc(1, 0, 3, 1); calc(1, 0, 2, 3); calc(1, 0, 3, 2); ans = ans / 2.0; printf(&quot;%.12f\\n&quot;, ans); return 0;} D. ABC Conjecture重现一下考试时的思考过程：设 $d=\\gcd(a,c),a=dk_1,c=dk_2,k_1&lt;k_2$，则 $b=d(k_2-k_1)$，$$\\begin{align}\\text{rad}(abc)&amp;=\\prod_{p\\mid abc}p\\&amp;=\\prod_{p\\mid d^3k_1k_2(k_2-k_1)}p\\&amp;=\\prod_{p\\mid dk_1k_2(k_2-k_1)}p\\&amp;=\\prod_{p\\mid ck_1(k_2-k_1)}p\\&amp;\\leqslant \\text{rad}(c)\\cdot k_1(k_2-k_1)\\end{align}$$故要使 $\\text{rad}(abc)&lt;c$，只需找到 $k_1\\perp k_2$ 使得 $k_1(k_2-k_1)&lt;\\frac{c}{\\text{rad}(c)}$，如果 $\\frac{c}{\\text{rad}(c)}\\neq 1$，那就取 $k_2=\\frac{c}{\\text{rad}(c)},k_1=1$ 即可；否则无解。 所以问题变成了判断 $c$ 是否有平方因子。比赛的时候直接莽上 Pollard-Rho 了，但事实上没有必要。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL gcd(LL a, LL b){ return b == 0 ? a : gcd(b, a % b); }mt19937 rnd(time(NULL));namespace Miller_Rabin{ inline LL fpow(LL bs, LL idx, LL mod){ bs %= mod; LL res = 1; while(idx){ if(idx &amp; 1) res = (__int128)res * bs % mod; bs = (__int128)bs * bs % mod; idx &gt;&gt;= 1; } return res; } bool test(LL n){ if(n &lt; 3) return n == 2; if(!(n &amp; 1)) return false; LL u = n - 1, t = 0; while(u % 2 == 0) u /= 2, t++; int testTime = 10; while(testTime--){ LL v = rnd() % (n - 2) + 2; v = fpow(v, u, n); if(v == 1 || v == n - 1) continue; int j; for(j = 0; j &lt; t; j++, v = (__int128)v * v % n) if(v == n - 1) break; if(j &gt;= t) return false; } return true; }}namespace Pollard_Rho{ vector&lt;LL&gt; factors; inline LL solve(LL n){ LL c = rnd() % (n - 1) + 1; LL x = 0, y = 0, val = 1; for(LL k = 1; ; k &lt;&lt;= 1, y = x, val = 1){ for(int i = 1; i &lt;= k; i++){ x = ((__int128)x * x + c) % n; val = (__int128)val * abs(x - y) % n; if(val == 0) return n; if(i % 127 == 0){ LL g = gcd(val, n); if(g &gt; 1) return g; } } LL g = gcd(val, n); if(g &gt; 1) return g; } } void factorize(LL n){ if(n &lt; 2) return; if(Miller_Rabin::test(n)){ factors.emplace_back(n); return; } LL p = n; while(p == n) p = solve(n); while(n % p == 0) n /= p; factorize(p), factorize(n); }}int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ LL c; scanf(&quot;%lld&quot;, &amp;c); Pollard_Rho::factors.clear(); Pollard_Rho::factorize(c); bool ok = false; for(auto &amp;fac : Pollard_Rho::factors){ if((c / fac) % fac == 0){ ok = true; break; } } puts(ok ? &quot;yes&quot; : &quot;no&quot;); } return 0;} G. Caesar Cipher分块+哈希。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500005#define mod 65536const long long P = 1000000007;const long long Base = 70000;inline int read () { register int s = 0, f = 1; register char ch = getchar (); for ( ; ch &lt; '0' || ch &gt; '9'; f = (ch == '-') ? -1 : f, ch = getchar ()); for ( ; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; s = s * 10 + (ch ^ 48), ch = getchar ()); return s * f;}long long Belong[N], L[N], R[N], C[N], bl, a[N], cnt;long long Hash[N], f[755][65540], power[N], inv;long long qpow (long long a, long long x) { long long ans = 1; while (x) { if (x &amp; 1) ans = (ans * a) % P; a = (a * a) % P; x &gt;&gt;= 1; } return ans;}int n, q;inline void Maintain (int l, int r) { if (r &lt;= R[Belong[l]]) { for (int i = l; i &lt;= r; ++i) { Hash[Belong[i]] = (Hash[Belong[i]] - a[i] * power[R[Belong[i]] - i] % P + P) % P; f[Belong[i]][a[i]] = (f[Belong[i]][a[i]] - power[R[Belong[i]] - i] + P) % P; a[i] = (a[i] + 1) % mod; f[Belong[i]][a[i]] = (f[Belong[i]][a[i]] + power[R[Belong[i]] - i]) % P; Hash[Belong[i]] = (Hash[Belong[i]] + a[i] * power[R[Belong[i]] - i] % P) % P; } return ; } for (int i = l; i &lt;= R[Belong[l]]; ++i) { Hash[Belong[i]] = (Hash[Belong[i]] - a[i] * power[R[Belong[i]] - i] % P + P) % P; f[Belong[i]][a[i]] = (f[Belong[i]][a[i]] - power[R[Belong[i]] - i] + P) % P; a[i] = (a[i] + 1) % mod; f[Belong[i]][a[i]] = (f[Belong[i]][a[i]] + power[R[Belong[i]] - i]) % P; Hash[Belong[i]] = (Hash[Belong[i]] + a[i] * power[R[Belong[i]] - i] % P) % P; } for (int i = L[Belong[r]]; i &lt;= r; ++i) { Hash[Belong[i]] = (Hash[Belong[i]] - a[i] * power[R[Belong[i]] - i] % P + P) % P; f[Belong[i]][a[i]] = (f[Belong[i]][a[i]] - power[R[Belong[i]] - i] + P) % P; a[i] = (a[i] + 1) % mod; f[Belong[i]][a[i]] = (f[Belong[i]][a[i]] + power[R[Belong[i]] - i]) % P; Hash[Belong[i]] = (Hash[Belong[i]] + a[i] * power[R[Belong[i]] - i] % P) % P; } for (int i = Belong[l] + 1; i &lt; Belong[r]; ++i) { C[i] = (C[i] + 1) % mod; Hash[i] = (Hash[i] + ((power[R[i] - L[i] + 1] - 1 + P) % P) * inv % P) % P; Hash[i] = (Hash[i] - mod * f[i][(mod - C[i]) % mod] % P + P) % P; } return ;} inline long long Query (int l, int r) { long long ans = 0; if (r &lt;= R[Belong[l]]) { for (int i = l; i &lt;= r; ++i) { ans = (ans + (a[i] + C[Belong[i]]) % mod * power[r - i] % P) % P; } return ans; } for (int i = l; i &lt;= R[Belong[l]]; ++i) { ans = (ans + (a[i] + C[Belong[i]]) % mod * power[R[Belong[i]] - i] % P) % P; } for (int i = Belong[l] + 1; i &lt; Belong[r]; ++i) { ans = (ans * power[R[i] - L[i] + 1] % P + Hash[i]) % P; } int tmp2 = 0; for (int i = L[Belong[r]]; i &lt;= r; ++i) { tmp2 = (tmp2 + (a[i] + C[Belong[i]]) % mod * power[r - i] % P) % P; } ans = (ans * power[r - L[Belong[r]] + 1] % P + tmp2) % P; return ans;}int main () { n = read (), q = read (); inv = qpow (Base - 1, P - 2); power[0] = 1; bl = sqrt (n + 1); for (int i = 1; i &lt;= n; ++i) { power[i] = power[i - 1] * Base % P; a[i] = read (); Belong[i] = (i - 1) / bl + 1; R[Belong[i]] = i; cnt = Belong[i]; } for (int i = n; i; --i) L[Belong[i]] = i; power[n + 1] = power[n] * Base % P; for (int i = 1; i &lt;= cnt; ++i) { for (int j = L[i]; j &lt;= R[i]; ++j) { Hash[i] = (Hash[i] * Base + a[j]) % P; (f[i][a[j]] += power[R[i] - j]) %= P; } } for (int opt, x, y, l, i = 1; i &lt;= q; ++i) { opt = read (); if (opt == 1) { x = read (), y = read (); Maintain (x, y); } else { x = read (), y = read (), l = read (); long long ans1 = Query (x, x + l - 1); long long ans2 = Query (y, y + l - 1); puts (ans1 == ans2 ? &quot;yes&quot; : &quot;no&quot;); } } return 0;} H. Message Bomb队友做的，没看题。。。 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;const int N = 1e5 + 2;typedef long long ll;ll stu[N &lt;&lt; 1], group[N];set&lt;ll&gt;st[N &lt;&lt; 1];int main(){ ll n, m, s, i, j, k;set&lt;ll&gt;::iterator it; scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;s); while(s--){ scanf(&quot;%lld%lld%lld&quot;, &amp;i, &amp;j, &amp;k); if(i == 1){ st[j].insert(k); stu[j] -= group[k]; }else if(i == 2){ st[j].erase(k); stu[j] += group[k]; }else{ if(st[j].find(k) != st[j].end())stu[j]--; group[k]++; } }for(i = 1;i &lt;= m;i++) for(it = st[i].begin();it != st[i].end();it++) stu[i] += group[*it]; for(i = 1;i &lt;= m;i++)printf(&quot;%lld\\n&quot;, stu[i]); return 0;} L. Clock Master同队友做的，没看题。 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;const int N = 30000;int v[N + 2], p[N + 2];double f[N + 2];int main(){ int T, n, i, j, k, alpha;double s; for(i = 2;i &lt;= N;i++){ if(!v[i])p[++p[0]] = i; for(j = 1;j &lt;= p[0] &amp;&amp; i * p[j] &lt;= N;j++){ v[i * p[j]] = 1; if(!(i % p[j]))break; } } for(i = 1;i &lt;= p[0];i++) for(j = N, s = log(p[i]);j;j--) for(k = 1, alpha = 0;k &lt;= j;k *= p[i], alpha++) f[j] = max(f[j], f[j - k] + alpha * s); scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d&quot;, &amp;n); printf(&quot;%.9lf\\n&quot;, f[n]); } return 0;}","link":"/blog-xcpc/2020/11/02/CCPC-2020-%E5%A8%81%E6%B5%B7%E7%AB%99%E8%AE%B0%E5%BD%95/"},{"title":"CDQ分治学习笔记","text":"参考博客：1 2 3 4 5 基本思想分治(Divide and conquer)思想是计算机科学中举足轻重的一种思想，应用范围极为广泛。 CDQ 分治是普通分治思想的延伸，区别主要在于：普通分治的子问题之间互不影响，而 CDQ 分治中左子区间可以对右子区间有影响。 CDQ 分治应用广泛，在不同地方的体现不尽相同，实现上大体上可分为如下三步： 分(Divide)：将原问题分为左右两个区间的子问题 治(Conquer)：递归解决左右两个子区间 并(Combine)：合并两子区间的答案，并且处理左区间对右区间产生的影响 可以发现，CDQ 分治的关键就在于如何处理左区间对右区间的影响，其余部分与普通分治相同。 CDQ 分治常常能够代替某些高级数据结构，并且常数更小，跑得更快。 练习二维偏序（逆序对）题目链接 逆序对问题本质就是一个二维偏序。CDQ 分治时，为了线性统计，我们希望左右子区间的数值已经排好序了，这样双指针就可以统计。所以归并排序正好用在了这里。 复杂度：$T(n)=2\\cdot T\\left(\\frac{n}{2}\\right)+O(n)=O(n\\lg n)$ &gt;folded123456789101112131415161718192021222324252627282930313233343536#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 500005;int n, a[N];LL ans;int t[N];void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid+1, r); t[0] = 0; int lpt = l, rpt = mid+1; while(lpt &lt;= mid &amp;&amp; rpt &lt;= r){ if(a[lpt] &lt;= a[rpt]) t[++t[0]] = a[lpt++]; else t[++t[0]] = a[rpt++], ans += mid - lpt + 1; } while(lpt &lt;= mid) t[++t[0]] = a[lpt++]; while(rpt &lt;= r) t[++t[0]] = a[rpt++]; for(int i = l; i &lt;= r; i++) a[i] = t[i - l + 1];}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); cdq(1, n); printf(&quot;%lld\\n&quot;, ans); return 0;} hdu1541 Stars题目链接 求横纵坐标都更小的点的个数，二维偏序。 &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 1000005;int n, ans[N];struct Node{ int x, y, id; int cnt;}node[N];bool cmpx(const Node &amp;A, const Node &amp;B){ return A.x == B.x ? A.y &lt; B.y : A.x &lt; B.x;}int t[N];void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++) node[i].y = lower_bound(t+1, t+t[0]+1, node[i].y) - t;}Node tmp[N];void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid+1, r); int posl = l, posr = mid+1, tid = 0; while(posl &lt;= mid &amp;&amp; posr &lt;= r){ if(node[posl].y &lt;= node[posr].y) tmp[++tid] = node[posl++]; else{ node[posr].cnt += posl - l; tmp[++tid] = node[posr++]; } } while(posl &lt;= mid) tmp[++tid] = node[posl++]; while(posr &lt;= r) node[posr].cnt += posl - l, tmp[++tid] = node[posr++]; for(int i = 1; i &lt;= tid; i++) node[i+l-1] = tmp[i];}int main(){ while(scanf(&quot;%d&quot;, &amp;n) != EOF){ t[0] = 0; memset(ans, 0, sizeof ans); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d%d&quot;, &amp;node[i].x, &amp;node[i].y); t[++t[0]] = node[i].y; node[i].id = i; node[i].cnt = 0; } disc(); sort(node+1, node+n+1, cmpx); cdq(1, n); for(int i = 1; i &lt;= n; i++) ans[node[i].cnt]++; for(int i = 0; i &lt; n; i++) printf(&quot;%d\\n&quot;, ans[i]); } return 0;} [SHOI2007]园丁的烦恼题目链接 用二维前缀和转化一下，然后就是求横纵坐标都更小的点的个数，即二维偏序问题。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int N = 500005;int n, m, tot, a[N], b[N], c[N], d[N], ans[N], maxx;struct Node{ int x, y, k, id;}node[N*5];bool cmp1(const Node &amp;A, const Node &amp;B){ return A.x == B.x ? (A.y == B.y ? A.k == 0 : A.y &lt; B.y) : A.x &lt; B.x;}int t[N*5];void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= tot; i++){ node[i].y = lower_bound(t+1, t+t[0]+1, node[i].y) - t; maxx = max(maxx, node[i].y); }}Node tmp[N*5];void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid+1, r); int posl = l, posr = mid+1, tid = 0, res = 0; while(posl &lt;= mid &amp;&amp; posr &lt;= r){ if(node[posl].y &lt;= node[posr].y){ res += (node[posl].k == 0); tmp[++tid] = node[posl++]; } else{ ans[node[posr].id] += node[posr].k * res; tmp[++tid] = node[posr++]; } } while(posl &lt;= mid) tmp[++tid] = node[posl++]; while(posr &lt;= r) ans[node[posr].id] += node[posr].k * res, tmp[++tid] = node[posr++]; for(int i = 1; i &lt;= tid; i++) node[i+l-1] = tmp[i];}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d%d&quot;, &amp;node[i].x, &amp;node[i].y); tot++; t[++t[0]] = node[i].y; } for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;c[i], &amp;d[i]); t[++t[0]] = b[i]-1, t[++t[0]] = d[i]; node[++tot] = (Node){a[i]-1, b[i]-1, 1, i}; node[++tot] = (Node){a[i]-1, d[i], -1, i}; node[++tot] = (Node){c[i], b[i]-1, -1, i}; node[++tot] = (Node){c[i], d[i], 1, i}; } disc(); sort(node+1, node+tot+1, cmp1); cdq(1, tot); for(int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} luoguP2345 奶牛集会题目链接 先把所有奶牛按照 $v$ 排序，然后 CDQ 分治。在考虑左右子区间时，左子区间的任一 $v$ 都小于右子区间的任一 $v$，于是我们只需要依次考虑右子区间的每一个元素，计算左子区间中 $x$ 比它小的坐标之和以及 $x$ 比它大的坐标之和是多少。欲在这一步做到线性，我们希望左右区间分别是按照 $x$ 排好序了的，这样就可以用双指针的方法搞出答案。正好把归并排序套上去即可。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 20005;int n;LL ans;struct Node{ LL v, x;}node[N];bool cmp1(const Node &amp;A, const Node &amp;B){ return A.v == B.v ? A.x &lt; B.x : A.v &lt; B.v; }Node tmp[N];void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid+1, r); LL sumb = 0, sums = 0; int pt = l; for(int i = l; i &lt;= mid; i++) sumb += node[i].x; for(int i = mid + 1; i &lt;= r; i++){ while(node[i].x &gt; node[pt].x &amp;&amp; pt &lt;= mid){ sumb -= node[pt].x; sums += node[pt].x; pt++; } ans += node[i].v * (sumb - node[i].x * (mid + 1 - pt) + node[i].x * (pt - l) - sums); } int ptl = l, ptr = mid + 1, tid = 0; while(ptl &lt;= mid &amp;&amp; ptr &lt;= r){ if(node[ptl].x &lt; node[ptr].x) tmp[++tid] = node[ptl++]; else tmp[++tid] = node[ptr++]; } while(ptl &lt;= mid) tmp[++tid] = node[ptl++]; while(ptr &lt;= r) tmp[++tid] = node[ptr++]; for(int i = 1; i &lt;= tid; i++) node[i+l-1] = tmp[i];}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld%lld&quot;, &amp;node[i].v, &amp;node[i].x); sort(node+1, node+n+1, cmp1); cdq(1, n); printf(&quot;%lld\\n&quot;, ans); return 0;} 三维偏序（陌上花开）题目链接 先按第一维排序，然后 CDQ 分治：solve(l, r) 时，递归进行 solve(l, mid) 和 solve(mid+1, r)，考虑如何统计 $l\\leq i\\leq mid,mid+1\\leq j\\leq r$ 的满足 $b_i&lt;b_j$ 且 $c_i&lt;c_j$ 的点对数。把所有 $[l,r]$ 区间的元素拿出来按第二维排序，遍历一遍，遇到左区间的就按第三维丢到值域树状数组里去，遇到右区间的就查询。 如果题目存在重复元素，需要去重（因为 CDQ 分治只能统计左区间对右区间的答案），丢值域树状数组的时候丢重复次数。 复杂度：$T(n)=2\\cdot T\\left(\\frac{n}{2}\\right)+O(n\\lg n)=O(n\\lg^2n)$ >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int N = 100005;const int K = 200005;int n, k, tot, ans[N], ranking[N]; // ranking[i] is the number less than ith elementstruct Node{ int a, b, c, dc; // dc is c after discretization int newid, cnt, num; // num is the number of elements which are less than this node}node[N];bool cmpa(const Node &amp;A, const Node &amp;B){ return A.a == B.a ? (A.b == B.b ? A.c &lt; B.c : A.b &lt; B.b) : A.a &lt; B.a;}bool cmpb(const Node &amp;A, const Node &amp;B){ return A.b == B.b ? (A.c == B.c ? A.a &lt; B.a : A.c &lt; B.c) : A.b &lt; B.b;}int tc[N];void disc(){ sort(tc+1, tc+tc[0]+1); tc[0] = unique(tc+1, tc+tc[0]+1) - (tc+1); for(int i = 1; i &lt;= n; i++) node[i].dc = lower_bound(tc+1, tc+tc[0]+1, node[i].c) - tc;}int c[N];inline int lowbit(int x){ return x &amp; -x; }void add(int x, int val){ while(x &lt;= n){ c[x] += val; x += lowbit(x); } }int sum(int x){ int res = 0; while(x){ res += c[x]; x -= lowbit(x); } return res;}void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid+1, r); sort(node+l, node+r+1, cmpb); for(int i = l; i &lt;= r; i++){ if(node[i].newid &lt;= mid) add(node[i].dc, node[i].cnt); else node[i].num += sum(node[i].dc); } for(int i = l; i &lt;= r; i++) // clear BIT if(node[i].newid &lt;= mid) add(node[i].dc, -node[i].cnt);}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d%d%d&quot;, &amp;node[i].a, &amp;node[i].b, &amp;node[i].c); tc[++tc[0]] = node[i].c; } disc(); sort(node+1, node+n+1, cmpa); for(int i = 1; i &lt;= n; i++){ // unique if(node[i-1].a != node[i].a || node[i-1].b != node[i].b || node[i-1].c != node[i].c) node[++tot] = node[i], node[tot].newid = tot, node[tot].cnt = 1; else node[tot].cnt++; } cdq(1, tot); for(int i = 1; i &lt;= tot; i++) ans[node[i].num + node[i].cnt - 1] += node[i].cnt; for(int i = 0; i &lt; n; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} 动态逆序对题目链接 删去一个值后，总逆序对数等于原逆序对数减去它参与构成的逆序对数。它参与构成的逆序对分两种情况： 位置在其前，值更大，删去时间更大 位置在其后，值更小，删去时间更大 这分别是两种三维偏序，CDQ 分治即可。 &gt;folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 200005;typedef long long LL;int n, m, pos[N];struct Query{ int tim, pos, val; int newid, num;}node[N];bool cmp1(const Query &amp;A, const Query &amp;B){ return A.tim &gt; B.tim; }bool cmp2(const Query &amp;A, const Query &amp;B){ return A.pos &gt; B.pos; }int c[N];inline int lowbit(int x){ return x &amp; -x; }void add(int x, int val){ while(x &lt;= n+1){ c[x] += val; x += lowbit(x); } }int sum(int x){ int res = 0; while(x){ res += c[x]; x -= lowbit(x); } return res;}void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid+1, r); sort(node+l, node+r+1, cmp2); for(int i = l; i &lt;= r; i++){ if(node[i].newid &lt;= mid) add(node[i].val, 1); else node[i].num += sum(node[i].val); } for(int i = l; i &lt;= r; i++) if(node[i].newid &lt;= mid) add(node[i].val, -1); for(int i = r; i &gt;= l; i--){ if(node[i].newid &lt;= mid) add(n + 1 - node[i].val, 1); else node[i].num += sum(n + 1 - node[i].val); } for(int i = r; i &gt;= l; i--) if(node[i].newid &lt;= mid) add(n + 1 - node[i].val, -1);}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d&quot;, &amp;node[i].val); pos[node[i].val] = i; node[i].pos = i; } for(int i = 1; i &lt;= m; i++){ int x; scanf(&quot;%d&quot;, &amp;x); node[pos[x]].tim = i; } for(int i = 1; i &lt;= n; i++) if(!node[i].tim) node[i].tim = m + 1; LL res = 0; for(int i = n; i &gt;= 1; i--) res += sum(node[i].val - 1), add(node[i].val, 1); for(int i = n; i &gt;= 1; i--) add(node[i].val, -1); sort(node+1, node+n+1, cmp1); for(int i = 1; i &lt;= n; i++) node[i].newid = i; cdq(1, n); sort(node+1, node+n+1, cmp1); for(int i = n; i &gt;= n - m + 1; i--){ printf(&quot;%lld\\n&quot;, res); res -= node[i].num; } return 0;} [BOI2007]Mokia题目链接 求横纵坐标以及时间都更小的点的数目，三维偏序。 以下代码中的排序采用了另一种方式（分别排序），两种都可以，看心情用咯～ >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 800005;int n, tot, opt[N];struct Node{ int x, y, t, k; LL val;}node[N];bool cmpt(const Node &amp;A, const Node &amp;B){ return A.t == B.t ? (A.x == B.x ? A.y &lt; B.y : A.x &lt; B.x) : A.t &lt; B.t;}bool cmpx(const Node &amp;A, const Node &amp;B){ return A.x == B.x ? (A.y == B.y ? A.t &lt; B.t : A.y &lt; B.y) : A.x &lt; B.x;}int t[N];inline void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= tot; i++) node[i].y = lower_bound(t+1, t+t[0]+1, node[i].y) - t;}LL c[N];inline int lowbit(int x){ return x &amp; -x; }inline void add(int x, LL val){ while(x &lt;= tot){ c[x] += val; x += lowbit(x); } }inline LL sum(int x){ LL res = 0; while(x){ res += c[x]; x -= lowbit(x); } return res; }LL ans[N];void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid), cdq(mid+1, r); sort(node+l, node+mid+1, cmpx); sort(node+mid+1, node+r+1, cmpx); int ptl = l, ptr; for(ptr = mid+1; ptr &lt;= r; ptr++){ while(ptl &lt;= mid &amp;&amp; node[ptl].x &lt;= node[ptr].x){ if(node[ptl].k == 0) add(node[ptl].y, node[ptl].val); ptl++; } ans[node[ptr].t] += node[ptr].k * sum(node[ptr].y); } for(int i = l; i &lt; ptl; i++) if(node[i].k == 0) add(node[i].y, -node[i].val);}int main(){ scanf(&quot;0 %d&quot;, &amp;n); for(int i = 1; ; i++){ scanf(&quot;%d&quot;, &amp;opt[++opt[0]]); if(opt[i] == 3) break; else if(opt[i] == 1){ int x, y; LL A; scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;A); ++tot, node[tot] = (Node){x, y, i, 0, A}; t[++t[0]] = y; } else if(opt[i] == 2){ int _x1, _y1, _x2, _y2; scanf(&quot;%d%d%d%d&quot;, &amp;_x1, &amp;_y1, &amp;_x2, &amp;_y2); tot++, node[tot] = (Node){_x2, _y2, i, 1, 0}; tot++, node[tot] = (Node){_x1-1, _y2, i, -1, 0}; tot++, node[tot] = (Node){_x2, _y1-1, i, -1, 0}; tot++, node[tot] = (Node){_x1-1, _y1-1, i, 1, 0}; t[++t[0]] = _y2, t[++t[0]] = _y1-1; } } disc(); sort(node+1, node+tot+1, cmpt); cdq(1, tot); for(int i = 1; i &lt;= opt[0]; i++) if(opt[i] == 2) printf(&quot;%lld\\n&quot;, ans[i]); return 0;} luoguP4169 [Violet]天使玩偶/SJY摆棋子题目链接 正解是 K-D Tree，但是也可以用 CDQ 分治做。考虑如何把最近距离问题转换成三维偏序问题——每个点的左下、左上、右下、右上部分分别求最近距离，这样就是四次三维偏序问题。为方便写代码，左上、右下、右上可以通过翻转转化成左下。 这道题时限很紧，在 CDQ 分治中不采用 sort 来排序第二维，而是套用一个归并排序，可以减少不少常数，然后提交的时候吸吸氧就可以过了。 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-') fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 1000005;const int INF = 2e9;int n, m, tot, ans[N], maxx, maxdy, maxy, _[N];struct Node{ int t, x, y, k, id, dy;}node[N], nod[N];bool cmpt(const Node &amp;A, const Node &amp;B){ return A.t == B.t ? (A.x == B.x ? A.y &lt; B.y : A.x &lt; B.x) : A.t &lt; B.t; }int t[N];void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= tot; i++){ node[i].dy = lower_bound(t+1, t+t[0]+1, node[i].y) - t; maxdy = max(maxdy, node[i].dy); maxy = max(maxy, node[i].y); maxx = max(maxx, node[i].x); }}int c[N];inline int lowbit(int x){ return x &amp; -x; }inline void modify(int x, int val){ while(x &lt;= n + m + 1){ c[x] = max(c[x], val); x += lowbit(x); } }inline int queryMax(int x){ int res = -1e9; while(x){ res = max(res, c[x]); x -= lowbit(x); } return res; }inline void clear(int x){ while(x &lt;= n + m + 1){ c[x] = 0; x += lowbit(x); } }Node tmp[N];void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid), cdq(mid+1, r); int ptl = l, tid = 0; for(int ptr = mid+1; ptr &lt;= r; ptr++){ while(ptl &lt;= mid &amp;&amp; node[ptl].x &lt;= node[ptr].x){ if(node[ptl].k) modify(node[ptl].dy, node[ptl].x + node[ptl].y); tmp[++tid] = node[ptl++]; } if(node[ptr].id){ int res = queryMax(node[ptr].dy); if(res) ans[node[ptr].id] = min(ans[node[ptr].id], node[ptr].x + node[ptr].y - queryMax(node[ptr].dy)); } tmp[++tid] = node[ptr]; } for(int i = l; i &lt; ptl; i++) clear(node[i].dy); while(ptl &lt;= mid) tmp[++tid] = node[ptl++]; for(int i = 1; i &lt;= tid; i++) node[i+l-1] = tmp[i];}int main(){ read(n, m); for(int i = 1; i &lt;= n; i++){ read(node[i].x, node[i].y); node[i].t = 0, node[i].k = 1; tot++; t[++t[0]] = node[i].y; } for(int i = 1; i &lt;= m; i++){ tot++; read(_[i], node[tot].x, node[tot].y); node[tot].t = i, node[tot].k = (_[i] == 1), node[tot].id = (_[i] == 2) * i; t[++t[0]] = node[tot].y; ans[i] = INF; } disc(); sort(node+1, node+tot, cmpt); for(int i = 1; i &lt;= tot; i++) nod[i] = node[i]; cdq(1, tot); for(int i = 1; i &lt;= tot; i++) node[i] = nod[i], node[i].y = maxy - nod[i].y + 1, node[i].dy = maxdy - nod[i].dy + 1; cdq(1, tot); for(int i = 1; i &lt;= tot; i++) node[i] = nod[i], node[i].x = maxx - nod[i].x + 1; cdq(1, tot); for(int i = 1; i &lt;= tot; i++) node[i] = nod[i], node[i].x = maxx - nod[i].x + 1, node[i].y = maxy - nod[i].y + 1, node[i].dy = maxdy - nod[i].dy + 1; cdq(1, tot); for(int i = 1; i &lt;= m; i++) if(_[i] == 2) printf(&quot;%d\\n&quot;, ans[i]); return 0;} 四维偏序（hdu5126 stars）题目链接 CDQ 套 CDQ分治。先按第一维 $a$ 排序，然后对第一维 CDQ 分治：递归回来后根据第一维的位置打上左右标记，然后按 $b$ 排序，得到一系列形如 $(L/R,b,c,d)$ 的元素且 $b$ 递增；复制一下，对第二维 CDQ 分治并在同时对第三维排序：递归回来后左子区间都是 $(L/R,L,c,d)$，右子区间都是 $(L/R,R,c,d)$，且各自区间内的 $c$ 是递增的，然后双指针把第四维丢值域树状数组里或者查询，丢的时候记得参考第一维的 $L/R$ 情况。 实现时用与 CDQ 浑然一体的归并排序而非 sort 来减少一些常数；同时清空树状数组时尽可能少清。 复杂度：$T(n)=2\\cdot T\\left(\\frac{n}{2}\\right)+O(n\\lg^2n)=O(n\\lg^3n)$ >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 50005;int T, q, a[N], tot, ans[N];#define LEFT 0#define RIGHT 1struct Node{ int t, x, y, z, k; bool mark;}node[N&lt;&lt;3];bool cmpt(const Node &amp;A, const Node &amp;B){ if(A.t == B.t) if(A.x == B.x) if(A.y == B.y) return A.z &lt; B.z; else return A.y &lt; B.y; else return A.x &lt; B.x; else return A.t &lt; B.t;}int t[N&lt;&lt;3];void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= tot; i++) node[i].z = lower_bound(t+1, t+t[0]+1, node[i].z) - t;}int c[N&lt;&lt;3];inline int lowbit(int x){ return x &amp; -x; }inline void add(int x, int val){ while(x &lt;= q * 8){ c[x] += val; x += lowbit(x); } }inline int sum(int x){ int res = 0; while(x){ res += c[x]; x -= lowbit(x); } return res; }Node tmp[N&lt;&lt;3], tmp2[N&lt;&lt;3];void cdq2(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq2(l, mid), cdq2(mid+1, r); int ptl = l, ptr = mid+1, tid = l-1, lastl; while(ptl &lt;= mid &amp;&amp; ptr &lt;= r){ if(tmp[ptl].y &lt;= tmp[ptr].y){ if(tmp[ptl].k == 0 &amp;&amp; tmp[ptl].mark == LEFT) add(tmp[ptl].z, 1); tmp2[++tid] = tmp[ptl++]; } else{ if(tmp[ptr].k != 0 &amp;&amp; tmp[ptr].mark == RIGHT) ans[tmp[ptr].t] += tmp[ptr].k * sum(tmp[ptr].z); tmp2[++tid] = tmp[ptr++]; } } lastl = ptl - 1; while(ptl &lt;= mid) tmp2[++tid] = tmp[ptl++]; while(ptr &lt;= r){ if(tmp[ptr].k != 0 &amp;&amp; tmp[ptr].mark == RIGHT) ans[tmp[ptr].t] += tmp[ptr].k * sum(tmp[ptr].z); tmp2[++tid] = tmp[ptr++]; } for(int i = l; i &lt;= lastl; i++) // crucial for decreasing constant if(tmp[i].k == 0 &amp;&amp; tmp[i].mark == LEFT) add(tmp[i].z, -1); for(int i = l; i &lt;= r; i++) tmp[i] = tmp2[i];}void cdq1(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq1(l, mid), cdq1(mid+1, r); int ptl = l, ptr = mid+1, tid = l-1; // tid must be l-1 or it can't be used in cdq2 while(ptl &lt;= mid &amp;&amp; ptr &lt;= r){ if(node[ptl].x &lt;= node[ptr].x){ node[ptl].mark = LEFT; tmp[++tid] = node[ptl++]; } else{ node[ptr].mark = RIGHT; tmp[++tid] = node[ptr++]; } } while(ptl &lt;= mid) node[ptl].mark = LEFT, tmp[++tid] = node[ptl++]; while(ptr &lt;= r) node[ptr].mark = RIGHT, tmp[++tid] = node[ptr++]; for(int i = l; i &lt;= r; i++) node[i] = tmp[i]; cdq2(l, r);}inline void init(){ tot = t[0] = 0; for(int i = 1; i &lt;= q; i++) ans[i] = 0;}int main(){ read(T); while(T--){ read(q); init(); int _x1, _y1, _z1, _x2, _y2, _z2; for(int i = 1; i &lt;= q; i++){ read(a[i], _x1, _y1, _z1); if(a[i] == 1){ node[++tot] = (Node){i, _x1, _y1, _z1, 0}; t[++t[0]] = _z1; } else{ read(_x2, _y2, _z2); node[++tot] = (Node){i, _x2, _y2, _z2, 1}; node[++tot] = (Node){i, _x1-1, _y2, _z2, -1}; node[++tot] = (Node){i, _x2, _y1-1, _z2, -1}; node[++tot] = (Node){i, _x2, _y2, _z1-1, -1}; node[++tot] = (Node){i, _x1-1, _y1-1, _z2, 1}; node[++tot] = (Node){i, _x1-1, _y2, _z1-1, 1}; node[++tot] = (Node){i, _x2, _y1-1, _z1-1, 1}; node[++tot] = (Node){i, _x1-1, _y1-1, _z1-1, -1}; t[++t[0]] = _z2, t[++t[0]] = _z1-1; } } disc(); sort(node+1, node+tot+1, cmpt); cdq1(1, tot); for(int i = 1; i &lt;= q; i++) if(a[i] == 2) printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/blog-xcpc/2020/02/19/CDQ%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"[CF1061F] Lost Root","text":"题目链接 Solution唔……随机化…… 随机两个点 $u,v$，然后枚举所有点询问是否在 $u,v$ 路径上，记录在路径上的点的个数，如果个数等于 $2h-1$，那么 $u,v$ 就是两个叶节点且根在其路径中间，一直循环随机直到找到这样的点（每次循环找到的概率是 $\\frac{1}{8}$）。 开一个链表，依次把 $u,v$ 路径上的点拿出来与链表中的点询问，判断它在链表中的位置，插入链表；该过程结束后根节点就是链表中间的那个节点。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int n, k;map&lt;tuple&lt;int, int, int&gt;, bool&gt; store;map&lt;pair&lt;int, int&gt;, bool&gt; asked;inline bool ask(int x, int y, int z){ if(store[make_tuple(x, y, z)]) return store[make_tuple(x, y, z)]; printf(&quot;? %d %d %d\\n&quot;, x, y, z); fflush(stdout); char s[10]; scanf(&quot;%s&quot;, s); store[make_tuple(x, y, z)] = s[0] == 'Y'; return s[0] == 'Y';}int main(){ srand(19950523); read(n, k); int h, tot; for(h = 0, tot = 1; tot &lt; n * (k - 1) + 1; h++, tot *= k); while(1){ int u = rand() % n + 1, v = rand() % n + 1; while(v == u) v = rand() % n + 1; if(asked[make_pair(u, v)] || asked[make_pair(v, u)]) continue; asked[make_pair(u, v)] = asked[make_pair(v, u)] = true; vector&lt;int&gt; vec; int cnt = 2; for(int i = 1; i &lt;= n; i++){ if(i == u || i == v) continue; if(ask(u, i, v)){ cnt++; vec.emplace_back(i); } } if(cnt != 2 * h - 1) continue; list&lt;int&gt; node; node.emplace_front(v); random_shuffle(vec.begin(), vec.end()); for(auto k: vec){ for(list&lt;int&gt;::iterator it = node.begin(); it != node.end(); it++){ if(ask(u, k, (*it))){ node.emplace(it, k); break; } } } cnt = 0; list&lt;int&gt;::iterator it; for(it = node.begin(); it != node.end(); it++){ cnt++; if(cnt == h - 1) break; } printf(&quot;! %d\\n&quot;, (*it)); fflush(stdout); return 0; }}","link":"/blog-xcpc/2020/04/17/CF1061F-Lost-Root/"},{"title":"[CF1292C] Xenon&#39;s Attack on the Gangs","text":"题目链接 Solution【参考：官方题解，博客1，博客2】 这种询问 $\\sum\\limits_{1\\leq u&lt;v\\leq n}(…)$ 的题目一般都是考虑边的贡献吧…… 考虑边权为 $0$ 的边：不经过它的路径的 $mex$ 一定为 $0$，而经过它的路径的 $mex$ 至少为 $1$. 也就是说，这条边把树分成了两部分 $A,B$，它的贡献至少是 $size_A\\times size_B$，我们答案里先加上 $size_A\\times size_B$. 如下图1所示。 然后考虑边权为 $1$ 的边，显然应该把它放在 $0$ 的旁边（否则，$0,1$ 之间的点对没有贡献，$0,1$ 外侧有贡献的点对还少了），那么 $0,1$ “外侧”形成两部分 $A,C$（如下图2所示），答案加上 $size_A\\times size_C$. 以此类推，$0,1,2,\\cdots$ 一定是连续地在一条路径上（如下图3所示），答案不断加上这条路径的“外侧”两部分的大小乘积。 也就是说，对于某一条从 $u$ 到 $v$ 长度为 $l$ 的路径，其最大值是唯一的——只需要以某种从中心往两侧扩散的方式在路径上依次放上 $0\\sim l-1$，其余边随意即可。 设 $dp[u][v]$ 是在点 $u,v$ 之间放上 $0\\sim l-1$ 的最大值， $fa[i][j]$ 是 $i$ 为根时 $j$ 的父亲，$sz[i][j]$ 是 $i$ 为根时 $j$ 的子树大小，考虑转移： $u,v$ 路径可以由 $v$ 为根时 $u$ 的父亲（即 $u$ 内侧的点）和 $v$ 转移而来，故 $dp[u][v]=dp[fa[v][u]]+sz[v][u]\\cdot sz[u][v]$. $u,v$ 路径也可以由 $u$ 为根时 $v$ 的父亲（即 $v$ 内侧的点）和 $u$ 转移而来，故 $dp[u][v]=dp[fa[u][v]]+sz[u][v]*sz[v][u]$. 综上，$dp$ 转移方程为：$dp[u][v]=\\max(dp[fa[u][v]][u], dp[fa[v][u]][v]) + sz[u][v]\\cdot sz[v][u]$. $dp$ 方向本是从内向外的，但是这样不太好写，可以采用记忆化搜索，从外向内搜索，回溯时从内向外更新。 复杂度：$O(n^2)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 3005;int n, u, v;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N][N], sz[N][N];LL dp[N][N], ans = -1e16;void dfs(int rt, int x, int f){ fa[rt][x] = f, sz[rt][x] = 1; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(rt, edge[i].to, x); sz[rt][x] += sz[rt][edge[i].to]; }}LL DP(int x, int y){ if(x == y) return 0ll; if(dp[x][y]) return dp[x][y]; return dp[x][y] = sz[x][y] * sz[y][x] + max(DP(x, fa[x][y]), DP(y, fa[y][x]));}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++){ scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); } for(int i = 1; i &lt;= n; i++) dfs(i, i, 0); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) ans = max(ans, DP(i, j)); printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/02/11/CF1292C-Xenon-s-Attack-on-the-Gangs/"},{"title":"[CF1310D] Tourism","text":"题目链接 Solution给定一个带权完全图，求从 $1$ 出发走 $k$ 条边回到 $1$ 且路径中没有奇圈的最小距离。 如果忽略“没有奇圈”这个条件，就是一个简单的 dp：设 $dp[i][j]$ 表示用 $j$ 步走到 $i$ 的最小距离，则：$dp[i][j]=\\min\\limits_{1\\leq r\\leq n \\wedge r\\neq i}dp[r][j-1]+w_{r,i}$. 复杂度为 $O(n^2k)$. 回忆奇圈的充要条件：一个图是二分图当且仅当该图不含奇圈。所以我们把原图二染色，即相当于删掉一些边使之成为二分图，然后再 dp。 然而暴力 $O(2^n)$ 二染色不可取，于是我们就……随机化！算一算正确概率：答案路径长为 $k$，只要它被染成“黑-白-……”或“白-黑-……”就得到了正确答案，所以正确概率是 $\\frac{2}{2^k}=2^{1-k}\\geq\\frac{1}{512}$. 只要我们做 $5000$ 次，错误概率就是 $\\left(\\frac{511}{512}\\right)^{5000}=5\\cdot10^{-5}$. 复杂度 $O(5000\\cdot n^2k)$，极限数据 $3e8$，然后就看评测机给不给力了（CF 的评测机无压力） Code123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;using namespace std;typedef long long LL;const int N = 85;int n, k, col[N];LL g[N][N], dp[N][15], ans = 1e16;inline void solve(){ memset(dp, 0x7f, sizeof dp); dp[1][0] = 0; for(int j = 1; j &lt;= k; j++){ for(int i = 1; i &lt;= n; i++){ for(int r = 1; r &lt;= n; r++){ if(col[r] == col[i]) continue; dp[i][j] = min(dp[i][j], dp[r][j-1] + g[r][i]); } } } ans = min(ans, dp[1][k]);}int main(){ srand(time(NULL)); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) scanf(&quot;%lld&quot;, &amp;g[i][j]); for(int _ = 1; _ &lt;= 5000; _++){ for(int i = 1; i &lt;= n; i++) col[i] = rand() % 2; solve(); } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/03/01/CF1310D-Tourism/"},{"title":"[CF1295F] Good Contest","text":"题目链接 Solution【参考：官方题解，博客】 总体思路：计算出单调不升序列的数量，除以总数量 $\\prod(R_i-L_i+1)$ 即是答案。 先把闭区间 $[L,R]$ 转换为左闭右开区间 $[L,R+1)$，然后离散化，即视所有 $L_i,R_i$ 把整个区间分成了 $O(n)$ 个小线段，离散化后的 $L_i,R_i$ 就指的是原来的 $L_i,R_i$ 是第几个小线段的端点。现在我们知道，一个单调不升序列一定是从右边的小线段往左边取值，即若 $i&lt;j$，则 $i$ 所属小线段 $\\geq$ $j$ 所属小线段。 欲 dp 解之： dp 状态：设 $dp[i][j]$ 表示前 $i$ 个数全在 $j$ 及其以后的小线段中，且后面的数全在第 $j$ 个小线段之前的方案数。 转移方程：考虑哪些数放在第 $j$ 个小线段中，即 $dp[i][j]$ 从 $dp[i-k][j+1]$ 转移而来，其中从 $i-k+1\\sim i$ 的这 $k$ 个数全放在第 $j$ 个小线段。这样放的方案数是多少？注意到我们这 $k$ 个数必须从右往左放，一共有第 $j$ 个小线段的长度 $length(j)$ 那么多位置可以放。把问题抽象出来是：将 $k$ 个相同小球放入 $length(j)$ 个不同的盒子且允许盒子为空的方案数。这是一个经典的组合问题，其等价于在 $k$ 个小球之间插入 $length(j)-1$ 个隔板且隔板可以相邻，那么无论怎么插隔板，隔板和小球的总数是 $k+length(j)-1$，其中选 $k$ 个位置作为小球，一共是 $C_{k+length(j)-1}^k$ 种方案。 综上，$$dp[i][j] = \\sum\\limits_{1\\leq k\\leq i\\bigwedge j\\in[L_{i-k+1},R_{i-k+1}]} dp[i-k][j+1]\\cdot C_{k+length(j)-1}^k$$其中求和的条件 $j\\in[L_{i-k+1},R_{i-k+1}]$ 是指 $i-k+1\\sim i$ 这 $k$ 个数都能在第 $j$ 个线段里取值。 注意上式只求了 $i-k+1\\sim i$ 这 $k$ 个数全只在第 $j$ 个线段里取值的方案数，所以还要后缀和。 转移顺序：由方程可知，顺序枚举即可。 边界条件：$dp[0][j]=1$ 复杂度：顺序枚举 $i,j,k$ 是 $O(n^3)$，求组合数 $O(n)$，共 $O(n^4)$. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const LL MOD = 998244353;const int N = 205;LL fpow(LL bs, LL idx){ LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int n, L[N], R[N], t[N];LL dp[N][N], sum = 1;inline LL C(LL x, LL y){ if(y &gt; x) return 0ll; if(y == 0 || x == y) return 1ll; LL res = 1, tmp = 1; for(LL i = x; i &gt;= x - y + 1; i--) (res *= i) %= MOD; for(LL i = 1; i &lt;= y; i++) (tmp *= i) %= MOD; return res * fpow(tmp, MOD - 2) % MOD;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d%d&quot;, &amp;L[i], &amp;R[i]); (sum *= (R[i] - L[i] + 1)) %= MOD; t[++t[0]] = L[i], t[++t[0]] = R[i] + 1; } sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++){ L[i] = lower_bound(t+1, t+t[0]+1, L[i]) - t; R[i] = lower_bound(t+1, t+t[0]+1, R[i] + 1) - t; } for(int j = 1; j &lt;= t[0]; j++) dp[0][j] = 1; for(int i = 1; i &lt;= n; i++){ for(int j = L[i]; j &lt; R[i]; j++){ for(int k = 1; k &lt;= i; k++){ if(L[i-k+1] &gt; j || R[i-k+1] &lt;= j) break; (dp[i][j] += dp[i-k][j+1] * C(t[j+1] - t[j] + k - 1, k) % MOD) %= MOD; } } for(int j = t[0] - 1; j &gt;= 1; j--) (dp[i][j] += dp[i][j+1]) %= MOD; } printf(&quot;%lld\\n&quot;, dp[n][1] * fpow(sum, MOD - 2) % MOD); return 0;}","link":"/blog-xcpc/2020/03/01/CF1295F-Good-Contest/"},{"title":"[CF1285E] Delete a Segment","text":"题目链接 Solution这道题似乎有好几种做法来着……不过最直观的是直接上线段树啦～ 区间加、求总体的段数……诶，等等，这不是扫描线求矩形周长并的那棵线段树吗！就是那棵没有 pushdown 的神奇线段树啊！（顺便放个链接：关于扫描线算法中线段树标记的理解） 注意一下离散化可能会使原来没有挨着的坐标挨着，所以离散化之后乘个 $2$ 就好了。 然后就没什么好说的了…… Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 400005;int T, n, t[N], maxx;struct segment{ int l, r; int dl, dr; // after discretization}a[N];inline void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++){ a[i].dl = lower_bound(t+1, t+t[0]+1, a[i].l) - t; a[i].dr = lower_bound(t+1, t+t[0]+1, a[i].r) - t; a[i].dl &lt;&lt;= 1, a[i].dr &lt;&lt;= 1; maxx = max(maxx, max(a[i].dl, a[i].dr)); }}struct segTree{ int l, r, cnt, tim; bool lcon, rcon;}tr[N&lt;&lt;3];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ if(tr[id].cnt){ tr[id].tim = 1; tr[id].lcon = tr[id].rcon = true; } else if(tr[id].l == tr[id].r){ tr[id].tim = 0; tr[id].lcon = tr[id].rcon = false; } else{ tr[id].tim = tr[lid].tim + tr[rid].tim - (tr[lid].rcon &amp;&amp; tr[rid].lcon); tr[id].lcon = tr[lid].lcon, tr[id].rcon = tr[rid].rcon; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].cnt = tr[id].tim = tr[id].lcon = tr[id].rcon = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].cnt += val; pushup(id); return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}int main(){ read(T); while(T--){ read(n); maxx = t[0] = 0; for(int i = 1; i &lt;= n; i++){ read(a[i].l, a[i].r); t[++t[0]] = a[i].l, t[++t[0]] = a[i].r; } disc(); build(1, 1, maxx); for(int i = 1; i &lt;= n; i++) add(1, a[i].dl, a[i].dr, 1); int ans = 0; for(int i = 1; i &lt;= n; i++){ add(1, a[i].dl, a[i].dr, -1); ans = max(ans, tr[1].tim); add(1, a[i].dl, a[i].dr, 1); } printf(&quot;%d\\n&quot;, ans); } return 0;}","link":"/blog-xcpc/2020/02/16/CF1285E-Delete-a-Segment/"},{"title":"[CF1316F] Battalion Strength","text":"题目链接 Solution考虑每一个数对 $(i,j)\\ (i&lt;j)$ 的贡献，它等于 $i,j$ 同时出现且之间没有数字出现的概率 $\\frac{1}{2^{j-i+1}}$ 乘上能力值之积，即 $\\frac{p_ip_j}{2^{j-i+1}}$. 于是答案可写作：$$\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n\\frac{p_ip_j}{2^{j-i+1}}=\\sum\\limits_{i=1}^n\\left[2^{i-1}p_i\\sum\\limits_{i+1}^n\\frac{p_j}{2^j}\\right]$$要维护修改操作，容易想到用值域线段树完成，考虑如何 pushup： 运用和 CDQ 分治类似的思想，我们只需要考虑如何统计 $i$ 从左子区间取、$j$ 从右子区间取的贡献。设左子区间共有 $k$ 个数，那么 $i\\leq k&lt;j$，于是贡献为：$$\\left(\\sum\\limits_{i=1}^k2^{i-1}p_i\\right)\\left(\\sum\\limits_{j=k+1}^n\\frac{p_j}{2^j}\\right)=\\left(\\sum\\limits_{i=1}^k2^{i-1}p_i\\right)\\frac{\\left(\\sum\\limits_{j=1}^{n-k}\\frac{p_j}{2^j}\\right)}{2^k}$$因此每个线段树节点维护四个信息： $val$：即答案 $cnt$：有多少个数 $Lval=\\sum\\limits_{i=1}^{cnt}2^{i-1}p_i$ $Rval=\\sum\\limits_{i=1}^{cnt}\\frac{p_i}{2^i}$ pushup 时： $val=val_l+val_r+\\frac{Lval_l\\cdot Rval_r}{2^{cnt_l}}$ $cnt=cnt_l+cnt_r$ $Lval=Lval_l+Lval_r\\cdot 2^{cnt_l}$ $Rval=Rval_l+\\frac{Rval_r}{2^{cnt_l}}$ 最后，在叶节点处做更改时需要手推一下式子；幂次预处理，否则会 TLE. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 300005;const LL MOD = 1000000007;int n, q;LL t[N&lt;&lt;1], P[N], invP[N], p[N], maxx;struct Query{ int pos; LL x;}que[N];void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++){ p[i] = lower_bound(t+1, t+t[0]+1, p[i]) - t; maxx = max(maxx, p[i]); } for(int i = 1; i &lt;= q; i++){ que[i].x = lower_bound(t+1, t+t[0]+1, que[i].x) - t; maxx = max(maxx, que[i].x); }}inline LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res % MOD;}struct segTree{ int l, r; LL val, Lval, Rval, cnt;}tr[N&lt;&lt;3];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].val = (tr[lid].val + tr[rid].val + tr[lid].Lval * tr[rid].Rval % MOD * invP[tr[lid].cnt]) % MOD; tr[id].Lval = (tr[lid].Lval + tr[rid].Lval * P[tr[lid].cnt]) % MOD; tr[id].Rval = (tr[lid].Rval + tr[rid].Rval * invP[tr[lid].cnt]) % MOD; tr[id].cnt = tr[lid].cnt + tr[rid].cnt;}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].val = tr[id].Lval = tr[id].Rval = tr[id].cnt = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int x, int val){ if(tr[id].l == tr[id].r){ tr[id].cnt += val; if(tr[id].cnt &gt; 0) tr[id].val = t[x] * t[x] % MOD * ((tr[id].cnt * P[tr[id].cnt-1] - P[tr[id].cnt] + 1) % MOD) % MOD * invP[tr[id].cnt] % MOD; else tr[id].val = 0; tr[id].Lval = (P[tr[id].cnt] - 1) % MOD * t[x] % MOD; tr[id].Rval = (P[tr[id].cnt] - 1) * invP[tr[id].cnt] % MOD * t[x] % MOD; return; } if(x &lt;= mid) add(lid, x, val); else add(rid, x, val); pushup(id);}int main(){ read(n); P[0] = 1, invP[0] = 1; for(int i = 1; i &lt;= n; i++){ read(p[i]); t[++t[0]] = p[i]; P[i] = P[i-1] * 2 % MOD; invP[i] = fpow(P[i], MOD - 2) % MOD; } read(q); for(int i = 1; i &lt;= q; i++){ read(que[i].pos, que[i].x); t[++t[0]] = que[i].x; } disc(); build(1, 1, maxx); for(int i = 1; i &lt;= n; i++) add(1, p[i], 1); printf(&quot;%lld\\n&quot;, tr[1].val); for(int i = 1; i &lt;= q; i++){ add(1, p[que[i].pos], -1); add(1, que[i].x, 1); p[que[i].pos] = que[i].x; printf(&quot;%lld\\n&quot;, tr[1].val); } return 0;}","link":"/blog-xcpc/2020/03/08/CF1316F-Battalion-Strength/"},{"title":"[CF1335F] Robots on a Grid","text":"题目链接 Solution其实给定的图是一个基环树森林。 容易知道，对于每一个基环树，它最多能放的机器人数量就是它的环的长度。主要问题在于怎么找到一种放置方式使黑色节点最多。 我们可以任取环内一点开始 $dfs$，用 $1\\sim r$ 循环染色，其中 $r$ 是环的长度。可以证明，在两个同色的节点处放置机器人是不合法的，因为充分长的时间后，它们会在环中该颜色的节点处相遇，换句话说，它们之间相差整数个周期（一个周期就是 $r$）；而在不同色的节点处的两个机器人，它们永远都不会差整数个周期，就永远不会相遇。 所以开一个 set，记录某颜色是否有黑色节点，最后数 set 的大小即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1000005;int T, n, m;char s[N];vector&lt;char&gt; c, g;vector&lt;int&gt; edge[N];int fa[N];int findfa(int x){ return fa[x] == x ? x : fa[x] = findfa(fa[x]); }void unionn(int x, int y){ if(findfa(x) == findfa(y)) return; fa[findfa(y)] = findfa(x);}inline int getNum(int x, int y){ return x * m + y; }vector&lt;bool&gt; vis;vector&lt;int&gt; dis;int dfs(int x, int d){ if(vis[x]) return d - dis[x]; vis[x] = 1; dis[x] = d; if(g[x] == 'U') return dfs(x-m, d+1); if(g[x] == 'D') return dfs(x+m, d+1); if(g[x] == 'L') return dfs(x-1, d+1); if(g[x] == 'R') return dfs(x+1, d+1); return -233;}vector&lt;bool&gt; vis2;set&lt;int&gt; col;void dfs(int x, int color, int MOD){ if(vis2[x]) return; vis2[x] = 1; if(c[x] == '0') col.insert(color); for(auto nxt: edge[x]) dfs(nxt, (color + 1) % MOD, MOD);}int main(){ for(read(T); T; T--){ read(n, m); for(int i = 0; i &lt; n * m; i++){ fa[i] = i; edge[i].clear(); } vis.clear(); vis.resize(n * m, 0); vis2.clear(); vis2.resize(n * m, 0); dis.clear(); dis.resize(n * m, 0); c.resize(n * m), g.resize(n * m); for(int i = 0; i &lt; n; i++){ scanf(&quot;%s&quot;, s); for(int j = 0; j &lt; m; j++) c[i*m+j] = s[j]; } for(int i = 0; i &lt; n; i++){ scanf(&quot;%s&quot;, s); for(int j = 0; j &lt; m; j++){ g[i*m+j] = s[j]; if(g[i*m+j] == 'U'){ unionn(getNum(i-1, j), getNum(i, j)); edge[getNum(i-1, j)].emplace_back(getNum(i, j)); } if(g[i*m+j] == 'D'){ unionn(getNum(i+1, j), getNum(i, j)); edge[getNum(i+1, j)].emplace_back(getNum(i, j)); } if(g[i*m+j] == 'L'){ unionn(getNum(i, j-1), getNum(i, j)); edge[getNum(i, j-1)].emplace_back(getNum(i, j)); } if(g[i*m+j] == 'R'){ unionn(getNum(i, j+1), getNum(i, j)); edge[getNum(i, j+1)].emplace_back(getNum(i, j)); } } } int ans0 = 0, ans1 = 0; for(int i = 0; i &lt; n * m; i++){ if(findfa(i) == i){ int res = dfs(i, 0); ans0 += res; col.clear(); dfs(i, 0, res); ans1 += col.size(); } } printf(&quot;%d %d\\n&quot;, ans0, ans1); } return 0;}","link":"/blog-xcpc/2020/04/14/CF1335F-Robots-on-a-Grid/"},{"title":"[CF833B] The Bakery","text":"题目链接 Solution考虑最简单的 $dp$：设 $dp[i][j]$ 表示将前 $i$ 个数字分成 $j$ 段能得到的最大价值，则：$$dp[i][j] =\\max_{k=1}^{i-1} {dp[k][j-1]+c(k+1,i)}$$其中，$c(k+1,i)$ 表示 $a[k+1],,a[k+2],\\cdots,a[i]$ 中不同数字的个数。 为了快速转移，我们考虑用线段树维护 $dp[k][j-1]+c(k+1,i)$，那么就能够做到 $O(nk\\log n)$。注意 $c(k+1,i)$ 是与 $i$ 有关的，当我们遍历 $i$ 时，我们需要随时更新线段树中的信息以保证正确性。考虑 $c(k+1,i)$ 什么时候会改变——当区间 $[k+1,i]$ 中没有 $a[i]$ 这个数时，$c(k+1,i)$ 就相比 $c(k+1,i-1)$ 加了 $1$，所以更新信息的操作就是找到与 $a[i]$ 相同的数上一次出现的位置（设为 $p$），对 $[p,i-1]$ 进行区间加 $1$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 35005;const int K = 55;struct segTree{ int l, r, mx, lazy;}tr[K][N&lt;&lt;2];#define lid (id&lt;&lt;1)#define rid (id&lt;&lt;1|1)#define mid ((tr[k][id].l + tr[k][id].r) &gt;&gt; 1)inline void pushup(int k, int id){ tr[k][id].mx = max(tr[k][lid].mx, tr[k][rid].mx);}inline void pushdown(int k, int id){ if(tr[k][id].l == tr[k][id].r) return; if(tr[k][id].lazy){ tr[k][lid].lazy += tr[k][id].lazy; tr[k][lid].mx += tr[k][id].lazy; tr[k][rid].lazy += tr[k][id].lazy; tr[k][rid].mx += tr[k][id].lazy; tr[k][id].lazy = 0; }}void build(int k, int id, int l, int r){ tr[k][id].l = l, tr[k][id].r = r; tr[k][id].mx = tr[k][id].lazy = 0; if(l == r) return; build(k, lid, l, mid), build(k, rid, mid+1, r); pushup(k, id);}void st(int k, int id, int pos, int val){ pushdown(k, id); if(tr[k][id].l == tr[k][id].r){ tr[k][id].mx = val; tr[k][id].lazy = 0; return; } if(pos &lt;= mid) st(k, lid, pos, val); else st(k, rid, pos, val); pushup(k, id);}void add(int k, int id, int l, int r, int val){ pushdown(k, id); if(tr[k][id].l == l &amp;&amp; tr[k][id].r == r){ tr[k][id].lazy += val; tr[k][id].mx += val; return; } if(r &lt;= mid) add(k, lid, l, r, val); else if(l &gt; mid) add(k, rid, l, r, val); else add(k, lid, l, mid, val), add(k, rid, mid+1, r, val); pushup(k, id);}int queryMax(int k, int id, int l, int r){ pushdown(k, id); if(tr[k][id].l == l &amp;&amp; tr[k][id].r == r) return tr[k][id].mx; if(r &lt;= mid) return queryMax(k, lid, l, r); else if(l &gt; mid) return queryMax(k, rid, l, r); else return max(queryMax(k, lid, l, mid), queryMax(k, rid, mid+1, r));}int n, k, a[N], lst[N], pre[N], dp[N][K];int main(){ read(n, k); for(int i = 1; i &lt;= n; i++){ read(a[i]); dp[i][1] = dp[i-1][1] + (lst[a[i]] == 0); pre[i] = max(1, lst[a[i]]); lst[a[i]] = i; } for(int j = 1; j &lt;= k; j++) build(j, 1, 1, n); for(int i = 1; i &lt;= n; i++) st(1, 1, i, dp[i][1]); for(int j = 2; j &lt;= k; j++){ for(int i = j; i &lt;= n; i++){ add(j-1, 1, pre[i], i-1, 1); dp[i][j] = queryMax(j-1, 1, 1, i-1); st(j, 1, i, dp[i][j]); } } printf(&quot;%d\\n&quot;, dp[n][k]); return 0;}","link":"/blog-xcpc/2021/05/19/CF833B-The-Bakery/"},{"title":"[CF1324F] Maximum White Subtree","text":"题目链接 Solution如果只询问根节点的答案，那是一道很简单的 $dp$ 题：设 $dp[i]$ 是以 $i$ 为根的子树的答案，$dfs$ 一遍就能得到答案。 现在考虑换根的问题，如果根节点从 $x$ 换成与之相邻的 $y$，可以发现 $dp$ 值改变的只有 $dp[x]$ 和 $dp[y]$，且 dp[x] -= max(0, dp[y]), dp[y] += max(0, dp[x]) 即可。于是再 $dfs$ 一遍得到所有点的答案。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 200005;int n, a[N], ans[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int res[N];int dfs(int x, int f){ for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; res[x] += max(0, dfs(edge[i].to, x)); } return res[x];}void dfsAns(int x, int f){ ans[x] = res[x]; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; res[x] -= max(0, res[edge[i].to]); res[edge[i].to] += max(0, res[x]); dfsAns(edge[i].to, x); res[edge[i].to] -= max(0, res[x]); res[x] += max(0, res[edge[i].to]); }}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d&quot;, &amp;a[i]); res[i] = a[i] == 1 ? 1 : -1; } for(int i = 1; i &lt; n; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); } dfs(1, 0); dfsAns(1, 0); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); return 0;}","link":"/blog-xcpc/2020/03/13/CF1324F-Maximum-White-Subtree/"},{"title":"[CF85D] Sum of Medians","text":"题目链接 Solution值域线段树。 线段树节点上存储信息：$sum_{0,1,2,3,4}$，$sum_i$ 表示该节点对应区间内第模 $5$ 余 $i$ 的所有数之和，注意这里的第 $i$ 个数是这个区间内的第 $i$ 个数，与前面的区间有多少数无关。考虑更新 $sum_i$ 的值：一个节点的左右儿子更新上来时，左儿子的第 $i$ 个数还是该节点的第 $i$ 个数，但是右儿子的第 $i$ 个数实际上是该节点的第 $i+size(左儿子)$ 个数，所以顺带维护一个节点大小信息 $size$ 即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int n, t[N], maxx, func[N];struct Query{ char s[10]; int x, dx;}q[N];inline void disc(){ sort(t+1, t+t[0]+1); t[0] = unique(t+1, t+t[0]+1) - (t+1); for(int i = 1; i &lt;= n; i++){ q[i].dx = lower_bound(t+1, t+t[0]+1, q[i].x) - t; maxx = max(maxx, q[i].dx); func[q[i].dx] = q[i].x; }}inline LL getMod(LL x){ return (x % 5 + 5) % 5; }struct segTree{ int l, r, size; LL sum[5];}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ for(int i = 0; i &lt; 5; i++) tr[id].sum[i] = tr[lid].sum[i] + tr[rid].sum[getMod(i - tr[lid].size)]; tr[id].size = tr[lid].size + tr[rid].size;}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].size = 0; for(int i = 0; i &lt; 5; i++) tr[id].sum[i] = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int pos, int val){ if(tr[id].l == tr[id].r){ tr[id].sum[1] = (val == 1) * func[tr[id].l]; tr[id].size += val; return; } if(pos &lt;= mid) add(lid, pos, val); else add(rid, pos, val); pushup(id);}int main(){ read(n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%s&quot;, q[i].s); if(q[i].s[0] == 'a'){ read(q[i].x); t[++t[0]] = q[i].x; } else if(q[i].s[0] == 'd'){ read(q[i].x); t[++t[0]] = q[i].x; } } disc(); build(1, 1, maxx); for(int i = 1; i &lt;= n; i++){ if(q[i].s[0] == 'a') add(1, q[i].dx, 1); if(q[i].s[0] == 'd') add(1, q[i].dx, -1); if(q[i].s[0] == 's') cout &lt;&lt; tr[1].sum[3] &lt;&lt; endl; } return 0;}","link":"/blog-xcpc/2020/02/17/CF85D-Sum-of-Medians/"},{"title":"[CF1517D] Explorer Space","text":"题目链接 Solution当 $k$ 是奇数时，肯定无法回到原点，所以只用考虑 $k$ 是偶数的情况。很显然，从 $u$ 回到其本身的最优路径一定是先从 $u$ 走 $k/2$ 步到某个 $v$，再从 $v$ 原路返回 走 $k/2$ 步到 $u$。所以问题转化为对每个点求走 $k/2$ 步的最短路（不管最后走到哪里），答案就是这个长度乘 $2$。设 $dp[i][j][t]$ 表示从 $(i,j)$ 出发走了 $t$ 步到达终点的最短路长度，则 $dp[i][j][t]$ 可以从 $dp[i-1][j][t+1],,dp[i+1][j][t+1],,dp[i][j-1][t+1],,dp[i][j+1][t+1]$ 四个方向转移而来，初始条件是 $dp[i][j][k/2]=0$. 当然如果想看得更直观一点，可以想象一个 $k$ 层的分层图，那么我们求的就是从第 $0$ 层走到第 $k$ 层任意一个节点的最短路。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x) const int N = 505; int n, m, k;LL a[N][N], b[N][N], dp[N][N][25]; int main(){ read(n, m, k); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt; m; j++) read(a[i][j]); for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt;= m; j++) read(b[i][j]); if(k &amp; 1){ for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) printf(&quot;%d%c&quot;, -1, &quot; \\n&quot;[j==m]); return 0; } k &gt;&gt;= 1; memset(dp, 0x7f, sizeof dp); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) dp[i][j][k] = 0; for(int kk = k - 1; kk &gt;= 0; kk--){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(i &lt; n) dp[i+1][j][kk] = min(dp[i][j][kk+1] + b[i][j], dp[i+1][j][kk]); if(i &gt; 1) dp[i-1][j][kk] = min(dp[i][j][kk+1] + b[i-1][j], dp[i-1][j][kk]); if(j &lt; m) dp[i][j+1][kk] = min(dp[i][j][kk+1] + a[i][j], dp[i][j+1][kk]); if(j &gt; 1) dp[i][j-1][kk] = min(dp[i][j][kk+1] + a[i][j-1], dp[i][j-1][kk]); } } } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) printf(&quot;%lld%c&quot;, dp[i][j][0] * 2, &quot; \\n&quot;[j == m]); return 0;}","link":"/blog-xcpc/2021/05/19/CF1517D-Explorer-Space/"},{"title":"Codeforces Global Round 7","text":"比赛链接 / 官方题解链接 A. Bad Ugly NumbersSolution输出 $999\\cdots98$ 或者$233\\cdots3$ 之类的都行。 Code>folded12345678910111213141516171819202122232425262728#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T, n;int main(){ read(T); while(T--){ read(n); if(n == 1) puts(&quot;-1&quot;); else{ for(int i = 1; i &lt; n; i++) putchar('9'); puts(&quot;8&quot;); } } return 0;} B. MaximumsSolution从左到右依次恢复即可。 Code>folded1234567891011121314151617181920212223242526272829#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;int a[N], b[N], n;int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(b[i]); int mx = 0; for(int i = 1; i &lt;= n; i++){ a[i] = b[i] + mx; mx = max(mx, a[i]); } for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); return 0;} C. Permutation PartitionsSolution最大值就是最大的 $k$ 个数之和。统计方案数时考虑在两个选出的数中插一个隔板，乘法原理即可。 Code>folded12345678910111213141516171819202122232425262728293031323334353637#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;const LL MOD = 998244353;LL n, k;LL p[N], ans, cnt = 1;int main(){ read(n, k); for(int i = 1; i &lt;= n; i++) read(p[i]); ans = (2 * n + 1 - k) * k / 2; int pre = 0; for(int i = 1; i &lt;= n; i++){ if(p[i] &gt;= n - k + 1){ if(!pre) pre = i; else{ (cnt *= i - pre) %= MOD; pre = i; } } } printf(&quot;%lld %lld\\n&quot;, ans, cnt); return 0;} D1&amp;D2. Prefix-Suffix PalindromeSolution先把头尾对称的字符加入答案并去掉，问题转化为寻找最大前缀/后缀回文串。为方便处理，字符两两之间插入 # 使长度为奇数。然后枚举中间点，通过正反哈希值判断能否形成回文串。 复杂度：$O(|s|)$ Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 2000005;const LL MOD = 998244353;LL h[N], invh[N], power[N], base = 233; // hash value of string s[1...i] is stored in h[i]void Hash(char s[], int len){ h[1] = s[1]; h[0] = 0; for(int i = 2; i &lt;= len; i++) h[i] = (h[i-1] * base % MOD + s[i]) % MOD;}void invHash(char s[], int len){ invh[len] = s[len]; invh[len+1] = 0; for(int i = len - 1; i &gt;= 1; i--) invh[i] = (invh[i+1] * base % MOD + s[i]) % MOD;}LL getSubstring(int l, int r){ // get hash value of s[l...r] return ((h[r] - h[l-1] * power[r - l + 1] % MOD) % MOD + MOD) % MOD;}LL getSubstringinv(int l, int r){ return ((invh[l] - invh[r+1] * power[r - l + 1] % MOD) % MOD + MOD) % MOD;}int T, n;char s[N], ans[N], t[N];int main(){ power[0] = 1; for(int i = 1; i &lt;= 1000000; i++) power[i] = power[i-1] * base % MOD; read(T); while(T--){ scanf(&quot;%s&quot;, s+1); n = strlen(s+1); if(n == 1){ printf(&quot;%s\\n&quot;, s+1); continue; } int id = 0, l = 0, r = n + 1; for(int i = 1; i &lt;= n / 2; i++){ if(s[i] == s[n - i + 1]) ans[++id] = s[i], l = i, r = n - i + 1; else break; } if(l == r - 1){ for(int i = 1; i &lt;= id; i++) putchar(ans[i]); for(int i = id; i &gt;= 1; i--) putchar(ans[i]); puts(&quot;&quot;); continue; } int tid = 0; for(int i = l + 1; i &lt; r; i++) t[++tid] = s[i], t[++tid] = '#'; tid--; Hash(t, tid); invHash(t, tid); int mark = 0, mx = 0; for(int i = 1; i &lt;= tid; i++){ if(i &lt;= tid - i + 1){ if(getSubstring(1, i) == getSubstringinv(i, i + i - 1)){ if(mx &lt; i){ mx = i; mark = i; } } } else{ if(getSubstring(i - (tid - i + 1) + 1, i) == getSubstringinv(i, tid)){ if(mx &lt; tid - i + 1){ mx = tid - i + 1; mark = i; } } } } if(mark &lt;= tid - mark + 1) for(int i = 1; i &lt;= mark; i++) ans[++id] = t[i]; else for(int i = tid; i &gt;= mark; i--) ans[++id] = t[i]; for(int i = 1; i &lt;= id; i++) if(ans[i] != '#') putchar(ans[i]); for(int i = id - 1; i &gt;= 1; i--) if(ans[i] != '#') putchar(ans[i]); puts(&quot;&quot;); } return 0;} E. BombsSolution【参考博客】答案是单调不增的。我们只需递减枚举答案上界 $x$，判断答案是否小于 $x$. 若答案小于 $x$，那么所有 $\\geq x$ 的点都会被炸掉，于是乎： 最靠右的 $\\geq x$ 的点的右侧（包括自己）必须要有至少 $1$ 个炸弹 次靠右的 $\\geq x$ 的点的右侧必须要有至少 $2$ 个炸弹 $\\cdots$ 第 $k$ 靠右的 $\\geq x$ 的点的右侧必须要有至少 $k$ 个炸弹 我们维护一个序列 $a_i=其右的炸弹数-其右 \\geq x 的数的数量$，若所有 $a_i$ 都 $\\geq0$，则答案小于 $x$. 于是我们对这个序列的操作有： 加入一个炸弹，将加入位置及其以前的所有 $a_i$ 加 $1$； $x$ 变成 $x-1$，将数 $x-1$ 所在位置及其以前的所有 $a_i$ 减 $1$； 询问所有 $a_i$ 的最小值。 线段树即可。 复杂度：$O(n\\lg n)$ Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 300005;struct segTree{ int l, r, mn, lazy;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].mn = min(tr[lid].mn, tr[rid].mn);}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazy){ tr[lid].lazy += tr[id].lazy; tr[lid].mn += tr[id].lazy; tr[rid].lazy += tr[id].lazy; tr[rid].mn += tr[id].lazy; tr[id].lazy = 0; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazy += val; tr[id].mn += val; return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}int n, p[N], q[N], pos[N];int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(p[i]); pos[p[i]] = i; } build(1, 1, n); printf(&quot;%d &quot;, n); int x = n + 1; for(int i = 1; i &lt;= n; i++){ read(q[i]); if(i == n) break; add(1, 1, q[i], 1); pushdown(1); while(tr[1].mn &gt;= 0){ x--; add(1, 1, pos[x], -1); pushdown(1); } printf(&quot;%d &quot;, x); } return 0;}","link":"/blog-xcpc/2020/03/20/Codeforces-Global-Round-7/"},{"title":"[CF1176F] Destroy it!","text":"题目链接 Solution每一轮中，值为 $1$ 的卡只需要保留伤害最高的三张，值为 $2$ 的一张，值为 $3$ 的一张，所以最多 $5$ 张卡。然后设 $dp[i][j]$ 表示第 $i$ 轮已经打出了模 $10$ 余 $j$ 张卡的最大伤害值，转移时分类讨论即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 200005;int n, k;LL dp[N][20], ans;struct Card{ int cost; LL dam; bool operator &lt; (const Card &amp;A) const{ return cost == A.cost ? dam &gt; A.dam : cost &lt; A.cost; }}c[N][10], t[N];inline int MOD(int x){ return (x % 10 + 10) % 10; }int main(){ scanf(&quot;%d&quot;, &amp;n); memset(dp, -0x7f, sizeof dp); dp[0][0] = 0; for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d&quot;, &amp;k); for(int j = 1; j &lt;= k; j++) { scanf(&quot;%d%lld&quot;, &amp;t[j].cost, &amp;t[j].dam); } sort(t+1, t+k+1); int cnt1 = 0, cnt2 = 0, cnt3 = 0; for(int j = 1; j &lt;= k; j++){ if(t[j].cost == 1 &amp;&amp; cnt1 &lt; 3) c[i][++cnt1] = t[j]; else if(t[j].cost == 2 &amp;&amp; !cnt2) cnt2++, c[i][4] = t[j]; else if(t[j].cost == 3 &amp;&amp; !cnt3) cnt3++, c[i][5] = t[j]; } for(int j = 0; j &lt; 10; j++){ dp[i][j] = dp[i-1][j]; if(c[i][5].cost == 3) dp[i][j] = max(dp[i][j], dp[i-1][MOD(j-1)] + c[i][5].dam + (j == 0 ? c[i][5].dam : 0)); if(c[i][4].cost == 2) dp[i][j] = max(dp[i][j], dp[i-1][MOD(j-1)] + c[i][4].dam + (j == 0 ? c[i][4].dam : 0)); if(c[i][4].cost == 2 &amp;&amp; c[i][1].cost == 1) dp[i][j] = max(dp[i][j], dp[i-1][MOD(j-2)] + c[i][4].dam + c[i][1].dam + (j &lt; 2 ? max(c[i][1].dam, c[i][4].dam) : 0)); if(c[i][1].cost == 1) dp[i][j] = max(dp[i][j], dp[i-1][MOD(j-1)] + c[i][1].dam + (j == 0 ? c[i][1].dam : 0)); if(c[i][2].cost == 1) dp[i][j] = max(dp[i][j], dp[i-1][MOD(j-2)] + c[i][1].dam + c[i][2].dam + (j &lt; 2 ? c[i][1].dam : 0)); if(c[i][3].cost == 1) dp[i][j] = max(dp[i][j], dp[i-1][MOD(j-3)] + c[i][1].dam + c[i][2].dam + c[i][3].dam + (j &lt; 3 ? c[i][1].dam : 0)); } } for(int j = 0; j &lt; 10; j++) ans = max(ans, dp[n][j]); printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/02/28/CF1176F-Destroy-it/"},{"title":"Codeforces Global Round 10","text":"比赛链接 / 官方题解链接 A. Omkar and PasswordSolution如果全部相同，则答案是序列长度；否则，答案一定是 $1$，因为我可以选择序列中最大的元素，不断加给它（如果有多个相同的最大元素，由于不全相同，一定有某个最大元素与不同的元素相邻，它们相加后成为了序列中的唯一最大元素）。 Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, a[N], T;int main(){ for(read(T); T; T--){ read(n); bool same = true; read(a[1]); for(int i = 2; i &lt;= n; i++){ read(a[i]); if(a[i] != a[1]) same = false; } if(same) printf(&quot;%d\\n&quot;, n); else puts(&quot;1&quot;); } return 0;} B. Omkar and Infinity ClockSolution画画图就知道，在一次操作之后，剩下的操作就是在两种状态之间来回变，判断 $k-1$ 的奇偶性即可。 Code1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n;LL k, a[N];int main(){ int T; for(read(T); T; T--){ read(n, k); LL mx = -1e14, mn = 1e14; for(int i = 1; i &lt;= n; i++){ read(a[i]); mx = max(mx, a[i]); mn = min(mn, a[i]); } for(int i = 1; i &lt;= n; i++) a[i] = mx - a[i]; mn = mx - mn; k--; if(k &amp; 1){ for(int i = 1; i &lt;= n; i++) a[i] = mn - a[i]; } for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, a[i]); puts(&quot;&quot;); } return 0;} C. Omkar and WaterslideSolution感觉这道题是最简单的呢。。。每次把整个后缀一起上移就行了，所以答案就是 $\\sum\\limits_{i=2}^n\\max(0,a_{i-1}-a_{i})$. Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n;LL a[N];int main(){ int T; for(read(T); T; T--){ read(n); LL ans = 0; read(a[1]); for(int i = 2; i &lt;= n; i++){ read(a[i]); if(a[i] &lt; a[i-1]) ans += a[i-1] - a[i]; } printf(&quot;%lld\\n&quot;, ans); } return 0;} D. Omkar and Bed WarsSolution画画图，手玩一下可以知道，只有 $LR,LLR,LRR,LLRR$ 是合法的（它们都是以 $LR$ 为“核”，向两边最多扩展一位）。把它们删掉，剩下的部分被分成了几段，每一段形如 $R\\cdots RL\\cdots L$，设 $R$ 有 $c_R$ 个，$L$ 有 $c_L$ 个，那么这一段需要改变的次数就是 $\\left\\lfloor\\frac{c_R}{3}\\right\\rfloor+\\left\\lfloor\\frac{c_L}{3}\\right\\rfloor$. （因为 $3$ 个一组改一次可以合法，如果最后单出一个，改与之相邻的合法片段即可，答案还是除以 $3$ 下取整不变） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n;char s[N], t[N];bool b[N], c[N];inline int get(int x){ x = x % n; if(x == 0) x = n; return x;}inline void expand(int i){ if(!b[get(i+2)] &amp;&amp; s[get(i+2)] == 'R') b[get(i+2)] = true; if(!b[get(i-1)] &amp;&amp; s[get(i-1)] == 'L') b[get(i-1)] = true;}inline int solve(int i, int j){ int cntR = 0, cntL = 0; for(int k = i; k &lt;= j; k++){ cntR += t[k] == 'R'; cntL += t[k] == 'L'; } int res = cntR / 3 + cntL / 3; if(cntR % 3) res++; if(cntL % 3) res++; return res;}int main(){ int T; for(read(T); T; T--){ int ans = 0; read(n); for(int i = 1; i &lt;= n; i++){ b[i] = c[i] = false; } scanf(&quot;%s&quot;, s+1); for(int i = 1; i &lt;= n; i++){ if(b[i] || b[get(i+1)]) continue; if(s[i] == 'L' &amp;&amp; s[get(i+1)] == 'R'){ b[i] = b[get(i+1)] = true; expand(i); } } int ed = 1; for(ed = 1; ed &lt;= n; ed++) if(b[ed]) break; ed--; int tid = 0; for(int i = ed + 1; i &lt;= n; i++) t[++tid] = s[i], c[tid] = b[i]; for(int i = 1; i &lt;= ed; i++) t[++tid] = s[i], c[tid] = b[i];// for(int i = 1; i &lt;= n; i++)// printf(&quot;%c %d\\n&quot;, t[i], c[i]); for(int i = 1; i &lt;= n; i++){ if(c[i]) continue; int j = i; while(j &lt; n &amp;&amp; !c[j+1]) j++; ans += solve(i, j); i = j; } printf(&quot;%d\\n&quot;, ans); } return 0;} E. Omkar and Duck构造题鲨我啊～ Solution构造矩阵：$$a_{i.j}=\\begin{cases}2^{i+j}&amp;,i\\text{ is odd}\\0&amp;,i\\text{ is even}\\end{cases}$$例如，$n=8$ 时构造如下（复制于官方题解）：$$\\begin{matrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 2^{3} &amp; 2^{4} &amp; 2^{5} &amp; 2^{6} &amp; 2^{7} &amp; 2^{8} &amp; 2^{9} &amp; 2^{10} \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 2^{5} &amp; 2^{6} &amp; 2^{7} &amp; 2^{8} &amp; 2^{9} &amp; 2^{10} &amp; 2^{11} &amp; 2^{12} \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 2^{7} &amp; 2^{8} &amp; 2^{9} &amp; 2^{10} &amp; 2^{11} &amp; 2^{12} &amp; 2^{13} &amp; 2^{14} \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 2^{9} &amp; 2^{10} &amp; 2^{11} &amp; 2^{12} &amp; 2^{13} &amp; 2^{14} &amp; 2^{15} &amp; 2^{16} \\ \\end{matrix}$$走到一个位置判断下一步的方向即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 30;int n;LL a[N][N];int main(){ read(n); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ a[i][j] = (i &amp; 1) ? 0 : (1ll &lt;&lt; (i + j)); printf(&quot;%lld &quot;, a[i][j]); } puts(&quot;&quot;); } fflush(stdout); int q; read(q); while(q--){ LL s; read(s); int nowx = 1, nowy = 1; printf(&quot;%d %d\\n&quot;, 1, 1); while(!(nowx == n &amp;&amp; nowy == n)){ if(nowx == n) nowy++; else if(nowy == n) nowx++; else{ if((s&gt;&gt;(nowx+nowy+1))&amp;1){ if(a[nowx+1][nowy]) nowx++; else nowy++; } else{ if(a[nowx+1][nowy]) nowy++; else nowx++; } } printf(&quot;%d %d\\n&quot;, nowx, nowy); } fflush(stdout); } return 0;} F. Omkar and LandslideSolution关键性质：答案中最多只含有一对相等的数，其他数都是以 $1$ 严格递增。 证明：题设“滑坡”操作其实等价于依次考虑每一个高度，一次性把这个高度滑到头。注意初始情况严格递增，没有相等的数。每滑一次，如果之前没有相等的数，那最多新增一对相等的数；如果之前有相等的数 $a_{i-1}=a_i,a_{i+1}=a_i+1$，那么 $a_i$ 加一后与 $a_{i-1}$ 不等了，但是与 $a_{i+1}$ 相等了。所以整个过程始终保证相等的数最多只有一对。证毕。 既然如此，我们知道所有数的总和，就可以唯一构造出这个答案序列。为什么？考虑以 $1$ 递增的等差数列，总和一定介于两个首项差 $1$ 的等差数列的和之间，取小者，多出来多少，前多少个数就加一即可。 Code123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1000005;int n;LL h, sumh;int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(h), sumh += h; LL x = ((2 * sumh) / n - n + 1) / 2; LL sum = (x + x + n - 1) * n / 2; LL diff = sumh - sum; for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, x + i - 1 + (i &lt;= diff)); puts(&quot;&quot;); return 0;}","link":"/blog-xcpc/2020/08/17/Codeforces-Global-Round-10/"},{"title":"Codeforces Round #616 (Div.2)","text":"比赛链接 / 官方题解链接 A. Even But Not EvenSolution从后往前删数直至满足题意或无解。 Better Solution若奇数个数大于1，任意输出2个奇数；否则无解。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 3005;int T, n;char s[N];int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s+1); int len = strlen(s+1); while(len &gt;= 1 &amp;&amp; (s[len] - '0') % 2 == 0) len--; if(len == 0){ puts(&quot;-1&quot;); continue; } int sum = 0; for(int i = 1; i &lt;= len; i++) sum += s[i] - '0'; if(sum % 2 == 0){ for(int i = 1; i &lt;= len; i++) putchar(s[i]); putchar(10); continue; } int mark = 0; for(int i = len - 1; i &gt;= 1; i--){ if((s[i]-'0') &amp; 1){ mark = i; break; } } if(!mark){ puts(&quot;-1&quot;); continue; } bool out = false; for(int i = 1; i &lt; mark; i++) out = true, putchar(s[i]); for(int i = mark + 1; i &lt;= len; i++) out = true, putchar(s[i]); if(!out) printf(&quot;-1&quot;); putchar(10); } return 0;} B. Array SharpeningSolution若 $a_i\\geq i-1$，且 $a_{i-1}$ 可作为递增数列的结尾，那么 $a_i$ 也可以作为递增数列的结尾；下降数列同理。若存在 $a_i$ 使得其既可作为递增数列的结尾，也可作为下降数列的开头，则输出 Yes；否则输出 No。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 300005;int T, n;LL a[N];bool in[N], de[N];int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ in[i] = de[i] = 0; read(a[i]); } for(int i = 1; i &lt;= n; i++){ if(a[i] &gt;= i - 1) in[i] = 1; else break; } for(int i = n; i &gt;= 1; i--){ if(a[i] &gt;= n - i) de[i] = 1; else break; } bool can = false; for(int i = 1; i &lt;= n; i++){ if(in[i] &amp;&amp; de[i]){ puts(&quot;Yes&quot;); can = true; break; } } if(!can) puts(&quot;No&quot;); } return 0;} C. Mind ControlSolution只用考虑排在你前面的人，$k$ 最大取到 $m-1$ 即可。假设受你控制的 $k$ 人中，有 $x$ 人取队首，$k-x$ 人取队尾；不受控制的 $m-1-k$ 人中，有 $y$ 人取队首，$m-1-k-y$ 人取队尾，则 $m-1$ 人取完后，还剩下 $[x+y+1,x+y+n-m+1]$ 区间的数，你取到的数是 $\\max(a_{x+y+1},a_{x+y+n-m+1})$，于是可以枚举 $x,y$，记录最小的取到的数的最大值。 事实上，$ans=\\max\\limits_{x=0}^k\\left[\\min\\limits_{y=0}^{m-1-k}\\left[\\max(a_{x+y+1},a_{x+y+n-m+1})\\right]\\right]$. 复杂度 $O(n^2)$ Advanced version【参考官方题解】存在 $O(n)$ 的解法。对上面的式子变形： $$ans=\\max\\limits_{x=0}^k\\left[\\min\\limits_{y=x}^{x+m-1-k}\\left[\\max(a_{y+1},a_{y+n-m+1})\\right]\\right]$$其中，$\\max(a_{y+1},a_{y+n-m+1})$ 是可以 $O(1)$ 解得的，不妨记为 $b_y$，则$$ans=\\max\\limits_{x=0}^k\\left[\\min\\limits_{y=x}^{x+m-1-k}b_y\\right]$$于是可以枚举 $x$，同时维护一个单调（递增）队列，在线性时间内求解。 Code — $O(n^2)$>folded1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 3505;int T, n, m, k, a[N];inline int solve(int l, int r, int x){ int res = 1e9; for(int i = 0; i &lt;= x; i++){ res = min(res, max(a[l + i], a[r - (x - i)])); } return res;}int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ read(n, m, k); k = min(k, m - 1); for(int i = 1; i &lt;= n; i++) read(a[i]); int ans = 0; for(int i = 1; i &lt;= n; i++){ int j = i + n - k - 1; if(j &gt; n) break; ans = max(ans, solve(i, j, m - 1 - k)); } printf(&quot;%d\\n&quot;, ans); } return 0;} Code — $O(n)$>folded1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 3505;int T, n, m, k, a[N];inline int func(int y){ return max(a[y+1], a[n-m+1+y]); }int main(){ read(T); while(T--){ int ans = 0; read(n, m, k); k = min(k, m - 1); for(int i = 1; i &lt;= n; i++) read(a[i]); deque&lt;int&gt; q; for(int x = 0, j = 0; x &lt;= k; x++){ while(!q.empty() &amp;&amp; q.front() &lt; x) q.pop_front(); while(j &lt;= m-1-k+x){ while(!q.empty() &amp;&amp; func(j) &lt;= func(q.back())) q.pop_back(); q.push_back(j); j++; } ans = max(ans, func(q.front())); } printf(&quot;%d\\n&quot;, ans); } return 0;} D. Irreducible AnagramsSolution【参考官方题解】难点在于寻找 “字符串 $s$ 具有至少一个 irreducible anagram ” 的充要条件。充要条件是字符串 $s$ 满足下列条件之一： $s.length()=1$ $s_1\\neq s_n$ $s$ 含有至少三个不同字母 证明：易知条件1是充分条件；对于条件2，只需将所有 $s_n$ 字母放在最开头，那么容易知道，除了 $s$ 本身以外，$s$ 的其他所有前缀的 $s_n$ 字母出现次数不同于原次数，自然是一个 irreducible anagram，于是条件2也是充分条件。同时不满足条件1、2的字符串满足 $s_1=s_n$，将它们分为三类： $s_1=s_n$ 且含至少三个不同字母：取最靠后一个不同于 $s_1$ 的字母（设为 $x$），把所有该字母放在开头，紧接着所有 $s_1$ 字母，那么每一个前缀要么有更多的 $x$，要么有更少的 $s_1$，是 irreducible anagram。 $s_1=s_n$ 且仅有两个不同字母：不妨设两个不同字母为 $a,b$，$s_1=s_n=a$，$s_x=s_y=b$ 且 $s_x$ 是第一个 $b$，$s_y$ 是最后一个 $b$。假设 $t$ 是 $s$ 的 irreducible anagram，则 $t_1=t_n=b$，于是 $t$ 的前 $x$ 位 $b$ 的次数比 $s$ 多，而前 $y$ 位 $b$ 的次数比 $s$ 少，那么存在一个 $z$，使得前 $z$ 位 $b$ 的次数相等，那么 $s[1…z],t[1…z]$ 是 anagram，因此不存在 irreducible anagram。 $s_1=s_n$ 且仅有一个字母：显然不存在。 证毕。 有了上述充要条件，这道题就很简单了。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;int q, l, r;char s[N];struct Node{ int buc[30]; Node() { memset(buc, 0, sizeof buc); }}a[N];Node operator + (const Node &amp;A, const Node &amp;B){ Node C; for(int i = 0; i &lt; 26; i++) C.buc[i] = A.buc[i] + B.buc[i]; return C;}Node operator - (const Node &amp;A, const Node &amp;B){ Node C; for(int i = 0; i &lt; 26; i++) C.buc[i] = A.buc[i] - B.buc[i]; return C;}int main(){ scanf(&quot;%s&quot;, s+1); int len = strlen(s+1); for(int i = 1; i &lt;= len; i++){ a[i] = a[i-1]; a[i].buc[s[i]-'a']++; } read(q); while(q--){ read(l, r); if(l == r || s[l] != s[r]) puts(&quot;Yes&quot;); else{ Node t = a[r] - a[l-1]; int cnt = 0; for(int i = 0; i &lt; 26; i++) cnt += (t.buc[i] &gt; 0); if(cnt &gt;= 3) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } } return 0;} E. Prefix EnlightenmentSolution题目条件中“任意三个集合交集为空”可翻译为“任意一盏灯最多属于两个集合”，考虑每一盏灯，我们可以得到集合与集合之间的关系： 若灯属于两个集合 $A$ 和 $B$ 若灯为开，则 $A,B$ 必须同时取或者同时不取 若灯为关，则 $A,B$ 取且仅取其一 若灯属于一个集合 $A$ 若灯为开，则 $A$ 必不能取 若灯为关，则 $A$ 必须取 若灯不属于任何集合，直接跳过不作处理 只考虑灯属于两个集合的话，这就是一个种类并查集，拆点即可（$A$ 拆为 $A$ 和 $A+k$）。 然而对于 $A$ 必/必不取这种约束条件不好维护，一个巧妙的方法是：开一个大小记为 $+\\infty$ 的点，那么对于 $A$ 必取的情况，把 $A+k$ 与之合并，则更新答案时一定是用 $A$ 更新的，达到了必取的效果；必不取同理。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 300005;const int INF = 1e9;int n, k, c;vector&lt;int&gt; vec[N];char s[N];int fa[N&lt;&lt;1], sz[N&lt;&lt;1];inline int lowbit(int x){ return x &amp; -x; }inline int findfa(int x){ return x == fa[x] ? x : fa[x] = findfa(fa[x]); }inline void unionn(int x, int y){ x = findfa(x), y = findfa(y); fa[y] = x; if(sz[x] &lt; INF) sz[x] += sz[y];}int main(){ read(n, k); scanf(&quot;%s&quot;, s+1); for(int i = 1; i &lt;= k; i++){ read(c); for(int j = 1; j &lt;= c; j++){ int x; read(x); vec[x].push_back(i); } } for(int i = 1; i &lt;= k * 2; i++) fa[i] = i, sz[i] = (i &lt;= k); fa[k*2+1] = k*2+1, sz[k*2+1] = INF; int ans = 0; for(int i = 1; i &lt;= n; i++){ if(vec[i].size() == 1){ if(findfa(k*2+1) != findfa(vec[i][0] + k * (s[i] == '0'))){ ans -= min(sz[findfa(vec[i][0])], sz[findfa(vec[i][0]+k)]); unionn(k*2+1, vec[i][0] + k * (s[i] == '0')); ans += min(sz[findfa(vec[i][0])], sz[findfa(vec[i][0]+k)]); } } else if(vec[i].size() == 2){ if(s[i] == '0'){ if(findfa(vec[i][0]) != findfa(vec[i][1]+k)){ ans -= min(sz[findfa(vec[i][0])], sz[findfa(vec[i][0]+k)]); ans -= min(sz[findfa(vec[i][1])], sz[findfa(vec[i][1]+k)]); unionn(vec[i][0], vec[i][1]+k); unionn(vec[i][0]+k, vec[i][1]); ans += min(sz[findfa(vec[i][0])], sz[findfa(vec[i][0]+k)]); } } else{ if(findfa(vec[i][0]) != findfa(vec[i][1])){ ans -= min(sz[findfa(vec[i][0])], sz[findfa(vec[i][0]+k)]); ans -= min(sz[findfa(vec[i][1])], sz[findfa(vec[i][1]+k)]); unionn(vec[i][0], vec[i][1]); unionn(vec[i][0]+k, vec[i][1]+k); ans += min(sz[findfa(vec[i][0])], sz[findfa(vec[i][0]+k)]); } } } printf(&quot;%d\\n&quot;, ans); } return 0;} F. Coffee Varieties (easy version)Solution【参考官方题解】把长为 $n$ 的序列 $a$ 分成长度为 $\\frac{k}{2}$ 的 $\\frac{2n}{k}$ 块，块与块之间两两组合拿去询问，回答 Y 的打上标记即可。 正确性证明：对于任意一个不是第一次出现的数 $a_j$，假设 $a_i=a_j,i&lt;j$，那么一定存在一次询问同时包含了 $a_i,a_j$，这个询问之后 $a_j$ 就被标记上了。 总询问次数 $=\\frac{\\frac{2n}{k}\\cdot\\left(\\frac{2n}{k}-1\\right)}{2}\\cdot k=\\frac{2n^2}{k}-n$. Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1100;int n, k;inline bool ask(int c){ printf(&quot;? %d\\n&quot;, c); fflush(stdout); char ch[2]; scanf(&quot;%s&quot;, ch); return ch[0] == 'N';}inline void reset(){ puts(&quot;R&quot;); fflush(stdout); }bool isFirst[N];int main(){ memset(isFirst, 1, sizeof isFirst); read(n, k); for(int len = 2; len &lt;= 2 * n / k; len++){ for(int i = 1; i &lt;= 2 * n / k; i++){ int j = i + len - 1; if(j &gt; 2 * n / k) break; for(int o = (i - 1) * k / 2 + 1; o &lt;= i * k / 2; o++) if(ask(o) == false) isFirst[o] = false; for(int o = (j - 1) * k / 2 + 1; o &lt;= j * k / 2; o++) if(ask(o) == false) isFirst[o] = false; reset(); } } int cnt = 0; for(int i = 1; i &lt;= n; i++) cnt += isFirst[i]; printf(&quot;! %d\\n&quot;, cnt); fflush(stdout); return 0;} Div 1. D. Coffee Varieties (hard version)Solution【参考官方题解】沿袭 easy version 的思路，方便起见，记块数为 $m=\\frac{2n}{k}$，如果把每一个块看成一个点，两两组合看成连边，则可以构建出一个 $K_m$ 完全图。在 easy version 中，我们事实上是把每条边拿出来进行询问，一共 $C_m^2$ 条边，每条边问 $k$ 次，故一共询问了 $k\\cdot C_m^2$ 次。 但是如下图所示，当我们询问了边 $1$ 之后（即询问了块 $a,b$ 之后），如果我们紧接着询问边 $2$，那么块 $b$ 仍然存在于队列之中，没有必要将其再加进去，这就减少了询问次数。更一般地，只要我们询问的边依次形成一条简单路径，那么我们沿着这条路径询问即可。设路径长度为 $l$，那么上面有 $l+1$ 个点，每个点也即每个块有 $\\frac{k}{2}$ 个元素，所以一条路径询问的次数就是 $(l+1)\\cdot \\frac{k}{2}$。我们的目标是找出多条边不同的简单路径，使之覆盖完全图 $K_m$ 的所有边。此时，设共有 $p$ 条路径，则询问次数为 $\\sum\\left((l_i+1)\\cdot\\frac{k}{2}\\right)=(C_m^2+p)\\cdot\\frac{k}{2}$. 找路径的方法有很多，我采用的是枚举出发点，再枚举边的长度，画一条每条边长度相同的路径直至末尾。可以算得，这样 $p=\\frac{m^2}{4}$，总询问次数为 $\\frac{3n^2}{2k}-\\frac{n}{2}$. 官方题解指出：实验中随机化 dfs 表现很好，大概是 $1.2\\frac{n^2}{k}$ 次询问；还给出了一种 $\\frac{n^2}{k}$ 次询问的方法。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1100;int n, k;inline bool ask(int c){ printf(&quot;? %d\\n&quot;, c); fflush(stdout); char ch[2]; scanf(&quot;%s&quot;, ch); return ch[0] == 'N';}inline void reset(){ puts(&quot;R&quot;); fflush(stdout); }bool tag[N];int main(){ memset(tag, 1, sizeof tag); read(n, k); int m = 2 * n / k; for(int i = 1; i &lt;= m / 2; i++){ for(int gap = i; gap &lt;= m - i; gap++){ reset(); int now = i; while(now &lt;= m){ for(int j = (now - 1) * k / 2 + 1; j &lt;= now * k / 2; j++) if(ask(j) == false) tag[j] = false; now += gap; } } } int cnt = 0; for(int i = 1; i &lt;= n; i++) cnt += tag[i]; printf(&quot;! %d\\n&quot;, cnt); fflush(stdout); return 0;}","link":"/blog-xcpc/2020/02/03/Codeforces-Round-616-Div-2/"},{"title":"Codeforces Round #618 (Div.2)","text":"比赛链接 / 官方题解链接 A. Non-zeroSolution是 $0$ 的数必须加 $1$，否则乘积为 $0$；此后若和非零，则不用操作，否则操作数加一（任取一个非零数加一，由于和为零，能够保证存在至少一个正数，对其操作后乘积仍然非零） Code&gt;folded123456789101112131415161718192021222324#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}int T, n, a;int main(){ read(T); while(T--){ read(n); int ans = 0, sum = 0; for(int i = 1; i &lt;= n; i++){ read(a); if(a == 0) a++, ans++; sum += a; } printf(&quot;%d\\n&quot;, ans + (sum == 0)); } return 0;} B. Assigning to ClassesSolution容易知道，尽量平均分最好，也就是说，若 $n$ 为奇数，就分成 $n:n$ 的两份；若 $n$ 为偶数，就分成 $n-1:n+1$ 的两份。先排序，则无论是哪种情形，两中位数都是 $a_n$ 和 $a_{n+1}$. Code&gt;folded1234567891011121314151617181920212223242526#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;int T, n;LL a[N];int main(){ read(T); while(T--){ read(n); for(int i = 1; i &lt;= 2 * n; i++) read(a[i]); sort(a+1, a+2*n+1); printf(&quot;%lld\\n&quot;, a[n+1] - a[n]); } return 0;} C. Anu Has a FunctionSolution首先需要发现：$f(a,b)=(a|b)-b=a&amp;(\\sim b)$，故 $f(f(\\cdots f(f(a_1,a_2),a_3),\\cdots a_{n-1})a_n)=a_1&amp;(\\sim a_2)&amp;(\\sim a_3)&amp;\\cdots&amp;(\\sim a_n)$. 其值与谁放在开头作为 $a_1$ 有关，剩余元素随意放即可。于是枚举放在开头的元素，计算它 $AND$ 上其他元素取反后的$AND$，后者可以通过预处理前后缀求得。 Code&gt;folded1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int n, mark;LL a[N], pre[N], sub[N], maxx = -1;int main(){ read(n); pre[0] = sub[n+1] = (1ll &lt;&lt; 33) - 1; for(int i = 1; i &lt;= n; i++){ read(a[i]); pre[i] = pre[i-1] &amp; (~a[i]); } for(int i = n; i &gt;= 1; i--){ sub[i] = sub[i+1] &amp; (~a[i]); LL res = a[i] &amp; sub[i+1] &amp; pre[i-1]; if(maxx &lt; res){ mark = i; maxx = res; } } printf(&quot;%lld &quot;, a[mark]); for(int i = 1; i &lt;= n; i++){ if(i == mark) continue; printf(&quot;%lld &quot;, a[i]); } putchar(10); return 0;} D. AerodynamicSolution手玩一些多边形后可以发现，$P$ 对边平行且相等（即中心对称）即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int n;struct Point{ LL x, y;}p[N];typedef Point Vector;Point operator - (Point A, Point B){ return (Point){A.x - B.x, A.y - B.y}; }LL operator ^ (Vector A, Vector B){ return A.x * B.y - A.y * B.x; } // cross productLL Length2(Vector A){ return (A.x * A.x + A.y * A.y); }int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(p[i].x, p[i].y); if(n &amp; 1){ puts(&quot;NO&quot;); return 0; } else{ for(int i = 1; i &lt;= n / 2; i++){ int j = i + n / 2; int nxti = i + 1, nxtj = j + 1; if(nxtj == n + 1) nxtj = 1; Vector v1 = p[nxti] - p[i], v2 = p[nxtj] - p[j]; if((v1 ^ v2) != 0 || Length2(v1) != Length2(v2)){ puts(&quot;NO&quot;); exit(0); } } } puts(&quot;YES&quot;); return 0;} E. Water BalanceSolution【参考官方题解】对于前缀和序列 ${sum_i}$，题设操作对应为：选择一段区间 $[l,r]$，并将其中的数 $sum_i(l\\leq i\\leq r)$ 更改为$$sum_{l-1}+\\frac{sum_r-sum_{l-1}}{r-l+1}\\cdot(i-l+1)$$这个式子实际上是 $(l-1,sum_{l-1}),(r,sum_r)$ 两点确定的直线上横坐标为 $i$ 的点的纵坐标。把所有点 $(i,sum_i)$ 画在坐标系中，发现求得下凸包即可。 Code&gt;folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1000005;int n, ch[N];LL a[N];double s[N];void getConvexHull(){ for(int i = 0; i &lt;= n; i++){ while(ch[0] &gt; 1 &amp;&amp; (double)(a[ch[ch[0]]] - a[ch[ch[0]-1]]) / (ch[ch[0]] - ch[ch[0]-1]) &gt; (double)(a[i] - a[ch[ch[0]]]) / (i - ch[ch[0]])) ch[0]--; ch[++ch[0]] = i; }}int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]), a[i] += a[i-1]; getConvexHull(); int pt = 2; for(int i = 1; i &lt;= n; i++){ while(i &gt; ch[pt]) pt++; s[i] = (double)(a[ch[pt]] - a[ch[pt-1]]) / (ch[pt] - ch[pt-1]) * (i - ch[pt-1]) + a[ch[pt-1]]; } for(int i = 1; i &lt;= n; i++) printf(&quot;%.9f\\n&quot;, s[i] - s[i-1]); return 0;}","link":"/blog-xcpc/2020/02/10/Codeforces-Round-618-Div-2/"},{"title":"Codeforces Round #620 (Div.2)","text":"比赛链接 / 官方题解链接 A. Two RabbitsSolution$x+at=y-bt\\Rightarrow (a+b)t=y-x$. Code&gt;folded1234567891011121314151617181920212223242526#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T;LL x, y, a, b;int main(){ read(T); while(T--){ read(x, y, a, b); if((y - x) % (a + b) == 0){ printf(&quot;%lld\\n&quot;, (y-x) / (a+b)); } else puts(&quot;-1&quot;); } return 0;} B. Longest PalindromeSolution设答案为 ans，则 ans 不断加上具有逆序串的字符串，输出 ans，如果有自身回文的串就任输出一个，然后 ans 翻转再输出即可。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 105;const int LEN = 55;int n, m, mark;char s[N][LEN];bool vis[N];string ans = &quot;&quot;;bool checkPalin(int a, int b){ for(int i = 1; i &lt;= m; i++) if(s[a][i] != s[b][m-i+1]) return false; return true;}int main(){ read(n, m); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%s&quot;, s[i]+1); if(!mark &amp;&amp; checkPalin(i, i)){ vis[i] = 1; mark = i; } } for(int i = 1; i &lt;= n; i++){ if(vis[i]) continue; for(int j = 1; j &lt; i; j++){ if(vis[j]) continue; if(checkPalin(i, j)){ vis[i] = vis[j] = 1; ans = ans + (s[i]+1); } } } if(mark) printf(&quot;%d\\n&quot;, 2 * (int)ans.size() + m); else printf(&quot;%d\\n&quot;, 2 * (int)ans.size()); cout &lt;&lt; ans; if(mark) printf(&quot;%s&quot;, s[mark]+1); reverse(ans.begin(), ans.end()); cout &lt;&lt; ans &lt;&lt; endl; return 0;} C. Air ConditionerSolution根据前一个人能调控到的温度范围，可以推知下一个人到来时能调控到的温度范围，与这个人的舒适温度范围取交，如此递推下去即可。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 105;int T, n;LL m, t[N], l[N], h[N];int main(){ read(T); while(T--){ read(n, m); for(int i = 1; i &lt;= n; i++) read(t[i], l[i], h[i]); LL low = m, high = m; bool b = true; for(int i = 1; i &lt;= n; i++){ high += t[i] - t[i-1]; low -= t[i] - t[i-1]; high = min(high, h[i]); low = max(low, l[i]); if(low &gt; high) { puts(&quot;NO&quot;); b = false; break; } } if(b) puts(&quot;YES&quot;); } return 0;} D. Shortest and Longest LISSolution最长 $LIS$ 的构造：只要上升，就上升到比当前最大值大 $1$ 处。 最短 $LIS$ 的构造：若某点后是一小段上升区间，那么保证上升幅度不要超过该点的前一个点。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;int T, n, a[N], dp[N];char s[N];inline void getMax(){ memset(a, 0, sizeof a); int curmax = 0, curmin = 0; a[1] = 0; for(int i = 1; i &lt; n; i++){ if(s[i] == '&lt;') a[i+1] = ++curmax; else a[i+1] = --curmin; } for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i] - curmin + 1);}inline void getMin(){ memset(dp, 0, sizeof dp); memset(a, 0, sizeof a); a[0] = 0; s[0] = '&gt;'; for(int i = n-1; i &gt;= 0; i--){ if(s[i] == '&lt;') dp[i] = dp[i+1] + 1; else dp[i] = 0; } int curmin = 0; for(int i = 0; i &lt; n; i++){ a[i+1] = curmin - dp[i+1] - 1; curmin = min(curmin, a[i+1]); for(int j = 1; j &lt;= dp[i+1]; j++) a[i+j+1] = a[i+j] + 1; i += dp[i+1]; } int mn = 1e9; for(int i = 1; i &lt;= n; i++) mn = min(mn, a[i]); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i] - mn + 1);}int main(){ read(T); while(T--){ read(n); scanf(&quot;%s&quot;, s+1); getMin(); putchar(10); getMax(); putchar(10); } return 0;} E. 1-Trees and QueriesSolution从 $a$ 到 $b$ 的路径可分为两种：经过了 $(x,y)$ 和未经过 $(x,y)$ 的： 对于未经过 $(x,y)$ 的路径，$a,b$ 间的最短路径即原树上两点之间的简单路径，若该路径长度 $dis(a,b)$ 小于等于 $k$ 且奇偶性相同，则可达； 对于经过了 $(x,y)$ 的路径，有两种可能： $a\\rightarrow x\\rightarrow y\\rightarrow b$，长 $dis(a,x)+1+dis(y,b)$. $a\\rightarrow y\\rightarrow x\\rightarrow b$，长 $dis(a,y)+1+dis(x,b)$. 若其一长度小于等于 $k$ 且奇偶性相同，则可达。 两点之间的距离 $dis(a,b)$ 可由倍增法求 $lca$ 得到：$dis(a,b)=dep[a]+dep[b]-2*dep[lca(a,b)]$. Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int n, u, v, q, qx, qy, qa, qb, qk;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N][25], dep[N];void dfs(int x, int f, int depth){ dep[x] = depth; fa[x][0] = f; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth+1); }}void init(){ for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for(int i = 1; i &lt;= n; i++) if(fa[i][j-1]) fa[i][j] = fa[fa[i][j-1]][j-1];}int lca(int x, int y){ if(dep[x] &lt; dep[y]) swap(x, y); for(int i = 20; i &gt;= 0; i--) if(dep[x] - (1 &lt;&lt; i) &gt;= dep[y]) x = fa[x][i]; if(x == y) return x; for(int i = 20; i &gt;= 0; i--){ if(fa[x][i] &amp;&amp; fa[x][i] != fa[y][i]){ x = fa[x][i]; y = fa[y][i]; } } return fa[x][0];}inline int dis(int a, int b){ return dep[a] + dep[b] - 2 * dep[lca(a, b)]; }int main(){ read(n); for(int i = 1; i &lt; n; i++){ read(u, v); addEdge(u, v), addEdge(v, u); } dfs(1, 0, 1); init(); read(q); while(q--){ read(qx, qy, qa, qb, qk); int d = dis(qa, qb); if(d &lt;= qk &amp;&amp; (qk - d) % 2 == 0){ puts(&quot;YES&quot;); continue; } d = dis(qa, qx) + 1 + dis(qy, qb); if(d &lt;= qk &amp;&amp; (qk - d) % 2 == 0){ puts(&quot;YES&quot;); continue; } d = dis(qa, qy) + 1 + dis(qx, qb); if(d &lt;= qk &amp;&amp; (qk - d) % 2 == 0){ puts(&quot;YES&quot;); continue; } puts(&quot;NO&quot;); } return 0;} F1. Animal Observation (easy version)Solution【参考官方题解】为方便阐述，设 $s[i][j]=\\sum\\limits_{i=1}^j a[i][j]$，即 $a[i][j]$ 的前缀和。又令 $Sum(i,j)$ 为第 $i$ 天在 $j\\sim j+k-1$ 区域内放置摄像机能摄到的动物数量（利用 $s$ 数组 $O(1)$ 可求） 考虑 $dp$： $dp$ 状态：$dp[i][j]$ 表示第 $i$ 天在 $j\\sim j+k-1$ 的区域放置摄像机后，前 $i$ 天一共能摄到的最多动物数量。 转移方程：分第 $i$ 天与第 $i-1$ 天无重叠和有重叠转移： 无重叠之前一天在第 $i$ 天之前：$dp[i][j]=\\max\\limits_{l=1}^{j-k}dp[i-1][l]+Sum(i,j)$. 其中，$\\max\\limits_{l=1}^{j-k}dp[i-1][l]$ 可预处理前缀最大值 $O(1)$ 调用。 无重叠之前一天在第 $i$ 天之后：$dp[i][j]=\\max\\limits_{l=j+k}^{m}dp[i-1][l]+Sum(i,j)$. 其中，$\\max\\limits_{l=j+k}^{m}dp[i-1][l]$ 可预处理后缀最大值 $O(1)$ 调用。 两天有重叠部分：由于 $k$ 比较小，循环删去重复部分即可。 转移顺序：由转移方程可知，依次循环即可。 边界条件：$dp[i][j]=0$. 复杂度 $O(nmk)$ Code&gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 55;const int M = 20005;int n, m, k;LL a[N][M], s[N][M], dp[N][M], pre[N][M], suf[N][M];inline LL Sum(int i, int j){ return s[i][j+k-1] - s[i][j-1] + s[i+1][j+k-1] - s[i+1][j-1]; }int main(){ read(n, m, k); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ read(a[i][j]); s[i][j] = s[i][j-1] + a[i][j]; } } for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m-k+1; j++){ if(j - k &gt; 0) dp[i][j] = max(dp[i][j], pre[i-1][j-k] + Sum(i, j)); if(j + k &lt;= m) dp[i][j] = max(dp[i][j], suf[i-1][j+k] + Sum(i, j)); for(int l = j-k+1; l &lt;= j+k-1; l++){ LL res = dp[i-1][l] + Sum(i, j); if(i &gt; 1){ if(l &lt; j) res -= s[i][l+k-1] - s[i][j-1]; else res -= s[i][j+k-1] - s[i][l-1]; } dp[i][j] = max(dp[i][j], res); } pre[i][j] = max(pre[i][j-1], dp[i][j]); } for(int j = m-k+1; j &gt;= 1; j--) suf[i][j] = max(suf[i][j+1], dp[i][j]); } LL ans = -1; for(int j = 1; j &lt;= m; j++) ans = max(ans, dp[n][j]); printf(&quot;%lld\\n&quot;, ans); return 0;} F2. Animal Observation (hard version)Solution【参考官方题解】需要把 easy version 中转移方程用数据结构维护。 三类转移方程其实可归为一个问题：求 $dp[i-1]$ 中减去重叠部分（可能为 $0$）后的最大值。对于每个 $i$，建立一颗以 $dp[i-1]$ 为基础的线段树，显然重叠部分不能循环 $j$，然后一个一个的暴力减，但我们可以用类似滑动窗口的做法做——首先减去 $dp[i][1]$ 的重叠部分，这 $k$ 个直接一个一个减就行了；然后假设我们已经减去了 $dp[i][j-1]$ 的重叠部分，在减 $dp[i][j]$ 的重叠部分时，窗口往右滑，只需要把不再覆盖 $a[i][j-1]$ 的区间 $[\\max(1, j-k), j-1]$ 加回 $a[i][j-1]$，把新的覆盖了 $a[i][j+k-1]$ 的区间 $[j, \\min(j+k-1, m-k+1)]$ 减去 $a[i][j+k-1]$ 即可。 复杂度 $O(nm\\lg m)$ Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 55;const int M = 20005;int n, m, k;LL a[N][M], s[N][M], dp[N][M];inline LL Sum(int i, int j){ return s[i][j+k-1] - s[i][j-1] + s[i+1][j+k-1] - s[i+1][j-1]; }struct segTree{ int l, r; LL mx, lazy;}tr[M&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ tr[id].mx = max(tr[lid].mx, tr[rid].mx);}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazy){ tr[lid].lazy += tr[id].lazy; tr[lid].mx += tr[id].lazy; tr[rid].lazy += tr[id].lazy; tr[rid].mx += tr[id].lazy; tr[id].lazy = 0; }}void build(int id, int l, int r, LL v[]){ tr[id].l = l, tr[id].r = r; tr[id].mx = tr[id].lazy = 0; if(tr[id].l == tr[id].r){ tr[id].mx = v[l]; tr[id].lazy = 0; return; } build(lid, l, mid, v); build(rid, mid+1, r, v); pushup(id);}void add(int id, int l, int r, LL v){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazy += v; tr[id].mx += v; return; } if(r &lt;= mid) add(lid, l, r, v); else if(l &gt; mid) add(rid, l, r, v); else add(lid, l, mid, v), add(rid, mid+1, r, v); pushup(id);}LL queryMax(int id, int l, int r){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].mx; if(r &lt;= mid) return queryMax(lid, l, r); else if(l &gt; mid) return queryMax(rid, l, r); else return max(queryMax(lid, l, mid), queryMax(rid, mid+1, r));}int main(){ read(n, m, k); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ read(a[i][j]); s[i][j] = s[i][j-1] + a[i][j]; } } for(int j = 1; j &lt;= m-k+1; j++) dp[1][j] = Sum(1, j); for(int i = 2; i &lt;= n; i++){ build(1, 1, m, dp[i-1]); for(int j = 1; j &lt;= k; j++) add(1, j, j, -(s[i][k] - s[i][j-1])); dp[i][1] = queryMax(1, 1, m-k+1) + Sum(i, 1); for(int j = 2; j &lt;= m-k+1; j++){ add(1, max(1, j-k), j-1, a[i][j-1]); add(1, j, min(j+k-1, m-k+1), -a[i][j+k-1]); dp[i][j] = queryMax(1, 1, m-k+1) + Sum(i, j); } } LL ans = -1; for(int j = 1; j &lt;= m; j++) ans = max(ans, dp[n][j]); printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/02/15/Codeforces-Round-620-Div-2/"},{"title":"Codeforces Round #617 (Div.3)","text":"比赛链接 / 官方题解链接 A. Array with Odd Sum略 B. Food Buying略 C. Yet Another Walking RobotSolution用 STL 的 map 记录上一次到达该位置的时间即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define mp(x,y) make_pair(x,y)const int N = 200005;int T, n, ans = 1e9, ansl, ansr;char s[N];int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s+1); map&lt;pii, int&gt; m; pii now = mp(0,0); m[now] = 1; ansl = ansr = 0, ans = 1e9; for(int i = 1; i &lt;= n; i++){ if(s[i] == 'U') now.second++; if(s[i] == 'D') now.second--; if(s[i] == 'L') now.first--; if(s[i] == 'R') now.first++; if(m[now] &gt; 0) if(i + 1 - m[now] &lt; ans) ans = i + 1 - m[now], ansl = m[now], ansr = i; m[now] = i + 1; } if(ansl == ansr &amp;&amp; ansl == 0) puts(&quot;-1&quot;); else printf(&quot;%d %d\\n&quot;, ansl, ansr); } return 0;} D. Fight with MonstersSolution对于每个怪物都能 $O(1)$ 地获知要得分需要用多少次技能，根据技能消耗数从小到大依次取即可。 Code>folded12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int N = 200005;int n; LL a, b, k, h, ans, kk;priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; q;int main(){ scanf(&quot;%d%lld%lld%lld&quot;, &amp;n, &amp;a, &amp;b, &amp;k); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%lld&quot;, &amp;h); if(h % (a + b) &lt;= a &amp;&amp; h % (a + b) != 0) ans++; else{ LL m = h % (a + b); if(m == 0) m = a + b; LL tim = m / a + 1; if(m % a == 0) tim--; q.push(tim - 1); } } while(!q.empty()){ if(kk + q.top() &lt;= k){ kk += q.top(); q.pop(); ans++; } else break; } printf(&quot;%lld\\n&quot;, ans); return 0;} E1. String Coloring (easy version)Solution #1首先有结论：只需所有逆序对的颜色不同即可，因为易知存在一种排序方式只交换逆序对。 于是我们可以给所有逆序对两两连边建图，然后二染色即可。 复杂度 $O(n^2)$ Solution #2进一步思考，每个元素的颜色只需与在它之前出现的且大于它的所有元素的颜色不同即可。所以我们可以从颜色的角度出发，记录每个颜色染到的元素最大值，那么循环每个元素，若能染色为0，染为0；否则若能染色为1，染为1；否则无解。 复杂度 $O(n)$ Code — $O(n^2)$>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 205;int n;char s[N];bool con[N];struct Edge{ int nxt, to;}edge[N*N];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}bool able;int col[N];void dfs(int x, int c){ if(!able) return; if(col[x] != -1){ if(col[x] != c){ col[x] = -1; able = false; } return; } col[x] = c; for(int i = head[x]; i; i = edge[i].nxt) dfs(edge[i].to, c ^ 1);}int main(){ scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s+1); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt; i; j++){ if(s[j] &gt; s[i]){ addEdge(i, j); addEdge(j, i); con[j] = con[i] = true; } } } able = true; memset(col, -1, sizeof col); for(int i = 1; i &lt;= n; i++){ if(col[i] == -1){ if(con[i]) dfs(i, 0); else col[i] = 0; } } if(!able) puts(&quot;NO&quot;); else{ puts(&quot;YES&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d&quot;, col[i]); puts(&quot;&quot;); } return 0;} Code — $O(n)$>folded123456789101112131415161718192021#include&lt;cstdio&gt;using namespace std;const int N = 205;int n, col[N];char s[N], maxch[N];int main(){ scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s+1); for(int i = 1; i &lt;= n; i++){ if(maxch[0] &lt;= s[i]) maxch[col[i] = 0] = s[i]; else if(maxch[1] &lt;= s[i]) maxch[col[i] = 1] = s[i]; else return puts(&quot;NO&quot;), 0; } puts(&quot;YES&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d&quot;, col[i]); return 0;} E2. String Coloring (hard version)Solution沿袭 E1 的 Solution #2 的思路，只不过 E2 的颜色数增加了而已，于是我们可以以颜色为下标建立线段树，像值域线段树那样查找最小的值不比当前元素大的颜色。 复杂度 $O(n\\lg n)$ Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 200005;const int INF = 1e9;int n;char s[N];struct segTree{ int l, r, mn;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].mn = min(tr[lid].mn, tr[rid].mn);}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].mn = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void modify(int id, int x, int val){ if(tr[id].l == tr[id].r){ tr[id].mn = val; return; } if(x &lt;= mid) modify(lid, x, val); else modify(rid, x, val); pushup(id);}int query(int id, int val){ if(tr[id].l == tr[id].r) return tr[id].l; if(tr[lid].mn &lt;= val) return query(lid, val); else return query(rid, val);}int col[N], cnt;bool appeared[N];int main(){ scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s+1); build(1, 1, n); for(int i = 1; i &lt;= n; i++){ int q = query(1, s[i]-'a'+1); modify(1, q, s[i]-'a'+1); col[i] = q; if(!appeared[q]) cnt++, appeared[q] = true; } printf(&quot;%d\\n&quot;, cnt); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, col[i]); return 0;} F. Berland BeautySolution根据 $g_i$ 的值从大到小排序，依次拿到路径上赋值，一条边的值为当前值和 $g_i$ 的最大值，赋值结束后还没值的边赋为1e6，随后把所有条件验证一遍，验证不过输出 -1，验证通过输出答案。 复杂度 $O(n^2)$ Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 5005;const int INF = 1e9;int n, u[N], v[N], m, val[N][N];vector&lt;int&gt; edge[N];struct Node{ int u, v, g; bool operator &lt; (const Node &amp;A) const{ return g &gt; A.g; }}q[N];vector&lt;int&gt; vec;bool found, vis[N], check;void dfs(int x, int y, int minval, int kind){ if(found) return; vis[x] = true; vec.push_back(x); if(x == y){ int minn = INF; for(int i = 1; i &lt; vec.size(); i++){ if(kind == 0) val[vec[i]][vec[i-1]] = val[vec[i-1]][vec[i]] = max(val[vec[i-1]][vec[i]], minval); else minn = min(minn, val[vec[i]][vec[i-1]]); } found = true; if(kind == 1 &amp;&amp; minn != minval){ puts(&quot;-1&quot;); exit(0); } return; } for(int i = 0; i &lt; edge[x].size(); i++) if(!vis[edge[x][i]]) dfs(edge[x][i], y, minval, kind); vec.pop_back(); vis[x] = false;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++){ scanf(&quot;%d%d&quot;, &amp;u[i], &amp;v[i]); edge[u[i]].push_back(v[i]); edge[v[i]].push_back(u[i]); } scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d%d&quot;, &amp;q[i].u, &amp;q[i].v, &amp;q[i].g); if(q[i].u &gt; q[i].v) swap(q[i].u, q[i].v); } sort(q+1, q+m+1); for(int i = 1; i &lt;= m; i++){ vec.clear(); found = false; memset(vis, 0, sizeof vis); dfs(q[i].u, q[i].v, q[i].g, 0); } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(val[i][j] == 0) val[i][j] = 1e6; for(int i = 1; i &lt;= m; i++){ vec.clear(); found = false; memset(vis, 0, sizeof vis); dfs(q[i].u, q[i].v, q[i].g, 1); } for(int i = 1; i &lt; n; i++) printf(&quot;%d &quot;, val[u[i]][v[i]] &gt; 1000000 ? 1000000 : val[u[i]][v[i]]); return 0;}","link":"/blog-xcpc/2020/02/05/Codeforces-Round-617-Div-3/"},{"title":"Codeforces Round #619 (Div.2)","text":"比赛链接 / 官方题解链接 A. Three StringsSolution$a_i,b_i$ 相同则 $c_i$ 必须也相同，$a_i,b_i$ 不同则 $c_i$ 必须与其中一个相同。 Code&gt;folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 205;int T;char a[N], b[N], c[N];int main(){ read(T); while(T--){ scanf(&quot;%s&quot;, a+1); scanf(&quot;%s&quot;, b+1); scanf(&quot;%s&quot;, c+1); int n = strlen(a+1); bool ok = true; for(int i = 1; i &lt;= n; i++){ if(a[i] == b[i]){ if(c[i] != a[i]){ ok = false; break; } } else{ if(!(c[i] == a[i] || c[i] == b[i])){ ok = false; break; } } } if(!ok) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } return 0;} B. Motarack’s BirthdaySolution二分最小差值 $m$，check 时，对于每一个 $?$，设其旁边的数为 $x$，则 $?$ 的取值范围为 $[x-m,x+m]$，判断所有这样的区间交集是否为空。 Better Solution可以 $O(n)$ 的…… $k$ 取 $\\frac{min+max}{2}$ 就好…… Code$O(n\\lg n)$: &gt;folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int T, n;LL a[N], k;bool check(LL m){ LL l = -1e14, r = 1e14; for(int i = 1; i &lt;= n; i++){ if(a[i] == -1){ if(i != 1 &amp;&amp; a[i-1] != -1) l = max(l, a[i-1] - m), r = min(r, a[i-1] + m); if(i != n &amp;&amp; a[i+1] != -1) l = max(l, a[i+1] - m), r = min(r, a[i+1] + m); } } if(l &lt;= r) k = l; return l &lt;= r;}int main(){ read(T); while(T--){ read(n); LL gap = -1e16; for(int i = 1; i &lt;= n; i++){ read(a[i]); if(i != 1 &amp;&amp; a[i] != -1 &amp;&amp; a[i-1] != -1) gap = max(gap, max(a[i] - a[i-1], a[i-1] - a[i])); } LL l = 0, r = 1e9; while(l &lt; r){ LL mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; } if(k &lt; 0 || k &gt; 1e9) k = 1; printf(&quot;%lld %lld\\n&quot;, max(gap, l), k); } return 0;} C. Ayoub’s functionSolution直觉告诉我们，把 $1$ 尽可能均分是最优的，事实上可以严谨证明。 证：设序列为 $\\underbrace{00\\cdots0}{a_1个0}1\\underbrace{00\\cdots0}{a_2个0}1\\cdots1\\underbrace{00\\cdots0}{a_l个0}$，且 $\\sum\\limits{i=1}^l a_i=n-m$. 要求的 $f(s)$ 可以看作所有区间个数减去不含 $1$ 的区间个数，即$$f(s)=\\frac{n(n+1)}{2}-\\sum\\limits_{i=1}^{l}\\frac{a_i(a_i+1)}{2}$$恒等变形：$$\\begin{align}f(s)&amp;=\\frac{n(n+1)}{2}-\\sum\\limits_{i=1}^{l}\\frac{a_i(a_i+1)}{2}\\&amp;=\\frac{n(n+1)}{2}-\\frac{1}{2}\\left(\\sum\\limits_{i=1}^la_i^2+\\sum\\limits_{i=1}^la_i\\right)\\&amp;=\\frac{n^2+m}{2}-\\frac{1}{2}\\sum\\limits_{i=1}^la_i^2\\end{align}$$根据均值不等式，上式后一项在 $a_1=a_2=\\cdots=a_l$ 时最小，$f(s)$ 最大，证毕. Code>folded1234567891011121314151617181920212223242526272829303132333435#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int T;LL n, m, ans;int main(){ read(T); while(T--){ read(n, m); ans = n * (n + 1) / 2; LL C = n - m; LL bs = C / (m + 1), res = C - bs * (m + 1); ans -= (m + 1 - res) * bs * (bs + 1) / 2 + res * (bs + 1) * (bs + 2) / 2; printf(&quot;%lld\\n&quot;, ans); } return 0;} D. Time to RunSolution可以找到一条路径经过所有 $4nm-2n-2m$ 条边，我找的是形如下图的路径： 然后就是模拟了…… Code【以下代码参考了 MiFaFaOvO 的代码，因为我的模拟实在是太丑了……】 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, string&gt; pis;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)int n, m, k;vector&lt; pis &gt; steps, ans;int main(){ read(n, m, k); if(4 * n * m - 2 * n - 2 * m &lt; k) return puts(&quot;NO&quot;), 0; puts(&quot;YES&quot;); if(m == 1){ if(k &lt;= m - 1) return printf(&quot;1\\n%d D\\n&quot;, k), 0; return printf(&quot;2\\n%d D\\n%d U\\n&quot;, n - 1, k - n + 1), 0; } steps.pb( mp(m-1, &quot;R&quot;) ); steps.pb( mp(m-1, &quot;L&quot;) ); for(int i = 1; i &lt; n; i++){ steps.pb( mp(m-1, &quot;DRU&quot;) ); steps.pb( mp(1, &quot;D&quot;) ); steps.pb( mp(m-1, &quot;L&quot;) ); } steps.pb( mp(n-1, &quot;U&quot;) ); int size = steps.size(), x; for(x = 0; x &lt; size; x++){ if(k &gt;= steps[x].first * (steps[x].second.size())){ k -= steps[x].first * (steps[x].second.size()); if(steps[x].first) ans.pb(steps[x]); } else{ int len = steps[x].second.size(); if(k / len) ans.pb( mp(k / len, steps[x].second) ); if(k % len) ans.pb( mp(1, steps[x].second.substr(0, k % len)) ); k = 0; } } printf(&quot;%d\\n&quot;, (int)ans.size()); for(int i = 0; i &lt; ans.size(); i++) printf(&quot;%d %s\\n&quot;, ans[i].first, ans[i].second.c_str()); return 0;} E. NanosoftSolution【参考官方题解】先用 $O(n^2)$ 的 $dp$ 得到每个方块作为红色右下角、黄色右上角、绿色左下角、蓝色左上角的最大色块边长，再用这些信息得到每个方块作为红色右下角能扩展出来的最大 $logo$ 大小。也即每个 $logo$ 都可以用红色右下角的方块的数值表示。 对于每次询问，二分答案（实际上二分的是 $logo$ 的半边长），check 时找到对应的区域（区域由可作为红色右下角的方块构成），判断区域内最大值是否大于等于二分的半边长。 区域内最大值用二维 ST 表维护。 复杂度 $O(n^2+n^2\\lg^2n+q\\lg n)$ Code&gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 505;int n, m, q, r1, c1, r2, c2;char g[N][N];int R[N][N], a[N][N];int Y[N][N], G[N][N], B[N][N];int lg[N], rmq[N][N][10][10];void pre(){ lg[1] = 0, lg[2] = 1; for(int i = 3; i &lt;= max(n, m); i++) lg[i] = lg[i/2] + 1;}void init(){ for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) rmq[i][j][0][0] = a[i][j]; for(int ki = 0; (1 &lt;&lt; ki) &lt;= n; ki++){ for(int kj = 0; (1 &lt;&lt; kj) &lt;= m; kj++){ if(!ki &amp;&amp; !kj) continue; for(int i = 1; i + (1 &lt;&lt; ki) - 1 &lt;= n; i++){ for(int j = 1; j + (1 &lt;&lt; kj) - 1 &lt;= m; j++){ if(!ki) rmq[i][j][ki][kj] = max(rmq[i][j][ki][kj-1], rmq[i][j+(1&lt;&lt;(kj-1))][ki][kj-1]); else rmq[i][j][ki][kj] = max(rmq[i][j][ki-1][kj], rmq[i+(1&lt;&lt;(ki-1))][j][ki-1][kj]); } } } }}int query(int u, int l, int d, int r){ int k1 = lg[d - u + 1], k2 = lg[r - l + 1]; return max(max(rmq[u][l][k1][k2], rmq[d-(1&lt;&lt;k1)+1][r-(1&lt;&lt;k2)+1][k1][k2]), max(rmq[d-(1&lt;&lt;k1)+1][l][k1][k2], rmq[u][r-(1&lt;&lt;k2)+1][k1][k2]));}bool check(int mid, int u, int l, int d, int r){ return query(u, l, d, r) &gt;= mid;}int main(){ read(n, m, q); for(int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, g[i] + 1); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(g[i][j] == 'R') R[i][j] = 1 + min(R[i-1][j-1], min(R[i-1][j], R[i][j-1])); for(int i = n; i &gt;= 1; i--) for(int j = 1; j &lt;= m; j++) if(g[i][j] == 'Y') Y[i][j] = 1 + min(Y[i+1][j-1], min(Y[i][j-1], Y[i+1][j])); for(int i = 1; i &lt;= n; i++) for(int j = m; j &gt;= 1; j--) if(g[i][j] == 'G') G[i][j] = 1 + min(G[i-1][j+1], min(G[i][j+1], G[i-1][j])); for(int i = n; i &gt;= 1; i--) for(int j = m; j &gt;= 1; j--) if(g[i][j] == 'B') B[i][j] = 1 + min(B[i+1][j+1], min(B[i][j+1], B[i+1][j])); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(g[i][j] == 'R' &amp;&amp; g[i+1][j] == 'Y' &amp;&amp; g[i][j+1] == 'G' &amp;&amp; g[i+1][j+1] == 'B') a[i][j] = min(min(R[i][j], Y[i+1][j]), min(G[i][j+1], B[i+1][j+1])); pre(); init(); while(q--){ read(r1, c1, r2, c2); int l = 0, r = min((r2 - r1 + 1) / 2, (c2 - c1 + 1) / 2); while(l &lt; r){ int mid = (l + r + 1) &gt;&gt; 1; if(check(mid, r1 + mid - 1, c1 + mid - 1, r2 - mid, c2 - mid)) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, 4 * l * l); } return 0;} F. Super JaberSolution【参考官方题解】设 $d[color][i][j]$ 为从 $i$ 行 $j$ 列的格子到一个颜色为 $color$ 的格子的最小步数，于是枚举颜色，以所有该颜色的格子为起点，bfs 求之。求答案时，枚举中间的桥梁颜色 $c$，则 ans=min(ans, d[c][r1][c1] + d[c][r2][c2] + 1)（+1 是因为在桥梁颜色之中再走一步），再和曼哈顿距离取最小即可。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int N = 1005;const int INF = 1e9;int n, m, k, a[N][N], q, r1, r2, c1, c2;int d[45][N][N];int dx[] = {-1, 0, 1, 0};int dy[] = {0, 1, 0, -1};bool vis[45];vector&lt;pii&gt; v[45];inline void bfs(int col){ queue&lt; pii &gt; que; memset(vis, 0, sizeof vis); for(int i = 0; i &lt; v[col].size(); i++){ que.push(v[col][i]); d[col][v[col][i].first][v[col][i].second] = 0; } vis[col] = 1; while(!que.empty()){ int x = que.front().first, y = que.front().second; que.pop(); if(!vis[a[x][y]]){ vis[a[x][y]] = true; for(int i = 0; i &lt; v[a[x][y]].size(); i++){ int tx = v[a[x][y]][i].first, ty = v[a[x][y]][i].second; if(d[col][tx][ty] == -1){ d[col][tx][ty] = d[col][x][y] + 1; que.push( mp(tx, ty) ); } } } for(int i = 0; i &lt; 4; i++){ int tx = x + dx[i], ty = y + dy[i]; if(tx &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= m &amp;&amp; d[col][tx][ty] == -1){ d[col][tx][ty] = d[col][x][y] + 1; que.push( mp(tx, ty) ); } } }}int main(){ read(n, m, k); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++){ read(a[i][j]); v[a[i][j]].pb( mp(i, j) ); } memset(d, -1, sizeof d); for(int i = 1; i &lt;= k; i++) bfs(i); read(q); while(q--){ read(r1, c1, r2, c2); int ans = abs(r1 - r2) + abs(c1 - c2); for(int kk = 1; kk &lt;= k; kk++) ans = min(ans, d[kk][r1][c1] + d[kk][r2][c2] + 1); printf(&quot;%d\\n&quot;, ans); } return 0;}","link":"/blog-xcpc/2020/02/14/Codeforces-Round-619-Div-2/"},{"title":"Codeforces Round #621 (Div.1+Div.2)","text":"比赛链接 / 官方题解链接 A. Cow and HaybalesSolution尽可能地往 $a_1$ 放就行了。 Code>folded12345678910111213141516171819202122232425262728293031#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 105;int T, n, a[N], d;int main(){ read(T); while(T--){ read(n, d); for(int i = 1; i &lt;= n; i++){ read(a[i]); if(i &gt; 1){ a[1] += min(d / (i - 1), a[i]); d -= (i - 1) * min(d / (i - 1), a[i]); } } printf(&quot;%d\\n&quot;, a[1]); } return 0;} B. Cow and FriendSolution其实就是不断画圆，以两圆的情况说明：假设先走 $r_1$ 距离，再走 $r_2$，联想惠更斯原理里面的包络面，到原点距离为 $(r_1,r2]$ 之间的区域都可以通过这两步走到。 所以先走一个最大的小于 $x$ 的长度，再用最大的长度走即可。 Code>folded12345678910111213141516171819202122232425262728293031#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int T, n, a, x, mx, mnx;int main(){ read(T); while(T--){ mnx = mx = 0; read(n, x); for(int i = 1; i &lt;= n; i++){ read(a); if(a &lt;= x &amp;&amp; a &gt; mnx) mnx = a; if(a &gt; mx) mx = a; } int ans = (x - mnx) / mx + 1; if((x - mnx) % mx) ans++; printf(&quot;%d\\n&quot;, ans); }} C. Cow and MessageSolution一定存在长度为 $1$ 或者 $2$ 的出现次数最多字符串，因为对于长度大于 $2$ 的字符串，取它的长度为 $2$ 的子串，出现次数至少和它一样多。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;char s[N];int n, dp2, dp1;LL cnt[200], ans;int main(){ scanf(&quot;%s&quot;, s+1); n = strlen(s+1); for(int i = 1; i &lt;= n; i++){ cnt[s[i]]++; ans = max(ans, max(cnt[s[i]], cnt[s[i]] * (cnt[s[i]] - 1) / 2)); } for(int i = 'a'; i &lt;= 'z'; i++){ for(int j = 'a'; j &lt;= 'z'; j++){ LL res = 0; if(j == i) continue; dp1 = dp2 = 0; for(int k = n; k &gt;= 1; k--){ dp1 = dp2; if(s[k] == j) dp1++; if(s[k] == i) res += dp1; dp2 = dp1; } ans = max(ans, res); } } printf(&quot;%lld\\n&quot;, ans); return 0;} D. Cow and FieldsSolution加上一条边后，从 $1$ 到 $n$ 的最短路有两种情况：经过了加的新边或未经过新边。 未经过新边：则最短路就是原来的最短路，$bfs$ 即可。 经过了新边：设新边是 $(u,v)$，则最短路就是 $\\min(dis1_{u}+1+dis2_{v},dis1_{v}+1+dis2_{u})$，其中 $dis1_{i}$ 表示 $1$ 到 $i$ 的最短路，$dis2_{i}$ 表示 $i$ 到 $n$ 的最短路，二者都可以 $bfs$ 求得。 现在我们的问题转化为最大化 $\\min(dis1_{i}+dis2_{j},dis1_{j}+dis2_{i})$，其中 $i,j$ 是 $a$ 中的数。我们想把讨厌的 $\\min()$ 去掉，考虑贪心：按照 $dis1$ 从小到大排序，分类讨论（设 $i&lt;j$ ）： 若 $dis1_i+dis2_j\\leq dis1_j+dis2_i$，则 $\\min(dis1_{i}+dis2_{j},dis1_{j}+dis2_{i})=dis1_i+dis2_j$，达到了去掉 $\\min()$ 的目的； 若 $dis1_i+dis2_j&gt;dis1_j+dis2_i$，又因为排序后 $dis1_i\\leq dis1_j$，所以一定有 $dis2_i&lt;dis2_j$，于是 $dis1_i+dis2_i&lt;dis1_j+dis2_j$，也就是说我不经过新加的 $(i,j)$ 这条边就能走出更短的路径，那么最后计算答案与原最短路取 $\\min$ 时，这个分类情况的存在不影响答案，不妨就按照第一种分类的情形计算罢了（反正结果不会影响最终答案）。 所以排序后维护一个 $dis2$ 的后缀最大值即可。 复杂度：$O(n\\lg n+m)$ Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;const int INF = 1e8;int n, a[N], u, v, m, k;struct Edge{ int nxt, to, dis;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to, 1}; head[from] = edgeNum;}int dis[3][N];void bfs(int s, int kind){ queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) dis[kind][i] = INF; dis[kind][s] = 0; q.push(s); while(!q.empty()){ int cur = q.front(); q.pop(); for(int i = head[cur]; i; i = edge[i].nxt){ if(dis[kind][edge[i].to] != INF) continue; dis[kind][edge[i].to] = dis[kind][cur] + 1; q.push(edge[i].to); } }}struct Special{ int a, b; bool operator &lt; (const Special A) const{ return a &lt; A.a; }}d[N];int mx[N];int main(){ read(n, m, k); for(int i = 1; i &lt;= k; i++) read(a[i]); for(int i = 1; i &lt;= m; i++){ read(u, v); addEdge(u, v); addEdge(v, u); } bfs(1, 1); bfs(n, 2); for(int i = 1; i &lt;= k; i++){ d[i].a = dis[1][a[i]]; d[i].b = dis[2][a[i]]; } sort(d+1, d+k+1); for(int i = k; i &gt;= 1; i--) mx[i] = max(mx[i+1], d[i].b); int res = 0; for(int i = 1; i &lt; k; i++) res = max(res, d[i].a + mx[i+1]); printf(&quot;%d\\n&quot;, min(dis[1][n], res + 1)); return 0;} E. Cow and Treats好诡异的题目背景呃……分分钟出戏啊～ Solution【参考博客：1，2 】 首先我们需要发现一个重要的结论： 结论：$f_i$ 相同的牛必不在同一侧，否则一定会撞车（很好理解） 推论1：$f_i$ 相同的牛最多只能走两头，即分别从左右两端走 推论2：同一侧的牛的 $f_i$ 互不相同，因此只要草够吃，就一定可以找到一个顺序使得它们全都睡觉 现在同一侧的牛之间倒是不会冲突了，但是两侧的牛还是可能冲突的。于是我们可以枚举一个分割点，规定左右侧的牛都不能走过这个分割点。 由于 $f_i$ 相同与否起到至关重要的作用，我们把所有牛按照 $f_i$ 分类，依次考虑每一类：假设从左边出发能吃饱睡觉的有 $a$ 头牛，从右边出发能吃饱睡觉的有 $b$ 头牛，从两边出发都可以吃饱睡觉的有 $c$ 头牛，那么简单分类列式一下就知道方案数了。 可惜这么做会出现重复计算的情况——当分割点处没有牛睡觉时。于是我们可以枚举第一头从左往右走的牛，它睡下后自然而然形成了分割点，再按上述过程处理（不过特判一下和它同一类的牛只能从右往左且最多走一头） 但是这样做会导致漏一种情况：没有牛从左边出发的情况。所以最后再单独计算一下全部从右边出发的情况即可。 复杂度：$O(n^2)$ 虽然至此这道题做完了，但是上述过程总还是有点不直观，然后搜到了 cz_xuyixuan dalao 的博客，把这个问题抽象成了数学语言： 每个元素有三个值 $f_i,l_i,r_i$，要求找到两个集合 $S,T$，满足同一集合中元素的 $f_i$ 互不相同且：$\\max\\limits_{i\\in S}{l_i}+\\max\\limits_{i\\in T}r_i\\leq n$. 求 $|S|+|T|$ 的最大值及方案数。 于是乎，我们的做法对应为：枚举 $\\max\\limits_{i\\in S}l_i$，对于一个元素 $j$，它能放在 $S$ 中需要满足：$l_j&lt;l_i$，能放在 $T$ 中需要满足：$n-r_j\\geq l_i$. 然后把元素按照 $f_i$ 分类后计数。 转化成数学模型之后就不用绕原来那个吃饱了睡觉的弯了，思维上直接一些。Orz… Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int N = 5005;const LL MOD = 1e9 + 7;int n, m, s[N], ltot[N], rtot[N], maxx;LL ans, ans0;struct Cow{ int f, h;}cow[N];vector&lt;int&gt; vec[N];inline int calPos(int i){ int cnt = 0, pos; for(pos = 1; pos &lt;= n; pos++){ // calculate the position where the first cow sleeps if(s[pos] == cow[i].f){ cnt++; if(cnt == cow[i].h) break; } } return pos;}inline void initTot(int pos){ memset(ltot, 0, sizeof ltot); memset(rtot, 0, sizeof rtot); for(int j = 1; j &lt;= pos - 1; j++) ltot[s[j]]++; for(int j = pos + 1; j &lt;= n; j++) rtot[s[j]]++;}inline int calGoFromRight(int i){ int cnt = 0; for(int k = 0; k &lt; vec[cow[i].f].size(); k++) if(vec[cow[i].f][k] &lt;= rtot[cow[i].f]) cnt++; cnt -= rtot[cow[i].f] &gt;= cow[i].h; return cnt;}void calOtherCow(int i, LL &amp;res, LL &amp;res0){ for(int j = 1; j &lt;= maxx; j++){ if(j == cow[i].f) continue; int a = 0, b = 0, c = 0; for(int k = 0; k &lt; vec[j].size(); k++){ if(vec[j][k] &lt;= ltot[j] &amp;&amp; vec[j][k] &lt;= rtot[j]) c++; else if(vec[j][k] &lt;= ltot[j]) a++; else if(vec[j][k] &lt;= rtot[j]) b++; } if((!a &amp;&amp; b &amp;&amp; c) || (a &amp;&amp; !b &amp;&amp; c)){ (res *= (a * b + a * c + b * c + c * (c - 1)) % MOD) %= MOD; res0 += 2; } else if(!a &amp;&amp; !b &amp;&amp; c){ if(c == 1) (res *= 2) %= MOD, res0++; else (res *= c * (c - 1) % MOD) %= MOD, res0 += 2; } else if(a &amp;&amp; !b &amp;&amp; !c) (res *= a) %= MOD, res0++; else if(!a &amp;&amp; b &amp;&amp; !c) (res *= b) %= MOD, res0++; }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d&quot;, &amp;s[i]); maxx = max(maxx, s[i]); } for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d&quot;, &amp;cow[i].f, &amp;cow[i].h); vec[cow[i].f].push_back(cow[i].h); maxx = max(maxx, cow[i].f); } for(int i = 1; i &lt;= m; i++){ // iterate the first cow LL res = 0, res0 = 0; int pos = calPos(i); if(pos == n + 1) continue; initTot(pos); int cnt = calGoFromRight(i); res = max(1, cnt); res0 = cnt == 0 ? 1 : 2; calOtherCow(i, res, res0); if(res0 &gt; ans0) ans0 = res0, ans = res; else if(res0 == ans0) (ans += res) %= MOD; } memset(rtot, 0, sizeof rtot); for(int i = 1; i &lt;= n; i++) rtot[s[i]]++; LL onlyRight0 = 0, onlyRight = 1; for(int i = 1; i &lt;= maxx; i++){ if(!vec[i].empty()){ int cnt = 0; for(int k = 0; k &lt; vec[i].size(); k++) if(rtot[i] &gt;= vec[i][k]) cnt++; if(cnt){ onlyRight0++; (onlyRight *= cnt) %= MOD; } } } if(onlyRight0 &gt; ans0) ans0 = onlyRight0, ans = onlyRight; else if(onlyRight0 == ans0) (ans += onlyRight) %= MOD; printf(&quot;%lld %lld\\n&quot;, ans0, ans0 == 0 ? 1 : ans); return 0;} F. Cow and VacationSolution对于每个询问，起点到终点在树上有唯一路径，我们要做的就是在路径的某个节点出去补充一下能量，然后回来继续沿着这条路径走。所以很容易地知道，假设我们在某个“路口”出去补充能量，那么补给站到路口的距离应小于 $\\frac{k}{2}$，否则回来之后能量反而更少了。于是我们有了一个 $O(nv)$ 的做法：即对于每个询问，一步一步地从起点往终点走，并且不断更新能量，能更新多少能量可以 $O(n^2)$ 的预处理出来。 现在要优化这个做法，我们显然不能一步一步地走。注意到如果两个补给站之间的距离小于等于 $k$，那么这两个补给站可以看作传送门。由此，用 $bfs$ 和并查集将补给站分好类，同一类的补给站之间可以进行无消耗的传送。那么对于每个询问，如果起点与终点要么可以直接走到，要么能通过一系列的传送门传送到达，就输出 YES。再想一下，不难发现上述的“一系列传送门”其实就是“一种传送门”，因为两种传送门之间能走到的话，按我们的定义，它们其实就是一种传送门。 所以现在只需要考虑如何判断起点与终点是否可以到达同一类补给站。又由第一段的叙述，不妨定义距离一个补给站小于 $\\frac{k}{2}$ 的所有点都是同一类传送门，于是同一类传送门之间可以进行传送且能量消耗小于 $\\frac{k}{2}$. 对于每个询问，特判掉可以直接走到的情况，然后从起点往终点走 $\\frac{k}{2}$ 的距离，从终点到起点走 $\\frac{k}{2}$ 的距离，判断新到的这两个点是否属于同一类传送门即可。 一个 trick：在每条边中间插一个点，即把边扩倍，然后 $k$ 也相应的乘 $2$，变成偶数便于处理。 复杂度：$O((n+v)\\lg n)$ Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)const int N = 400005;int n, k, r, u, v, q, rest[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}struct LCA{ int fa[N][25], dep[N]; void dfs(int x, int f, int depth){ dep[x] = depth; fa[x][0] = f; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth+1); } } void init(){ for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for(int i = 1; i &lt;= n; i++) if(fa[i][j-1]) fa[i][j] = fa[fa[i][j-1]][j-1]; } int lca(int x, int y){ if(dep[x] &lt; dep[y]) swap(x, y); for(int i = 20; i &gt;= 0; i--) if(dep[x] - (1 &lt;&lt; i) &gt;= dep[y]) x = fa[x][i]; if(x == y) return x; for(int i = 20; i &gt;= 0; i--){ if(fa[x][i] &amp;&amp; fa[x][i] != fa[y][i]){ x = fa[x][i]; y = fa[y][i]; } } return fa[x][0]; } inline int up(int x, int d){ for(int i = 20; i &gt;= 0; i--){ if((1 &lt;&lt; i) &lt;= d){ d -= (1 &lt;&lt; i); x = fa[x][i]; } } return x; }}lca;struct DSU{ int fa[N]; inline void init(){ for(int i = 1; i &lt;= n; i++) fa[i] = i; } int findfa(int x){ return fa[x] == x ? x : fa[x] = findfa(fa[x]); } inline void unionn(int x, int y){ fa[findfa(y)] = findfa(x); }}dsu;int dis[N];queue&lt;int&gt; que;inline void bfs(){ for(int i = 1; i &lt;= n; i++) dis[i] = -1; for(int i = 1; i &lt;= r; i++){ que.push(rest[i]); dis[rest[i]] = 0; } while(!que.empty()){ int cur = que.front(); que.pop(); if(dis[cur] == k) continue; for(int i = head[cur]; i; i = edge[i].nxt){ if(dis[edge[i].to] == -1){ que.push(edge[i].to); dis[edge[i].to] = dis[cur] + 1; } dsu.unionn(cur, edge[i].to); } }}int main(){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;r); for(int i = 1; i &lt; n; i++){ scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, n+i), addEdge(n+i, u); addEdge(n+i, v), addEdge(v, n+i); } n += n - 1; dsu.init(); for(int i = 1; i &lt;= r; i++) scanf(&quot;%d&quot;, &amp;rest[i]); bfs(); lca.dfs(1, 0, 1); lca.init(); scanf(&quot;%d&quot;, &amp;q); while(q--){ scanf(&quot;%d%d&quot;, &amp;u, &amp;v); int uvlca = lca.lca(u, v); if(lca.dep[u] + lca.dep[v] - 2 * lca.dep[uvlca] &lt;= 2 * k){ puts(&quot;YES&quot;); continue; } if(lca.dep[u] - lca.dep[uvlca] &gt;= k) u = lca.up(u, k); else u = lca.up(v, lca.dep[v] + lca.dep[u] - 2 * lca.dep[uvlca] - k); if(lca.dep[v] - lca.dep[uvlca] &gt;= k) v = lca.up(v, k); else v = lca.up(u, lca.dep[v] + lca.dep[u] - 2 * lca.dep[uvlca] - k); if(dsu.findfa(u) == dsu.findfa(v)) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0;}","link":"/blog-xcpc/2020/02/18/Codeforces-Round-621-Div-1-Div-2/"},{"title":"Codeforces Round #624 (Div.3)","text":"比赛链接 A/B/C略 D. Three IntegersSolution结论：$1\\leq A\\leq 2a,1\\leq B\\leq 2b$. 因为有把 $a$ 变成 $2a$ 的功夫，都可以把 $a$ 变成 $1$ 了，而变成 $1$ 显然是更好的事。所以循环枚举 $A$，再枚举 $A$ 的倍数且小于等于 $2b$ 的数，然后就进计算 $C$ 即可。 复杂度：$O(n\\lg n)$ Code>folded1234567891011121314151617181920212223242526272829#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;int T, a, b, c;int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); int ans[4] = {(int)1e9}, res = 0; for(int i = 1; i &lt;= 2 * a; i++) { for(int j = i; j &lt;= 2 * b; j += i){ int k = c / j * j; if(k == 0) k += j; if(ans[0] &gt; abs(a - i) + abs(b - j) + min(abs(c - k), abs(k + j - c))){ ans[0] = abs(a - i) + abs(b - j) + min(abs(c - k), abs(k + j - c)); ans[1] = i, ans[2] = j, ans[3] = abs(c - k) &lt; abs(k + j - c) ? k : k + j; } } } printf(&quot;%d\\n&quot;, ans[0]); for(int i = 1; i &lt;= 3; i++) printf(&quot;%d &quot;, ans[i]); putchar(10); } return 0;} E. Construct the Binary TreeSolution二叉树的深度和在完全二叉树的情况下取到最小，在链的情况下取到最大。当 $d$ 落在这个最大与最小的范围之间时一定有解。 我的构造方法是：以完全二叉树为初始情况，深度和不够的话，就从当前最深的且同一层有 $1$ 个以上节点的那一层中取出一个节点往下放，直到深度和达到 $d$ 或者不能继续往下放为止。 复杂度：$O(n)$ Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int N = 5005;int T, n, d, ans[N];vector&lt;int&gt; v[N];int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;d); for(int i = 1; i &lt;= n; i++) v[i].clear(); int k = 0, now = 1, res = 0; while(now - 1 &lt; n) k++, now &lt;&lt;= 1; // now = 2 ^ k now = 1; for(int i = 1; i &lt;= k; i++){ now &lt;&lt;= 1; for(int j = now / 2; j &lt; min(n+1, now); j++) v[i].push_back(j); res += (min(n+1, now) - now / 2) * (i - 1); } if(d &gt; n * (n - 1) / 2 || d &lt; res){ puts(&quot;NO&quot;); continue; } int lst = k; now = k; while(res &lt; d){ while(v[now].size() == 1) now--; if(v[now].size() &gt; 1){ int cur = v[now].back(); v[now].pop_back(); if(lst + 1 - now &lt;= d - res){ v[++lst].push_back(cur); res += lst - now; } else{ v[now + d - res].push_back(cur); res = d; } } } v[0].push_back(0); puts(&quot;YES&quot;); for(int i = 2; i &lt;= lst; i++) for(int j = 0; j &lt; v[i].size(); j++) ans[v[i][j]] = v[i-1][j/2]; for(int i = 2; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } return 0;} F. Moving PointsSolution说白了就是求二维偏序并且维护 $x$ 那一维的差值和。 刚好才学了 CDQ 分治，就愉快地用 CDQ 分治过了这道题。 自然，CDQ 分治能做，树状数组也能做。 复杂度：$O(n\\lg n)$ Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 200005;int n;struct Node{ int x, v;}node[N];bool cmpv(const Node &amp;A, const Node &amp;B){ return A.v == B.v ? A.x &lt; B.x : A.v &lt; B.v; }LL ans = 0;Node tmp[N];void cdq(int l, int r){ if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid), cdq(mid+1, r); int ptl = l, ptr = mid + 1, tid = l - 1; LL res = 0; while(ptl &lt;= mid &amp;&amp; ptr &lt;= r){ if(node[ptl].x &lt;= node[ptr].x){ res += node[ptl].x; tmp[++tid] = node[ptl++]; } else{ ans += 1ll * (ptl - l) * node[ptr].x - res; tmp[++tid] = node[ptr++]; } } while(ptl &lt;= mid) tmp[++tid] = node[ptl++]; while(ptr &lt;= r) ans += 1ll * (ptl - l) * node[ptr].x - res, tmp[++tid] = node[ptr++]; for(int i = l; i &lt;= tid; i++) node[i] = tmp[i];}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;node[i].x); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;node[i].v); sort(node+1, node+n+1, cmpv); cdq(1, n); printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/02/25/Codeforces-Round-624-Div-3/"},{"title":"Codeforces Round #622 (Div.2)","text":"比赛链接 / 官方题解链接 A. Fast Food RestaurantSolution最多最多就 $7$ 种搭配，$a,b,c,ab,ac,bc,abc$，从大到小依次去满足即可。 Code&gt;folded123456789101112131415161718192021222324#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}int T, a, b, c;int main(){ read(T); while(T--){ int ans = 0; read(a, b, c); if(a &lt; b) swap(a, b); if(a &lt; c) swap(a, c); if(b &lt; c) swap(b, c); if(a) a--, ans++; if(b) b--, ans++; if(c) c--, ans++; if(a &amp;&amp; b) a--, b--, ans++; if(a &amp;&amp; c) a--, c--, ans++; if(b &amp;&amp; c) b--, c--, ans++; if(a &amp;&amp; b &amp;&amp; c) a--, b--, c--, ans++; printf(&quot;%d\\n&quot;, ans); } return 0;} B. Different Rules卡了好久……好歹把式子弄出来了，差点以为要挂在 B 题上…… 看到官方题解也是庞大的一坨，我就放心了（雾 Solution不失一般性，假设 $x\\leq y$. 下面的图中，第一列代表第一轮，第二列代表第二轮，每一行代表一个人的得分。 我们首先看一种大家“皆大欢喜”的情况——所有人总得分都一样，第一轮得了 $i$ 分，第二轮就得 $n+1-i$ 分（图1）。接下来分情况讨论： $x+y\\leq n$：此时图1中第二列的 $y$ 在第一列的 $x$ 下方（图2-1），已知条件是，第二列的这个 $y$ 往上跑到和第一列的 $x$ 同一层去了。 最小排名：交换第二列的 $y$ 和与第一列的 $x$ 同一层的那个元素，显然就是第1名了（图2-2）； 最大排名：$y$ 往上跑了 $(n-y+1)-x$ 层导致了 $x+y$ 变小了，于是其他人很不爽，也想把第二轮的得分变小且变小到总分与 $x+y$ 相等就够了，于是大家都往上移 $(n-y+1)-x$ 层，总体上来看第二列往上“滚”（第 $i$ 层到第 $i-1$ 层，第 $1$ 层到最后一层）了 $(n-y+1)-x$ 层（图2-3）。从上面滚到下面去了的有 $(n-y+1)-x$ 个，这些分事实上变大了，不计入答案，所以最大排名是 $n-[(n-y+1)-x]=x+y-1$. $x+y&gt;n$：此时图1中第二列的 $y$ 在第一列的 $x$ 上方（图3-1），已知条件是，第二列的这个 $y$ 往下跑到和第一列的 $x$ 同一层去了。 最大排名：交换第二列的 $y$ 和与第一列的 $x$ 同一层的那个元素，显然就是第 $n$ 名了（图3-2）； 最小排名：$y$ 往下跑了$x-(n-y+1)$ 层导致了 $x+y$ 变大了，其他人都很关心它，想把第二轮得分变大，于是大家都往下移 $x-(n-y+1)$ 层，总体上来看第二列往下“滚”了 $x-(n-y+1)$ 层，可惜还不够，为使 $x+y$ 排名更小，其他元素还得再往下移一层（图3-3）。从下面滚到上面去了的有 $\\min{n-1,x-(n-y+1)+1}$ 个（小心 $x=y=n$ 的特殊情况），这些分事实上变小了，不计入答案，所以最小排名是 $\\min{n-1,x-(n-y+1)+1}+1=\\min{n,x+y-n+1}$. 把上面两种情况整合起来，最小排名 $=\\max(\\min(n,x+y+1-n),1)$，最大排名 $=\\min(x+y-1,n)$. Code>folded123456789101112#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int T, n, x, y;int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;x, &amp;y); printf(&quot;%d %d\\n&quot;, max(min(n, x + y + 1 - n), 1), min(x + y - 1, n)); } return 0;} C1. Skyscrapers (easy version)Solution依次枚举每一个元素作为最高点，然后向左右两边暴力扩展即可。 复杂度：$O(n^2)$ Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1005;int n;LL m[N], f[N], rec[N], ans[N];int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(m[i]); for(int i = 1; i &lt;= n; i++){ LL res = m[i]; rec[i] = m[i]; for(int j = i - 1; j &gt;= 1; j--){ LL now = min(m[j], rec[j+1]); res += now; rec[j] = min(m[j], rec[j+1]); } for(int j = i + 1; j &lt;= n; j++){ LL now = min(m[j], rec[j-1]); res += now; rec[j] = min(m[j], rec[j-1]); } if(ans[0] &lt; res){ ans[0] = res; for(int j = 1; j &lt;= n; j++) ans[j] = rec[j]; } } for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]); return 0;} C2. Skyscrapers (hard version)唉，比赛时在正解的边缘疯狂试探，然后逐渐偏离正解，用分治解出了最大值，突然想起题目要求的是方案，结果复杂度降不下来了…… Solution预处理每一个元素左右最近的小于它的元素位置（设为 $L_i,R_i$），然后就可以递推了： 设 $f_i$ 是以第 $i$ 个元素结尾的最大上升序列的值，那么 $f_i=f_{L_i}+m_i\\cdot(i-L_i)$. 设 $g_i$ 是以第 $i$ 个元素开头的最大下降序列的值，那么 $g_i=g_{R_i}+m_i\\cdot(R_i-i)$. 然后枚举每一个点作为最大值，第 $i$ 个点作为最大值时的答案就是 $f_i+g_i-m_i$ 了。靠 $L$ 和 $R$ 数组也能够线性地把方案解出来。 怎么预处理呢？我的方法是 ST 表+二分查找（说实话有点奇怪……毕竟以前从来没有在 ST 表上二分过……） 复杂度：$O(n\\lg n)$ Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 500005;int n, L[N], R[N];LL m[N], f[N], g[N], h[N], ans;int lg[N];LL rmq[N][20];void pre(){ lg[1] = 0, lg[2] = 1; for(int i = 3; i &lt;= n; i++) lg[i] = lg[i/2] + 1;}void init(){ for(int i = 1; i &lt;= n; i++) rmq[i][0] = m[i]; for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) rmq[i][j] = min(rmq[i][j-1], rmq[i+(1&lt;&lt;(j-1))][j-1]);}int query(int l, int r){ int k = lg[r - l + 1]; return min(rmq[l][k], rmq[r-(1&lt;&lt;k)+1][k]);}inline void find(int x){ int l = 0, r = x - 1; while(l &lt; r){ int mid = (l + r) &gt;&gt; 1; if(query(mid + 1, r) &lt; m[x]) l = mid + 1; else r = mid; } L[x] = l; l = x + 1, r = n + 1; while(l &lt; r){ int mid = (l + r) &gt;&gt; 1; if(query(l, mid) &lt; m[x]) r = mid; else l = mid + 1; } R[x] = r;}int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(m[i]); pre(); init(); for(int i = 1; i &lt;= n; i++) find(i); for(int i = 1; i &lt;= n; i++) f[i] = f[L[i]] + m[i] * (i - L[i]); for(int i = n; i &gt;= 1; i--) g[i] = g[R[i]] + m[i] * (R[i] - i); int mark = 0; for(int i = 1; i &lt;= n; i++){ if(ans &lt; f[i] + g[i] - m[i]){ ans = f[i] + g[i] - m[i]; mark = i; } }// printf(&quot;%lld\\n&quot;, ans); int now = mark; while(now){ for(int i = L[now] + 1; i &lt;= now; i++) h[i] = m[now]; now = L[now]; } now = mark; while(now &lt;= n){ for(int i = now; i &lt;= R[now] - 1; i++) h[i] = m[now]; now = R[now]; } for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, h[i]); return 0;} D. Happy New Year留坑……","link":"/blog-xcpc/2020/02/23/Codeforces-Round-622-Div-2/"},{"title":"Codeforces Round #626 (Div.2, based on Moscow Open Olympiad in Informatics)","text":"比赛链接 / 官方题解链接 A. Even Subset Sum ProblemSolution找一个偶数或两个奇数即可。 Code&gt;folded12345678910111213141516171819202122232425262728293031323334353637#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 105;int T, n, a[N];int main(){ read(T); while(T--){ read(n); int mark = 0, mark1 = 0, mark2 = 0; for(int i = 1; i &lt;= n; i++){ read(a[i]); if(a[i] % 2 == 0) mark = i; else if(mark1 == 0) mark1 = i; else mark2 = i; } if(mark){ printf(&quot;1\\n%d\\n&quot;, mark); continue; } if(mark1 &amp;&amp; mark2) printf(&quot;2\\n%d %d\\n&quot;, mark1, mark2); else puts(&quot;-1&quot;); } return 0;} B. Count SubrectanglesSolution枚举矩形边长，分别数 $a$ 和 $b$ 数组中有多少能构成边长的连续 $1$，答案加上二者乘积。 复杂度：$O(n\\cdot r(k))$，其中 $r(k)$ 表示 $k$ 的约数个数。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 40005;int n, m, k, a[N], b[N];int dpa[N], dpb[N];LL ans = 0;int main(){ read(n, m, k); for(int i = 1; i &lt;= n; i++){ read(a[i]); if(a[i] == 1) dpa[i] = dpa[i-1] + 1; else dpa[i] = 0; } for(int i = 1; i &lt;= m; i++){ read(b[i]); if(b[i] == 1) dpb[i] = dpb[i-1] + 1; else dpb[i] = 0; } vector&lt;int&gt; vec; for(int r = 1; r * r &lt;= k; r++) if(k % r == 0) vec.push_back(r); for(auto r: vec){ LL cnt1 = 0, cnt2 = 0; for(int i = 1; i &lt;= n; i++) cnt1 += (dpa[i] &gt;= r); for(int i = 1; i &lt;= m; i++) cnt2 += (dpb[i] &gt;= (k / r)); ans += cnt1 * cnt2; if(r * r == k) continue; cnt1 = cnt2 = 0; for(int i = 1; i &lt;= n; i++) cnt1 += (dpa[i] &gt;= (k / r)); for(int i = 1; i &lt;= m; i++) cnt2 += (dpb[i] &gt;= r); ans += cnt1 * cnt2; } printf(&quot;%lld\\n&quot;, ans); return 0;} C. Unusual CompetitionsSolution比赛时猜的结论：顺序遍历字符串，当 ( 和 ) 相等时，若没有构成合法序列，就 reorder 一次。 Intuitive proof：画一个折线图，遇到 ( 就往上画，遇到 ) 就往下画，然后我们需要把基准线以下的部分翻转到上面去，图参看官方题解。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1000005;int n, cnt[2][N], ans;char s[N];int main(){ read(n); scanf(&quot;%s&quot;, s+1); for(int i = 1; i &lt;= n; i++){ if(s[i] == '(') cnt[0][i] = cnt[0][i-1] + 1, cnt[1][i] = cnt[1][i-1]; else cnt[0][i] = cnt[0][i-1], cnt[1][i] = cnt[1][i-1] + 1; } if(cnt[0][n] != cnt[1][n]) return puts(&quot;-1&quot;), 0; stack&lt;int&gt; sta; int pre = 0; for(int i = 1; i &lt;= n; i++){ if(s[i] == ')' &amp;&amp; !sta.empty() &amp;&amp; sta.top() == '(') sta.pop(); else sta.push(s[i]); if(cnt[0][i] == cnt[1][i]){ if(!sta.empty()){ ans += i - pre; while(!sta.empty()) sta.pop(); } pre = i; } } printf(&quot;%d\\n&quot;, ans); return 0;} D. PresentSolution答案的第 $i$ 位为 $1$ 当且仅当存在奇数个数对 $(j,k)$ 满足 $a_j+a_k$ 的第 $i$ 位为 $1$。 依次考虑答案的每一位（从 $0$ 开始），在考虑第 $i$ 位时，由于更高位对答案没有影响，我们先去掉更高位的数字，形成新的数列 $b[]$，那么现在每个数的取值范围是 $[1,2^{i+1}-1]$，两个数的和的范围是 $[2,2^{i+2}-2]$. 于是，若数对 $(j,k)$ 满足 $b_j+b_k$ 的第 $i$ 位为 $1$，那么 $b_j+b_k\\in[2^i,2^{i+1}-1]\\cup[2^{i+1}+2^i,2^{i+2}-2]$（草纸上举举例就知道了）。枚举 $b_j$，排序后分别在两个区间二分查找就可以数出数对 $(j,k)$ 的数量。 复杂度：$O(n\\lg n\\lg10^7)$ Code>folded123456789101112131415161718192021222324252627282930313233343536#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 400005;int n, a[N], b[N], ans;int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 0; i &lt;= 24; i++){ for(int j = 1; j &lt;= n; j++) b[j] = a[j] &amp; ((1 &lt;&lt; (i+1)) - 1); sort(b+1, b+n+1); LL cnt = 0; for(int j = 1; j &lt;= n; j++){ int l = lower_bound(b+1, b+j, (1&lt;&lt;i) - b[j]) - b; int r = upper_bound(b+1, b+j, (1&lt;&lt;(i+1))-1 - b[j]) - b; cnt += r - l; l = lower_bound(b+1, b+j, (1&lt;&lt;i)+(1&lt;&lt;(i+1)) - b[j]) - b; r = upper_bound(b+1, b+j, (1&lt;&lt;(i+2))-2 - b[j]) - b; cnt += r - l; } if(cnt &amp; 1) ans |= (1 &lt;&lt; i); } printf(&quot;%d\\n&quot;, ans); return 0;} E. Instant NoodlesSolution容易知道，把右边邻域相同的点合并为一个点（权值相加）后答案不变。结论：合并后答案就是右边所有点的权值 $gcd$. 证明：设左边点 $a$ 在右边的邻域的权值和为 $A$，左边点 $b$ 在右边的邻域的权值和为 $B$，那么 $a,a\\cup b$ 是两个子集，选出这两个子集时，$gcd(A,A+B)=gcd(A,B)$. 扩展到所有子集，答案就是右边所有点的 $gcd$. Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 500005;LL gcd(LL a, LL b){ return b == 0 ? a : gcd(b, a % b); }int T, n, m;LL c[N];vector&lt;int&gt; edge[N];int main(){ read(T); while(T--){ read(n, m); for(int i = 1; i &lt;= n; i++) edge[i].clear(); for(int i = 1; i &lt;= n; i++) read(c[i]); for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); edge[v].emplace_back(u); } map&lt;vector&lt;int&gt;, LL&gt; a; for(int i = 1; i &lt;= n; i++){ if(edge[i].empty()) continue; sort(edge[i].begin(), edge[i].end()); a[edge[i]] += c[i]; } LL ans = 0; for(auto x: a) ans = gcd(x.second, ans); printf(&quot;%lld\\n&quot;, ans); } return 0;} F. Reality ShowSolution把输入颠倒一下顺序，则原题可转化为：求不降序列使得合并后收益最大。 设 $dp[i][j][k]$ 表示考虑前 $i$ 个数，最大值小于等于 $j$ 且有 $k$ 个值等于 $j$ 的最大收益，则若选择第 $i$ 个数，$dp[i][l_i][k]$ 可从 $dp[i-1][l_i][k-1]$ 转移而来；另外，不断地两两合并，有 $dp[i][j][k]$ 可以从 $dp[i][j-1][2k]$ 和 $dp[i][j-1][2k+1]$ 转移而来，一共合并 $O(\\lg n)$ 次。 实现时 $dp$ 数组第一维滚动，则时间复杂度 $O(n^2\\lg n)$，空间 $O(n^2)$. Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 2005;const int INF = 1e9;int n, m, l[N], s[N], c[N&lt;&lt;1];int dp[N&lt;&lt;1][N], ans = -INF;int main(){ read(n, m); for(int i = n; i &gt;= 1; i--) read(l[i]); for(int i = n; i &gt;= 1; i--) read(s[i]); for(int i = 1; i &lt;= n + m; i++) read(c[i]); memset(dp, -0x7f, sizeof dp); for(int i = 1; i &lt;= n + m; i++) dp[i][0] = 0; for(int i = 1; i &lt;= n; i++){ int pos = l[i]; for(int j = i; j &gt;= 1; j--) dp[pos][j] = max(dp[pos][j], dp[pos][j - 1] + c[l[i]] - s[i]); for(int k = pos + 1, t = i / 2; k &lt;= n + m; k++, t &gt;&gt;= 1){ for(int j = t; j &gt;= 0; j--){ dp[k][j] = max(dp[k][j], dp[k-1][j&lt;&lt;1] + j * c[k]); dp[k][j] = max(dp[k][j], dp[k-1][j&lt;&lt;1|1] + j * c[k]); } } } for(int i = 1; i &lt;= n + m; i++) ans = max(ans, max(dp[i][0], dp[i][1])); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/03/14/Codeforces-Round-626-Div-2-based-on-Moscow-Open-Olympiad-in-Informatics/"},{"title":"Codeforces Round #625 (Div.2, based on Technocup 2020 Final Round)","text":"比赛链接 A. Contest for RobotsSolution$b$ 能赢的题设为 $1$ 分即可。 Code>folded123456789101112131415161718192021222324252627282930#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 105;int n, a[N], b[N], cnta, cntb;int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= n; i++) read(b[i]); for(int i = 1; i &lt;= n; i++){ if(a[i] == 1 &amp;&amp; b[i] == 0) cnta++; if(a[i] == 0 &amp;&amp; b[i] == 1) cntb++; } if(cnta == 0){ puts(&quot;-1&quot;); return 0; } int ans = cntb / cnta; if(cnta * ans &lt;= cntb) ans++; printf(&quot;%d\\n&quot;, ans); return 0;} B. Journey PlanningSolution题目中 $c_{i+1}-c_i=b_{c_{i+1}}-b_{c_i}$ 可以改写为：$b_{c_{i+1}}-c_{i+1}=b_{c_i}-c_i$. 于是计算（值减下标）相同的那些数的值之和的最大值即可。 坑点：减去下标后会出现负数。 Code>folded123456789101112131415161718192021222324#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int n;LL b, ans, cnt[800005];int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(b); cnt[b - i + 200000] += b; ans = max(ans, cnt[b - i + 200000]); } printf(&quot;%lld\\n&quot;, ans); return 0;} C. Remove AdjacentSolution从 $z$ 到 $a$ 枚举要删的字符，把字符串中能删的该字符都删掉即可。为代码方便，实践中我们把要删的字符减一，等价于删掉该字符再并到一起。 Code>folded1234567891011121314151617181920212223242526272829303132#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 105;int n, ans;bool b[N];char s[N];int main(){ read(n); scanf(&quot;%s&quot;, s+1); for(char ch = 'z'; ch &gt;= 'a'; ch--){ for(int i = 2; i &lt;= n; i++) if(s[i] == ch &amp;&amp; s[i-1] == ch - 1) b[i] = true, s[i] = ch - 1; for(int i = n - 1; i &gt;= 1; i--) if(s[i] == ch &amp;&amp; s[i+1] == ch - 1) b[i] = true, s[i] = ch - 1; } for(int i = 1; i &lt;= n; i++) ans += b[i]; printf(&quot;%d\\n&quot;, ans); return 0;} D. Navigation SystemSolution倒着建边，能用 $bfs$ 求出每个点到终点的最短距离以及走最短距离时下一步能走哪些节点。依次访问实际路径的节点：求最少次数时，如果下一步能走的节点中没有实际上下一步走的节点，答案加一；求最多次数时，如果下一步能走的节点中有不是实际上下一步走的节点，答案加一。 Code&gt;folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;int n, m, u, v, k, p[N], s, t, maxans, minans;bool has[N];struct Edge{ int nxt, to;}edge[N];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int dis[N], cnt[N], nxt[N];void bfs(){ memset(dis, 0x7f, sizeof dis); queue&lt;int&gt; q; dis[t] = 0; q.push(t); while(!q.empty()){ int cur = q.front(); q.pop(); for(int i = head[cur]; i; i = edge[i].nxt){ if(dis[edge[i].to] &gt; dis[cur] + 1){ dis[edge[i].to] = dis[cur] + 1; cnt[edge[i].to] = (cur != nxt[edge[i].to]); if(cur == nxt[edge[i].to]) has[edge[i].to] = true; q.push(edge[i].to); } else if(dis[edge[i].to] == dis[cur] + 1){ cnt[edge[i].to] += (cur != nxt[edge[i].to]); if(cur == nxt[edge[i].to]) has[edge[i].to] = true; } } }}int main(){ read(n, m); for(int i = 1; i &lt;= m; i++){ read(u, v); addEdge(v, u); } read(k); for(int i = 1; i &lt;= k; i++){ read(p[i]); if(i &gt; 1) nxt[p[i-1]] = p[i]; } s = p[1], t = p[k]; bfs(); for(int i = 1; i &lt; k; i++) maxans += (cnt[p[i]] &gt; 0); for(int i = 1; i &lt; k; i++) minans += (!has[p[i]]); printf(&quot;%d %d\\n&quot;, minans, maxans); return 0;} E. World of Darkraft: Battle for AzathothSolution武器按照攻击力从小到大排序，怪兽按照防御从小到大排序，则枚举武器时，能用一个指针指出当前能攻击的怪兽集合。以盔甲的防御力为值域建立线段树，维护该防御力能获得的最大利益（能攻击的怪兽价值减去自己的价格）。指针每往后移一次（即把一个怪兽加入被攻击集合），把线段树中大于这个怪兽的攻击力的所有点加上这个怪物的价值，询问线段树中最大价值，减去当前武器的价格就得到了这个武器的最大收益。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;int n, m, p, wid, aid;LL ans = -1e16, fun[1123456];struct Weapon{ LL att, cost; bool operator &lt; (const Weapon &amp;A) const{ return att == A.att ? cost &lt; A.cost : att &lt; A.att; }}w[N];struct Armor{ LL def, cost; bool operator &lt; (const Armor &amp;A) const{ return def == A.def ? cost &lt; A.cost : def &lt; A.def; }}a[N];struct Monster{ LL att, def, cost; bool operator &lt; (const Monster &amp;A) const{ return def &lt; A.def; }}mon[N];struct segTree{ int l, r; LL mxc, lazy;}tr[4123456];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].mxc = max(tr[lid].mxc, tr[rid].mxc);}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazy){ tr[lid].lazy += tr[id].lazy; tr[lid].mxc += tr[id].lazy; tr[rid].lazy += tr[id].lazy; tr[rid].mxc += tr[id].lazy; tr[id].lazy = 0; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; if(tr[id].l == tr[id].r){ if(fun[tr[id].l]) tr[id].mxc = -fun[tr[id].l]; else tr[id].mxc = -1e16; return; } build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazy += val; tr[id].mxc += val; return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}int query(int id, int l, int r){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].mxc; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else return max(query(lid, l, mid), query(rid, mid+1, r));}int main(){ read(n, m, p); for(int i = 1; i &lt;= n; i++) read(w[i].att, w[i].cost); for(int i = 1; i &lt;= m; i++) read(a[i].def, a[i].cost); for(int i = 1; i &lt;= p; i++) read(mon[i].def, mon[i].att, mon[i].cost); sort(w+1, w+n+1); sort(a+1, a+m+1); sort(mon+1, mon+p+1); for(int i = 1; i &lt;= n; i++) if(w[i].att != w[i-1].att) w[++wid] = w[i]; for(int i = 1; i &lt;= m; i++) if(a[i].def != a[i-1].def) a[++aid] = a[i]; for(int i = 1; i &lt;= aid; i++) fun[a[i].def] = a[i].cost; build(1, 1, 1e6+5); int pt = 0; for(int i = 1; i &lt;= wid; i++){ while(pt &lt; p &amp;&amp; mon[pt+1].def &lt; w[i].att){ pt++; add(1, mon[pt].att+1, 1e6+5, mon[pt].cost); } ans = max(ans, query(1, 1, 1e6+5) - w[i].cost); } printf(&quot;%lld\\n&quot;, ans); return 0;} F. Reachable StringsSolution两个字符串，只要其 $0$ 的个数与奇偶性相同，就可以互相转化。例如：$0101100$ 和 $0111000$ 都有 $4$ 个零且奇偶性都是奇-奇-偶-奇，所以它们可以互相转化。于是对原字符串针对 $0$ 及其奇偶性进行哈希。例如：忽视 $1$，奇数位的 $0$ 哈希成 $2$，偶数位的 $0$ 哈希成 $1$，这样就可以达到目的。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 200005;const LL MOD = 998244353;int n, q, cnt[N];char t[N];LL h[2][N], base = 233, power[N] = {1};inline void Hash(char s[]){ for(int i = 1; i &lt;= n; i++){ if(s[i] == '0'){ h[0][i] = (h[0][i-1] * base + (i &amp; 1) + 1) % MOD; h[1][i] = (h[1][i-1] * base + (!(i &amp; 1)) + 1) % MOD; } else h[0][i] = h[0][i-1], h[1][i] = h[1][i-1]; }}inline LL getSubstring(int l, int r, int k){ return ((h[k][r] - h[k][l-1] * power[cnt[r] - cnt[l-1]]) % MOD + MOD) % MOD;}int main(){ scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, t+1); for(int i = 1; i &lt;= n; i++){ power[i] = power[i-1] * base % MOD; cnt[i] = cnt[i-1] + (t[i] == '0'); } Hash(t); scanf(&quot;%d&quot;, &amp;q); while(q--){ int l1, l2, len; scanf(&quot;%d%d%d&quot;, &amp;l1, &amp;l2, &amp;len); LL res1 = getSubstring(l1, l1 + len - 1, l1 &amp; 1); LL res2 = getSubstring(l2, l2 + len - 1, l2 &amp; 1); puts(res1 == res2 ? &quot;YES&quot; : &quot;NO&quot;); } return 0;}","link":"/blog-xcpc/2020/03/02/Codeforces-Round-625-Div-2-based-on-Technocup-2020-Final-Round/"},{"title":"Codeforces Round #628 (Div.2)","text":"比赛链接 / 官方题解链接 A. EhAb AnD gCdSolution输出 $1$ 和 $x-1$ 即可。 Code>folded123456789101112131415161718192021#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T, x;int main(){ read(T); while(T--){ read(x); printf(&quot;%d %d\\n&quot;, 1, x-1); } return 0;} B. CopyCopyCopyCopyCopySolution排序去重后输出长度。 Code>folded1234567891011121314151617181920212223242526#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int T, n, a[N];int main(){ read(T); while(T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1); printf(&quot;%ld\\n&quot;, unique(a+1, a+n+1) - (a+1)); } return 0;} C. Ehab and Path-etic MEXsSolution考虑 $0,1$ 同时出现的路径，只需要保证 $2$ 不在该路径上。实现上，找一个度数大于 $2$ 的节点，把与之相连的边依次赋为 $0,1,2\\cdots$ 即可达到目的。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int n, ans[N], now;bool b[N];struct Edge{ int nxt, to, id;}edge[N&lt;&lt;1];int head[N], edgeNum, deg[N];void addEdge(int from, int to, int id){ edge[++edgeNum] = (Edge){head[from], to, id}; head[from] = edgeNum; deg[to]++;}int main(){ memset(ans, -1, sizeof ans); read(n); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); addEdge(u, v, i), addEdge(v, u, i); } int mark = 0; for(int i = 1; i &lt;= n; i++) if(deg[i] &gt; 2) mark = i; if(mark) for(int i = head[mark]; i; i = edge[i].nxt) ans[edge[i].id] = now++; for(int i = 1; i &lt; n; i++){ if(ans[i] == -1) ans[i] = now++; printf(&quot;%d\\n&quot;, ans[i]); } return 0;} D. Ehab the XorcistSolution我们有性质：$a\\oplus b \\leq a+b$，证明不难：$a+b$ 可以表达为 $a\\oplus b$ 作为当前位、$a&amp; b$ 作为进位，即 $a+b=a\\oplus b+((a&amp; b)&lt;&lt;1)$，所以加法比异或多了进位，当然更大。 $u&gt;v$ 时：由上述性质，无解； $u=v$ 时：特判掉 $u=v=0$ 的情况，然后输出 $u$ 就好； $u&lt;v$ 时： $v$ 奇 $u$ 偶，无解，因为 $u$ 只能分解为偶数个偶数和偶数个奇数之和，它们的异或一定是偶数； $v$ 偶 $u$ 奇，无解，因为 $u$ 只能分解为若干个偶数和奇数个奇数之和，它们的异或一定是奇数； $u,v$ 同奇偶，由于 $u,\\frac{v-u}{2},\\frac{v-u}{2}$ 是满足条件的解，但是若前两项可以合并（$u+\\frac{v-u}{2}=u\\oplus\\frac{v-u}{2}$），则合并后输出。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;LL u, v;int main(){ read(u, v); if(u &gt; v) return puts(&quot;-1&quot;), 0; if(u == 0 &amp;&amp; v == 0) return puts(&quot;0&quot;), 0; if(u == v){ puts(&quot;1&quot;); printf(&quot;%lld\\n&quot;, u); return 0; } if((v - u) % 2 == 0){ LL w = (v - u) &gt;&gt; 1; if(u + w == (u ^ w)){ puts(&quot;2&quot;); printf(&quot;%lld %lld\\n&quot;, u + w, w); } else{ puts(&quot;3&quot;); printf(&quot;%lld %lld %lld\\n&quot;, u, w, w); } return 0; } puts(&quot;-1&quot;); return 0;} E. Ehab’s REAL Number Theory ProblemSolution【参考官方题解】首先，如果一个数有完全平方因数，除掉后不影响答案。然后为方便起见，特判掉存在完全平方数或存在两个数相等的情况。 由于每个数最多 $7$ 个因数，所以每个数最多有 $2$ 个质因数，即每个数都只能是 $p$ 或 $p\\cdot q$ 两种情况（ $p,q$ 质数）。以所有质数和 $1$ 为点，对于 $p$ 连接 $1,p$ 两点，对于 $p\\cdot q$ 连接 $p,q$ 两点，则问题转化为寻找图中的最小环。从每个点分别 $bfs$ 可以求出包含这个点的最小环大小，但这是 $O(n^2)$ 的；事实上，我们只需要从数字小于 $\\sqrt{\\max(a_i})$ 的点出发 $bfs$ 即可，因为一个环一定包含数字小于 $\\sqrt{\\max(a_i)}$ 的点。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int N = 200005;const int M = 1000005;bool notP[M];int pList[M] = {0, 1}, pID = 1, fun[M] = {0, 1};void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i, fun[i] = pID; for(int j = 2; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0) break; } }}int n, a[N], ans = 1e9, maxx, dis[M];vector&lt;int&gt; edge[M];pii d[N];inline pii getDiv(int &amp;x){ pii res(0, 0); for(int i = 2; pList[i] * pList[i] &lt;= x; i++){ if(x % pList[i] == 0){ int cnt = 0; while(x % pList[i] == 0){ cnt ^= 1; x /= pList[i]; } if(cnt){ if(!res.first) res.first = pList[i]; else res.second = pList[i]; } } } if(x &gt; 1){ if(!res.first) res.first = x; else res.second = x; } if(res.first &amp;&amp; !res.second) res.second = res.first, res.first = 1; x = res.first * res.second; return res;}int main(){ Euler(1000000); read(n); for(int i = 1; i &lt;= n; i++){ read(a[i]); int sq = sqrt(a[i]); if(sq * sq == a[i]) return puts(&quot;1&quot;), 0; d[i] = getDiv(a[i]); maxx = max(maxx, a[i]); } sort(a+1, a+n+1); for(int i = 1; i &lt; n; i++) if(a[i] == a[i+1]) return puts(&quot;2&quot;), 0; for(int i = 1; i &lt;= n; i++) { int fi = fun[d[i].first], se = fun[d[i].second]; edge[fi].pb(se), edge[se].pb(fi); } for(int i = 1; pList[i] * pList[i] &lt;= maxx; i++){ for(int j = 1; j &lt;= pID; j++) dis[j] = -1; queue&lt;pii&gt; q; q.push(mp(i, 0)); dis[i] = 0; while(!q.empty()){ pii cur = q.front(); q.pop(); for(auto to: edge[cur.first]){ if(to == cur.second) continue; if(dis[to] == -1){ dis[to] = dis[cur.first] + 1; q.push(mp(to, cur.first)); } else ans = min(ans, dis[to] + dis[cur.first] + 1); } } } if(ans == 1e9) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;, ans); return 0;} F. Ehab’s Last TheoremSolution【参考官方题解】$dfs$ 并考虑 $dfs$ 树，若某祖先到当前点的路径与返祖边构成了一个长度大于等于 $\\lceil\\sqrt n\\rceil$ 的圈，输出即可；否则，当前点的返祖边一定不超过 $\\lceil\\sqrt n\\rceil-2$ 条，如果其邻域内其他点都没被纳入独立集里，就把它纳入独立集里。如此，若 $dfs$ 结束后没有找到圈，我们一定找到了足够大的独立集，因为每个点最多阻碍了 $\\lceil\\sqrt n\\rceil-1$ 个点。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)const int N = 100005;int n, m, sq;vector&lt;int&gt; ans;bool inans[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;2];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int dep[N], fa[N];void dfs(int x, int f, int depth){ dep[x] = depth, fa[x] = f; bool ok = true; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; if(dep[edge[i].to]){ if(dep[x] - dep[edge[i].to] + 1 &gt;= sq){ printf(&quot;2\\n%d\\n&quot;, dep[x] - dep[edge[i].to] + 1); int now = x; while(now != edge[i].to){ printf(&quot;%d &quot;, now); now = fa[now]; } printf(&quot;%d\\n&quot;, edge[i].to); exit(0); } } else dfs(edge[i].to, x, depth + 1); if(inans[edge[i].to]) ok = false; } if(ok) ans.push_back(x), inans[x] = 1;}int main(){ read(n, m); sq = ceil(sqrt(n)); for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); addEdge(u, v), addEdge(v, u); } dfs(1, 0, 1); puts(&quot;1&quot;); for(int i = 0; i &lt; sq; i++) printf(&quot;%d &quot;, ans[i]); return 0;}","link":"/blog-xcpc/2020/03/15/Codeforces-Round-628-Div-2/"},{"title":"Codeforces Round #631 (Div.2)","text":"比赛链接 / 官方题解链接 A. Dreamoon and Ranking CollectionSolution挨个枚举，有空就填，直到走不动且用光填补次数为止。 Code>folded1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1005;int T, n, x, a[N];bool b[N];int main(){ read(T); while(T--){ memset(b, 0, sizeof b); read(n, x); for(int i = 1; i &lt;= n; i++){ read(a[i]); b[a[i]] = 1; } int ans = 0; while(x){ while(b[ans+1]) ans++; x--; ans++; } while(b[ans+1]) ans++; printf(&quot;%d\\n&quot;, ans); } return 0;} B. Dreamoon Likes PermutationsSolution分别从前往后和从后往前遍历，不断统计累和。以从前往后为例，如果前 $i$ 个点没有重复数字且累和为 $\\frac{i(i+1)}{2}$，则这 $i$ 个数必是 $1\\sim i$ 的一个排列，在 $i$ 处打上标记；从后往前同理。如果连续两个点，前者有从前往后的标记，后者有从后往前的标记，则是一个解。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int T, n, a[N];bool p[N], q[N], e[N];int main(){ read(T); while(T--){ read(n); for(int i = 1; i &lt;= n; i++) p[i] = q[i] = e[i] = 0; LL sum = 0; for(int i = 1; i &lt;= n; i++) read(a[i]); bool rep = false; for(int i = 1; i &lt;= n; i++){ sum += a[i]; if(e[a[i]]) rep = true; e[a[i]] = true; if(!rep &amp;&amp; sum == 1ll * i * (i + 1) / 2) p[i] = true; } rep = false; sum = 0; for(int i = 1; i &lt;= n; i++) e[i] = 0; for(int i = n; i &gt;= 1; i--){ sum += a[i]; if(e[a[i]]) rep = true; e[a[i]] = true; if(!rep &amp;&amp; sum == 1ll * (n - i + 1) * (n - i + 2) / 2) q[i] = true; } vector&lt;pii&gt; ans; for(int i = 1; i &lt; n; i++) if(p[i] &amp;&amp; q[i+1]) ans.pb(mp(i, n-i)); printf(&quot;%d\\n&quot;, (int)ans.size()); for(auto k: ans) printf(&quot;%d %d\\n&quot;, k.first, k.second); } return 0;} C. Dreamoon Likes ColoringSolution我们可以先排除一些无解的情况： 如果所有区间长度之和小于 $n$，那肯定涂不完； 如果第 $i$ 个区间的长度大于 $n-i+1$，那么它一定会覆盖掉前 $i-1$ 个颜色中的某些颜色使颜色不全。 然后我们可以构造一种涂色方法：对于 $1\\leq i\\leq m$，把第 $i$ 个区间的起始点放在 $i$ 处。如此放完后第 $m$ 个区间到 $n$ 之间可能会有空隙，我们倒序依次往后移动区间把空隙填满即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, m, a[N];LL sum[N], mx[N], pos[N];int main(){ read(n, m); for(int i = 1; i &lt;= m; i++){ read(a[i]); sum[i] = a[i]; } for(int i = m; i &gt;= 1; i--) sum[i] += sum[i+1]; if(sum[1] &lt; n) return puts(&quot;-1&quot;), 0; for(int i = 1; i &lt;= m; i++) if(i + a[i] - 1 &gt; n) return puts(&quot;-1&quot;), 0; for(int i = 1; i &lt;= m; i++){ mx[i] = max(mx[i-1], 1ll * i + a[i] - 1); pos[i] = i; } int boun = n, now = m; while(now &amp;&amp; mx[now] &lt; boun){ pos[now] += boun - (pos[now] + a[now] - 1); boun = pos[now] - 1; now--; } if(pos[1] &gt; 1) return puts(&quot;-1&quot;); for(int i = 1; i &lt;= m; i++) printf(&quot;%lld &quot;, pos[i]); return 0;} D. Dreamoon Likes SequencesSolution假设 $a_i$ 的最高位 $1$ 是第 $k$ 位，我们有结论：$a_1,a_2,\\cdots,a_{i-1}$ 的最高位 $1$ 的位置一定小于 $k$，且 $a_{i+1},a_{i+2},\\cdots,a_n$ 的最高位 $1$ 的位置一定大于 $k$. 证明：由于 $a$ 递增，所以 $a_1,a_2,\\cdots,a_{i-1}$ 的最高位 $1$ 的位置最高等于 $k$，设 $a_j,a_r(j&lt;r\\leq i)$ 是第一、第二个第 $k$ 位是 $1$ 的数，那么 $b_j&gt;b_r$，不符合题意，所以 $a_i$ 是第一个最高位 $1$ 在 $k$ 的数，也就是 $a_1,a_2,\\cdots,a_{i-1}$ 的最高位 $1$ 的位置一定小于 $k$；类似的容易知道 $a_{i+1},a_{i+2},\\cdots,a_n$ 的最高位 $1$ 的位置一定大于 $k$. 换句话说，假设 $x$ 的第 $k$ 位为 $1$（ $2^k\\leq x\\leq 2^{k+1}-1$ ），在这个范围 $[2^k,2^{k+1}-1]$ 内的数只能不选或者选一个，一共 $1+2^k$ 种选法。 设 $lg=\\lfloor\\log_2d\\rfloor$，则对于 $0\\leq k&lt;lg$，每个 $k$ 有 $1+2^k$ 种选法；对于 $k=lg$，有 $d-2^{lg}+2$ 种选法。所以答案就是 $\\prod\\limits_{k=0}^{lg-1}(1+2^k)\\cdot(d-2^{lg}+2)-1$，减 $1$ 是因为全都不选（ $n=0$ ）的情况要删去。 Code>folded1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T;LL d, m;int main(){ read(T); while(T--){ read(d, m); LL lg = (int)log2(d); LL ans = 1, p = 1; for(LL i = 1; i &lt;= lg; i++, p &lt;&lt;= 1){ // p=2^(i-1) (ans *= (1 + p)) %= m; } (ans *= (1 + d - p + 1)) %= m; ans--; ((ans %= m) += m) %= m; printf(&quot;%lld\\n&quot;, ans); } return 0;} E. Drazil Liks HeapSolution贪心策略比较显然：能够选根节点则选择根节点，否则递归选择其左右子节点。所谓能够选的意思是，如果选了之后存在高度小于 $g$ 的点，则不能选。采用递归的方式写较为简便。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 3000005;int T, h, g;LL a[N];vector&lt;int&gt; ans;#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1int dis(int id){ if(a[lid] == 0 &amp;&amp; a[rid] == 0) return 1; if(a[lid] &gt; a[rid]) return dis(lid) + 1; else return dis(rid) + 1;}void f(int id){ if(a[lid] == 0 &amp;&amp; a[rid] == 0){ a[id] = 0; return; } if(a[lid] &gt; a[rid]){ a[id] = a[lid]; f(lid); } else{ a[id] = a[rid]; f(rid); }}void solve(int id, int dep){ if(a[id] == 0) return; while(dis(id) + dep - 1 &gt; g){ ans.emplace_back(id); f(id); } solve(lid, dep + 1); solve(rid, dep + 1);}int main(){ read(T); while(T--){ read(h, g); LL sum = 0; ans.clear(); for(int i = 1; i &lt;= (1 &lt;&lt; (h+1)); i++) a[i] = 0; for(int i = 1; i &lt; (1 &lt;&lt; h); i++) read(a[i]); solve(1, 1); for(int i = 1; i &lt; (1 &lt;&lt; g); i++) sum += a[i]; printf(&quot;%lld\\n&quot;, sum); for(auto k: ans) printf(&quot;%d &quot;, k); puts(&quot;&quot;); } return 0;}","link":"/blog-xcpc/2020/04/04/Codeforces-Round-631-Div-2/"},{"title":"Codeforces Round #632 (Div.2)","text":"比赛链接 / 官方题解链接 紫名留念！ A. Little ArtemSolution构造题，染色成棋盘，若 $n\\times m$ 是偶数就再挑一个白色染成黑色即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, m;int main(){ read(T); while(T--){ read(n, m); if((n * m) &amp; 1){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if((i + j) &amp; 1) putchar('W'); else putchar('B'); } puts(&quot;&quot;); } continue; } else{ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(i == 1 &amp;&amp; j == 1){ putchar('B'); continue; } if((i + j) &amp; 1) putchar('B'); else putchar('W'); } puts(&quot;&quot;); } continue; } } return 0;} B. Kind AntonSolution$\\forall i\\in[1,n]$： 若 $a[i]&lt;b[i]$，则必须 $\\exists j\\in[1,i-1] (a[j]=1)$； 若 $a[i]&gt;b[i]$，则必须 $\\exists j\\in[1,i-1] (a[j]=-1)$. 不满足上述条件输出 NO，满足输出 YES. Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n;LL a[N], b[N];bool e[10];int main(){ read(T); while(T--){ read(n); e[0] = e[1] = e[2] = 0; for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= n; i++) read(b[i]); bool ok = true; for(int i = 1; i &lt;= n; i++){ if(a[i] &lt; b[i]){ if(!e[2]){ ok = false; break; } } else if(a[i] &gt; b[i]){ if(!e[0]){ ok = false; break; } } e[a[i]+1] = 1; } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} C. Eugene and an arraySolution求出前缀和，逆序枚举区间左端点，需要求出值与当前节点相同的节点最小位置，并且与最小的 $0$ 区间右端点取 $\\min$，统计答案。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n;LL a[N], s[N], ans, mnpos;map&lt;LL, LL&gt; pos;int main(){ read(n); mnpos = n + 1; for(int i = 1; i &lt;= n; i++){ read(a[i]); s[i] = s[i-1] + a[i]; } for(int i = n; i &gt;= 1; i--){ pos[s[i]] = i; if(pos[s[i-1]] == 0) ans += mnpos - i; else{ mnpos = min(mnpos, pos[s[i-1]]); ans += mnpos - i; } } printf(&quot;%lld\\n&quot;, ans); return 0;} D. Challenges in school №41Solution每个 $L$ 都会与它前面的所有 $R$ 交换一次，所以最大时间就是最多交换次数 $=\\sum\\limits_{s[i]==L}i之前R的数量$， 如果 $k$ 大于这个数无解；然后我们按最小时间的方案模拟过程，即每个时间把所有相邻的 $RL$ 都给交换了。如果 $k$ 小于最小时间则无解，否则，把同一时间进行的操作拆开补满 $k$ 比最小时间多出来的部分。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 3005;int n, k, id;char s[N];LL maxk, mink;vi v, ans[N*N];int main(){ read(n, k); scanf(&quot;%s&quot;, s+1); LL cnt = 0; for(int i = 1; i &lt;= n; i++){ cnt += s[i] == 'R'; if(s[i] == 'L') maxk += cnt; } if(k &gt; maxk) return puts(&quot;-1&quot;), 0; for(int i = 1; i &lt; n; i++) if(s[i] == 'R' &amp;&amp; s[i+1] == 'L') v.pb(i); cnt = 0; while(!v.empty()){ id++; vi tmp; while(!v.empty()){ int cur = v.back(); v.pop_back(); ans[id].pb(cur); s[cur] = 'L', s[cur+1] = 'R'; if(s[cur+2] == 'L') tmp.pb(cur+1); if(s[cur-1] == 'R') tmp.pb(cur-1); } while(!tmp.empty()) v.pb(tmp.back()), tmp.pop_back(); } mink = id; if(k &lt; mink) return puts(&quot;-1&quot;), 0; k -= mink; for(int i = 1; i &lt;= id; i++){ while(k &amp;&amp; !ans[i].empty()){ printf(&quot;1 %d\\n&quot;, ans[i].back()); ans[i].pop_back(); if(!ans[i].empty()) k--; } if(!k &amp;&amp; !ans[i].empty()){ printf(&quot;%d &quot;, (int)ans[i].size()); for(auto t: ans[i]) printf(&quot;%d &quot;, t); puts(&quot;&quot;); } } return 0;} E. Road to 1600Solution【参看dls的视频讲解吧～：链接】 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int n, tot, ans[505][505];void solve(int m, int k){ if(m == 3){ ans[2][2] = ++tot, ans[2][3] = ++tot, ans[3][3] = ++tot; ans[3][1] = ++tot, ans[2][1] = ++tot, ans[1][3] = ++tot; ans[1][2] = ++tot, ans[1][1] = ++tot, ans[3][2] = ++tot; return; } if(!k){ for(int i = 1; i &lt;= m; i++) ans[m][i] = ++tot; for(int i = m-1; i &gt;= 1; i--) ans[i][m] = ++tot; if(m == 4) swap(ans[1][m], ans[2][m]); } else{ for(int i = 1; i &lt;= m; i++) ans[i][m] = ++tot; for(int i = m-1; i &gt;= 1; i--) ans[m][i] = ++tot; if(m == 4) swap(ans[m][1], ans[m][2]); } solve(m - 1, k ^ 1);}int main(){ read(n); if(n == 1 || n == 2) return puts(&quot;-1&quot;), 0; solve(n, 0); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++) printf(&quot;%d &quot;, ans[i][j]); puts(&quot;&quot;); } return 0;} F. Kate and imperfectionSolution【参考博客】首先把所有质数丢进集合，然后考虑加入合数，先加入与当前集合内的数的最大公因数为 $2$ 的所有合数，再加入最大公因数为 $3$ 的所有合数……于是每加入一个合数，答案就是其最大因数。处理出所有数的最大因数（质数为 $1$），排序后输出即可。 Code>folded123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 500005;int n, ans[N];int main(){ read(n); for(int k = 2; k &lt;= n; k++){ if(!ans[k]) ans[k] = 1; for(int j = 2; k * j &lt;= n; j++) ans[k*j] = k; } sort(ans+2, ans+n+1); for(int i = 2; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); return 0;}","link":"/blog-xcpc/2020/04/09/Codeforces-Round-632-Div-2/"},{"title":"Codeforces Round #633 (Div.2)","text":"比赛链接 / 官方题解链接 A. Filling DiamondsSolution发现一旦放置一个竖着的菱形，那么它的两边其他菱形的放置方式就固定了，所以答案就是 $n$. Code>folded123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n;int main(){ read(T); while(T--){ read(n); printf(&quot;%d\\n&quot;, n); } return 0;} B. Sorted Adjacent DifferencesSolution排序后从两头交叉着取数，再反转，则一定满足条件。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n;LL a[N], b[N];int main(){ read(T); while(T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1); int l = 1, r = n, id = 0; while(1){ b[++id] = a[l]; if(l == r) break; l++; b[++id] = a[r]; if(l == r) break; r--; } reverse(b+1, b+id+1); for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, b[i]); puts(&quot;&quot;); } return 0;} C. Powered AdditionSolution依次考虑每个数，把它用最少的时间补成最小的不低于前一个数的数。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n;LL a[N], power[N] = {1};int main(){ for(int i = 1; i &lt;= 35; i++) power[i] = power[i-1] * 2; read(T); while(T--){ LL ans = 0; read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 2; i &lt;= n; i++){ LL diff = a[i-1] - a[i]; if(diff &lt;= 0) continue; LL tim = (LL)log2(diff) + 1; ans = max(ans, tim); a[i] += power[tim] - 1; for(int j = tim; j &gt;= 1; j--) if(a[i] - power[j-1] &gt;= a[i-1]) a[i] -= power[j-1]; } printf(&quot;%lld\\n&quot;, ans); } return 0;} D. Edge Weight AssignmentSolution任选一个叶节点为根，我们只需要满足条件：所有其他叶节点到根的路径上异或和为 $0$ 即可。容易证明满足这个条件后任意两个叶节点之间的路径上异或和一定为 $0$. 首先考虑最少数字： 若其他叶节点到根的距离均为偶数，那么容易知道，任意两个叶节点之间的距离一定都是偶数，所以所有边都赋值为同一个数就能满足条件；若存在到根的距离为奇数的叶节点，我们一定可以用 $1,2,3$ 这三个数赋值满足条件（$2$ 个数不可能，因为凡用 $2$ 个数满足条件的一定用 $1$ 个数就够了），因为，假想我们 $dfs$ 这棵树，只要下一个点不是叶节点就赋值 $1,2,3$ 中的一个并保证前缀异或和不为 $0$，而若下一个点是叶节点就赋值为前缀异或和，这样就能满足条件。 然后考虑最多数字： $dfs$ 这棵树，只要下一个点不是叶节点就赋值为 $(1&lt;&lt;k)$，其中 $k$ 是从 $0$ 开始的某个之前没有用过的数，而若下一个点是叶节点就赋值为前缀异或和。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, deg[N], k;vi edge[N];int dis[N], cnt[N];void dfs(int x, int f, int d){ dis[x] = d; if(deg[x] != 1) k++; else cnt[f]++; for(auto nxt: edge[x]){ if(nxt == f) continue; dfs(nxt, x, d + 1); }}int main(){ read(n); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); edge[u].pb(v); edge[v].pb(u); deg[u]++, deg[v]++; } int rt = 0; for(rt = 1; rt &lt;= n; rt++) if(deg[rt] == 1) break; dfs(rt, 0, 0); bool allEven = true; for(int i = 1; i &lt;= n; i++){ if(deg[i] == 1 &amp;&amp; dis[i] &amp; 1){ allEven = false; break; } } printf(allEven ? &quot;1 &quot; : &quot;3 &quot;); cnt[edge[rt][0]]++; for(int i = 1; i &lt;= n; i++) k += cnt[i] &gt; 0; printf(&quot;%d\\n&quot;, k - 1); return 0;} E. Perfect Triples比赛时找了个假的规律，结束前2分钟交上去，于是愉快地WA了…… Solution找规律，三元组的第一个数很容易发现规律，然后第二个数应该是——第一个数的四进制表示中，$0$ 换成 $0$，$1$ 换成 $2$，$2$ 换成 $3$，$3$ 换成 $1$，第三个数就是前两个的异或。 Code沿用了部分比赛时的代码，所以很丑…… >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL n, power[40] = {1};inline LL lg4(LL x){ int p = lower_bound(power, power+32, x) - power; if(power[p] &gt; x) p--; return p;}int main(){ for(int i = 1; i &lt;= 31; i++) power[i] = power[i-1] * 4; read(T); while(T--){ read(n); LL g = lg4(n); // start with 4^g LL w = 0; // which col w = n % 3; if(!w) w = 3; LL r = 0; // which row r = (n - power[g] + 1) / 3; if((n-power[g]+1) % 3) r++; LL blo = r / 4; if(r % 4) blo++; // which block LL z = r % 4; if(!z) z = 4; // which subrow LL a = power[g] + (blo - 1) * 4; a += z - 1; LL b = a; for(int i = 0; (b &gt;&gt; i); i += 2){ int x = ((b &gt;&gt; i) &amp; 1) | (((b &gt;&gt; (i+1)) &amp; 1) &lt;&lt; 1); if(x == 1) b ^= (1ll &lt;&lt; i), b ^= (1ll &lt;&lt; (i+1)); else if(x == 2) b ^= (1ll &lt;&lt; i); else if(x == 3) b ^= (1ll &lt;&lt; (i+1)); } LL c = a ^ b; printf(&quot;%lld\\n&quot;, w == 1 ? a : (w == 2 ? b : c)); } return 0;}","link":"/blog-xcpc/2020/04/13/Codeforces-Round-633-Div-2/"},{"title":"Codeforces Round #630 (Div.2)","text":"比赛链接 / 官方题解链接 A. Exercising WalkSolution左右方向和上下方向分别考虑，以 $a&gt;b$ 为例，最优走法显然是 左-右-左-右-……，所以终止位置在初始位置左边 $a-b$ 处，其余方向同理。 注意特判一步都不能走的情况。 Code>folded12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T, a, b, c, d, x, y, x_1, y_1, x_2, y_2;int main(){ read(T); while(T--){ read(a, b, c, d); read(x, y, x_1, y_1, x_2, y_2); if(x - (a - b) &lt; x_1 || x - (a - b) &gt; x_2) puts(&quot;NO&quot;); else if(y - (c - d) &lt; y_1 || y - (c - d) &gt; y_2) puts(&quot;NO&quot;); else if(a == b &amp;&amp; a &gt; 0 &amp;&amp; x_1 == x_2) puts(&quot;NO&quot;); else if(c == d &amp;&amp; c &gt; 0 &amp;&amp; y_1 == y_2) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } return 0;} B. Composite ColoringSolution把每个数染成其最小质因数的颜色，小于 $\\sqrt{1000}$ 的质数正好 $11$ 个。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1005;int T, n, a, col[N], id;int p[15] = {-1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};int c[15];int main(){ read(T); while(T--){ id = 0; memset(col, 0, sizeof col); memset(c, 0, sizeof c); read(n); for(int i = 1; i &lt;= n; i++){ read(a); for(int j = 1; j &lt;= 11; j++){ if(a % p[j] == 0){ if(c[j]) col[i] = c[j]; else col[i] = c[j] = ++id; break; } } } printf(&quot;%d\\n&quot;, id); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, col[i]); puts(&quot;&quot;); } return 0;} C. K-Complete WordSolution周期性+对称性=一个周期内部对称。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int T, n, k, cnt[30];char s[N];int main(){ read(T); while(T--){ read(n, k); scanf(&quot;%s&quot;, s+1); int ans = 0; for(int i = 1; i &lt;= (k + 1) / 2; i++){ int tot = 0; memset(cnt, 0, sizeof cnt); for(int j = i; j &lt;= n; j += k) cnt[s[j]-'a']++, tot++; if(i != k - i + 1){ for(int j = k - i + 1; j &lt;= n; j += k) cnt[s[j]-'a']++, tot++; } int mark = -1, mx = -1; for(int j = 0; j &lt;= 'z'-'a'; j++){ if(mx &lt; cnt[j]){ mark = j; mx = cnt[j]; } } ans += tot - mx; } printf(&quot;%d\\n&quot;, ans); } return 0;} D. Walk on MatrixSolution设 $k$ 有 $b$ 位，$kk=(1&lt;&lt;b)|k$， 我构造的是：$\\begin{pmatrix} kk &amp; k &amp; 0\\ kk &amp; k &amp; 0\\ 1&lt;&lt;b &amp; kk &amp; k \\\\end{pmatrix}$. 但事实上，$\\begin{pmatrix} 2^{17}+k &amp; 2^{17} &amp; 0\\ k &amp; 2^{17}+k &amp; k\\ \\end{pmatrix}$ 足以。 Code>folded123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int main(){ int k; read(k); if(!k){ puts(&quot;1 1&quot;); puts(&quot;1&quot;); return 0; } int b = 0; while((k &gt;&gt; b) != 0) b++; int kk = (1 &lt;&lt; b) | k; puts(&quot;3 3&quot;); printf(&quot;%d %d %d\\n&quot;, kk, k, 0); printf(&quot;%d %d %d\\n&quot;, kk, k, 0); printf(&quot;%d %d %d\\n&quot;, 1 &lt;&lt; b, kk, k); return 0;} E. Height All the SameSolution手玩一些例子，可以发现一些结论： 高度不重要，奇偶性是关键，所以我们在推结论时可以想象成平面上凸起一些高度为 $1$ 的小块。 若 $n\\cdot m$ 为奇数，无论初始情况是怎么样的，都可以达到目标。 若 $n\\cdot m$ 为偶数，若平面上凸起小块是奇数个，无法达成目标；否则，一定可以达成目标。 所以，对于奇数情况，答案就是 $(R-L+1)^{nm}$；对于偶数情况，我们要保证初始时所有高度之和为偶数，即选出偶数个位置放奇数，剩下偶数个位置放偶数。设 $[L,R]$ 内有 $a$ 个奇数，$b$ 个偶数，则答案为 $\\sum\\limits_{i=0}^{\\frac{nm}{2}}C_{nm}^{2i}a^{2i}b^{nm-2i}=\\frac{(b+a)^{nm}+(b-a)^{nm}}{2}$. Code>folded123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const LL MOD = 998244353;LL n, m, L, R;inline LL fpow(LL bs, LL idx){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int main(){ read(n, m, L, R); if((n * m) &amp; 1) printf(&quot;%lld\\n&quot;, fpow(R - L + 1, n * m)); else{ LL a = (R - L + 1) / 2 + ((R - L + 1) % 2 &amp;&amp; L % 2); LL b = (R - L + 1) / 2 + ((R - L + 1) % 2 &amp;&amp; L % 2 == 0); printf(&quot;%lld\\n&quot;, (fpow(b - a, n * m) + fpow(b + a, n * m)) * (MOD + 1) / 2 % MOD); } return 0;}","link":"/blog-xcpc/2020/04/01/Codeforces-Round-630-Div-2/"},{"title":"Codeforces Round 635 (Div.2)","text":"比赛链接 / 官方题解链接 A. Ichihime and TriangleSolution用 $b,c,c$ 一定能构成三角形。 Code>folded1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, a, b, c, d;int main(){ for(read(T); T; T--){ read(a, b, c, d); printf(&quot;%d %d %d\\n&quot;, b, c, c); } return 0;} B. Kana and Dragon Quest gameSolution能用第一种操作就用第一种操作，否则用第二种操作。因为如果对于一个数，用第一种操作不能使之减小，那么对于小于它的数，用第一种操作更不可能使之减小。 Code>folded1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, x, n, m;int main(){ for(read(T); T; T--){ read(x, n, m); while(n--){ if(x / 2 + 10 &lt; x) x = x / 2 + 10; else break; } x -= 10 * m; puts(x &gt; 0 ? &quot;NO&quot; : &quot;YES&quot;); } return 0;} C. Linova and KingdomSolution首先观察出一个结论：如果一个点被选了，那么它的子树所有点一定都会被选，否则的话，选子树中的点显然比选它更优。 于是乎，如果我们现在选了点 $x$，那么答案加上 $dep[x]-(sz[x]-1)$，其中 $dep[x]$ 表示 $x$ 的深度，$sz[x]$ 表示 $x$ 子树大小。所以要使答案最大，把所有点按照 $dep[x]-(sz[x]-1)$ 降序排序即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, k;LL ans;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}struct Node{ LL dep, sz; bool operator &lt; (const Node &amp;A) const{ return dep - sz + 1 &gt; A.dep - A.sz + 1; }}a[N];void dfs(int x, int f, LL depth){ a[x].dep = depth; a[x].sz = 1; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth+1); a[x].sz += a[edge[i].to].sz; }}int main(){ read(n, k); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); addEdge(u, v); addEdge(v, u); } dfs(1, 0, 0); sort(a+1, a+n+1); for(int i = 1; i &lt;= k; i++) ans += a[i].dep - a[i].sz + 1; printf(&quot;%lld\\n&quot;, ans); return 0;} D. Xenia and Colorful GemsSolution固定 $z$，二分找到 $z$ 的左右最近的 $x,y$，更新答案。 根据 $x,y,z$ 的轮换对称性，做 $3$ 次上述过程。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;LL ans;inline void solve(LL x[], LL y[], LL z[], int nx, int ny, int nz){ for(int k = 1; k &lt; nz; k++){ vector&lt;LL&gt; X, Y; int j = lower_bound(y+1, y+ny+1, z[k]) - y; if(j &gt; 1) Y.pb(y[j-1]); if(j &lt; ny) Y.pb(y[j]); int i = lower_bound(x+1, x+nx+1, z[k]) - x; if(i &gt; 1) X.pb(x[i-1]); if(i &lt; nx) X.pb(x[i]); for(auto xx: X) for(auto yy: Y) ans = min(ans, (xx-yy)*(xx-yy) + (yy-z[k])*(yy-z[k]) + (z[k]-xx)*(z[k]-xx)); }}int T, nx, ny, nz;LL x[N], y[N], z[N];int main(){ for(read(T); T; T--){ read(nx, ny, nz); ans = 2e18; for(int i = 1; i &lt;= nx; i++) read(x[i]); for(int i = 1; i &lt;= ny; i++) read(y[i]); for(int i = 1; i &lt;= nz; i++) read(z[i]); sort(x+1, x+nx+1); nx = unique(x+1, x+nx+1) - (x+1); sort(y+1, y+ny+1); ny = unique(y+1, y+ny+1) - (y+1); sort(z+1, z+nz+1); nz = unique(z+1, z+nz+1) - (z+1); x[++nx] = 1e16, y[++ny] = 1e16, z[++nz] = 1e16; solve(x, y, z, nx, ny, nz); solve(y, z, x, ny, nz, nx); solve(z, x, y, nz, nx, ny); printf(&quot;%lld\\n&quot;, ans); } return 0;} E. Kaavi and Magic SpellSolution区间 $dp$. 设 $dp[i][j]$ 表示用 $s[1…j-i+1]$ 匹配了 $t[i…j]$ 这一段字符的方案数，其中，超过 $m$ 的部分任意字符都算作匹配。那么容易写出 $dp$ 方程。 答案就是 $\\sum\\limits_{i=m}^ndp[1][i]$. Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 3005;const LL MOD = 998244353;int n, m, pt;char s[N], t[N];LL dp[N][N];int main(){ scanf(&quot;%s&quot;, s+1); scanf(&quot;%s&quot;, t+1); n = strlen(s+1), m = strlen(t+1); for(int i = 1; i &lt;= n+1; i++) dp[i][i-1] = 1; for(int l = 1; l &lt;= n; l++){ for(int i = 1; i &lt;= n; i++){ int j = i + l - 1; if(j &gt; n) break; if(s[l] == t[j] || j &gt; m) (dp[i][j] += dp[i][j-1]) %= MOD; if(s[l] == t[i] || i &gt; m) (dp[i][j] += dp[i+1][j]) %= MOD; } } LL ans = 0; for(int i = m; i &lt;= n; i++) (ans += dp[1][i]) %= MOD; printf(&quot;%lld\\n&quot;, ans); return 0;} F. Yui and Mahjong SetSolution【参考官方题解】题解讲的挺清楚了，下面仅仅写一写式子罢了。 按照 $n-1,n-2,\\cdots,4,3,1,2,1$ 的顺序询问，记录下每次回答的差值 $d_1[i],d_2[i]$，那么： 最后一次询问中，$d_1[0]=C_{a_1+1}^2=\\cfrac{(a_1+1)a_1}{2}$， 所以 $a_1=\\lfloor\\sqrt{d_1[0]\\times2}\\rfloor$. 对于两次询问 $1$，有：$d_2[0]=(a_2+1)(a_3+1),d_2[2]=a_2(a_3+1)$， 所以 $a_3=d_2[0]-d_2[2]-1,a_2=\\cfrac{d_2[2]}{a_3+1}$. 对于询问 $2$，有：$d_2[1]=(a_1+1)(a_3+1)+(a_4+1)(a_3+1)$， 所以 $a_4=\\cfrac{d_2[1]-(a_1+1)(a_3+1)}{a_3+1}-1$. 对于询问 $i(3\\leq i&lt;n-2)$，有：$d_2[i]=a_{i-1}(a_{i+1}+1)+(a_{i+1}+1)(a_{i+2}+1)+a_{i-2}a_{i-1}$， 所以 $a_{i+2}=\\cfrac{d_2[i]-a_{i-1}(a_{i+1}+1)-a_{i-2}a_{i-1}}{a_{i+1}+1}-1$. 对于询问 $n-2$，有：$d_2[n-2]=a_{n-3}(a_{n-1}+1)+(a_{n-1}+1)a_n+a_{n-4}a_{n-3}$， 所以 $a_n=\\cfrac{d_2[n-2]-a_{n-3}(a_{n-1}+1)-a_{n-4}a_{n-3}}{a_{n-1}+1}$. Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int n, a[105];int s1[105], s2[105], d1[105], d2[105];int main(){ read(n, s1[0], s2[0]); for(int i = n - 1; i &gt;= 0; i--){ if(i &lt;= 2) printf(&quot;+ %d\\n&quot;, i % 2 ? 2 : 1); else printf(&quot;+ %d\\n&quot;, i); fflush(stdout); read(s1[i], s2[i]); d1[i] = s1[i] - s1[i+1]; d2[i] = s2[i] - s2[i+1]; } a[1] = sqrt(2 * d1[0]); a[3] = d2[0] - d2[2] - 1; a[2] = d2[2] / (a[3] + 1); a[4] = (d2[1] - (a[3] + 1) * (a[1] + 1)) / (a[3] + 1) - 1; for(int i = 3; i &lt;= n - 2; i++) a[i+2] = (d2[i] - a[i-2] * a[i-1] - a[i-1] * (a[i+1] + 1)) / (a[i+1] + 1) - 1; a[n]++; printf(&quot;! &quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); puts(&quot;&quot;); fflush(stdout); return 0;}","link":"/blog-xcpc/2020/04/16/Codeforces-Round-635-Div-2/"},{"title":"Codeforces Round #637 (Div.2)","text":"比赛链接 / 官方题解链接 A. Nastya and RiceSolution只要 $[n(a-b),n(a+b)]$ 和 $[c-d,c+d]$ 有交即可。 Code>folded12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, a, b, c, d;int main(){ for(read(T); T; T--){ read(n, a, b, c, d); int l = n * (a - b), r = n * (a + b); if(c + d &gt;= l &amp;&amp; c - d &lt;= r) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0;} B. Nastya and DoorSolution前缀和预处理，枚举左端点。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int T, n, k;LL a[N], p[N], s[N];int main(){ for(read(T); T; T--){ read(n, k); a[0] = a[n+1] = 1e16; for(int i = 1; i &lt;= n; i++){ read(a[i]); p[i] = s[i] = 0; } for(int i = 1; i &lt;= n; i++){ if(a[i] &gt; a[i-1] &amp;&amp; a[i] &gt; a[i+1]) p[i] = 1; s[i] = p[i] + s[i-1]; } LL mx = -1, mark = 0; for(int i = 1; i &lt;= n; i++){ int j = i + k - 1; if(j &gt; n) break; LL cnt = s[j] - s[i-1]; if(p[i]) cnt--; if(p[j]) cnt--; if(cnt &gt; mx) mx = cnt, mark = i; } printf(&quot;%lld %lld\\n&quot;, mx + 1, mark); } return 0;} C. Nastya and Strange GeneratorSolution容易发现这个生成器生成的数字一定可以分成多段，每一段都是连续的数字。 Code>folded12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, p[N];int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(p[i]); bool ok = true; for(int i = 2; i &lt;= n; i++){ if(p[i] &lt; p[i-1]) continue; else if(p[i] &gt; p[i-1] + 1){ ok = false; break; } } puts(ok ? &quot;Yes&quot; : &quot;No&quot;); } return 0;} D. Nastya and ScoreboardSolution容易想到的一个 $dp$ 是：$dp[i][j]$ 表示前 $i$ 个数点亮了 $j$ 根管子的最大数值，但是这样做的话，$dp$ 数组需要开成字符串类型，而字符串的比较是 $O(n)$ 的，会 $TLE$. 正解是结合一下贪心和 $dp$：设 $dp[i][j]$ 表示从后往前的 $i$ 个数能否在点亮 $j$ 根管子后形成数字，这样 $dp$ 就是 $O(n^2)$ 的。至于从后往前，那是因为我们接下来就可以从前往后贪心地求出答案了。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2005;int n, k;string digits[20], a[N];int dis[N][10];bool can[N][N];inline int dist(int x, string s){ string sx = digits[x]; int res = 0; for(int i = 0; i &lt; 7; i++){ if(sx[i] == s[i]) continue; if(sx[i] == '0' &amp;&amp; s[i] == '1') return 1e9; else if(sx[i] == '1' &amp;&amp; s[i] == '0') res++; } return res;}int main(){ read(n, k); digits[0] = &quot;1110111&quot;; digits[1] = &quot;0010010&quot;; digits[2] = &quot;1011101&quot;; digits[3] = &quot;1011011&quot;; digits[4] = &quot;0111010&quot;; digits[5] = &quot;1101011&quot;; digits[6] = &quot;1101111&quot;; digits[7] = &quot;1010010&quot;; digits[8] = &quot;1111111&quot;; digits[9] = &quot;1111011&quot;; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; a[i]; for(int j = 0; j &lt;= 9; j++) dis[i][j] = dist(j, a[i]); } can[n+1][0] = true; for(int i = n; i &gt;= 1; i--) for(int num = 0; num &lt;= 9; num++) for(int j = dis[i][num]; j &lt;= k; j++) can[i][j] |= can[i+1][j-dis[i][num]]; if(can[1][k] == false) puts(&quot;-1&quot;); else{ for(int i = 1; i &lt; n; i++){ for(int num = 9; num &gt;= 0; num--){ if(k &gt;= dis[i][num] &amp;&amp; can[i+1][k-dis[i][num]]){ k -= dis[i][num]; putchar(num + '0'); break; } } } for(int num = 9; num &gt;= 0; num--){ if(dis[n][num] == k){ printf(&quot;%d\\n&quot;, num); break; } } } return 0;} E. Nastya and Unexpected GuestSolution【参考官方题解】我们把“在模 $g$ 余 $j$ 的时刻到达第 $i$ 个安全岛”看做一个状态，那么不同状态之间就可以连上不同边权的边（边权即花费的时间），最短路就是答案。但是这样做复杂度太高。 重新定义边权为：到达当前状态经过的“绿灯-红灯”轮数。那么边权只是 $0$ 或者 $1$，要求得最短路，我们只需要进行 $01bfs$，即使用双端队列代替 dijkstra 的优先队列，边权是 $0$ 就从前插入，边权是 $1$ 就从后插入，仍然维护了队列的单调性，且复杂度降低到 $O(n)$. Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int M = 10005;int n, m, d[M], g, r;LL dp[M][1005], ans = 1e16;bool vis[M][1005];void bfs(){ deque&lt;pii&gt; q; // first: pos; second: time q.push_front(mp(1, 0)); vis[1][0] = 1; while(!q.empty()){ pii cur = q.front(); q.pop_front(); if(cur.second == 0) if(n - d[cur.first] &lt;= g) ans = min(ans, dp[cur.first][cur.second] * (g + r) + n - d[cur.first]); if(cur.second == g){ if(!vis[cur.first][0]){ dp[cur.first][0] = dp[cur.first][cur.second] + 1; vis[cur.first][0] = 1; q.push_back(mp(cur.first, 0)); } continue; } if(cur.first &gt; 1){ int v = d[cur.first] - d[cur.first-1] + cur.second; if(v &lt;= g &amp;&amp; !vis[cur.first-1][v]){ dp[cur.first-1][v] = dp[cur.first][cur.second]; vis[cur.first-1][v] = 1; q.push_front(mp(cur.first-1, v)); } } if(cur.first &lt; m){ int v = d[cur.first+1] - d[cur.first] + cur.second; if(v &lt;= g &amp;&amp; !vis[cur.first+1][v]){ dp[cur.first+1][v] = dp[cur.first][cur.second]; vis[cur.first+1][v] = 1; q.push_front(mp(cur.first+1, v)); } } }}int main(){ read(n, m); for(int i = 1; i &lt;= m; i++) read(d[i]); sort(d+1, d+m+1); read(g, r); bfs(); if(ans == 1e16) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;, ans); return 0;} F. Nastya and Time MachineSolution参考博客：链接 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, mxdeg, deg[N];vi edge[N];vector&lt;pii&gt; ans;void dfs(int x, int f, int t){ ans.pb(mp(x, t)); if(t == mxdeg){ t = mxdeg - deg[x]; ans.pb(mp(x, t)); } for(auto to: edge[x]){ if(to == f) continue; dfs(to, x, t + 1); t++; if(ans.back().second != t - 1) ans.pb(mp(to, t - 1)); ans.pb(mp(x, t)); if(f &amp;&amp; t == mxdeg){ t = mxdeg - deg[x]; ans.pb(mp(x, t)); } }}int main(){ read(n); if(n == 1){ puts(&quot;1&quot;); puts(&quot;1 0&quot;); return 0; } for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); deg[u]++, deg[v]++; mxdeg = max(mxdeg, deg[u]); mxdeg = max(mxdeg, deg[v]); } dfs(1, 0, 0); printf(&quot;%d\\n&quot;, (int)ans.size()); for(auto k: ans) printf(&quot;%d %d\\n&quot;, k.first, k.second); return 0;}","link":"/blog-xcpc/2020/04/24/Codeforces-Round-637-Div-2/"},{"title":"Codeforces Round #639 (Div.2)","text":"比赛链接 / 官方题解链接 这场出题人真惨～ A. Puzzle PiecesSolution若 $n=1$ 或 $m=1$ 或 $n=m=2$，那么可行；否则不可行，因为无法拼出 $2\\times3$ 的格子。 Code>folded1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, m;int main(){ for(read(T); T; T--){ read(n, m); if(n == 1) puts(&quot;YES&quot;); else if(m == 1) puts(&quot;YES&quot;); else if(n == 2 &amp;&amp; m == 2) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0;} B. Card ConstructionsSolution可以推导出通项公式：$a_n=\\frac{3n^2+n}{2}$，那么不断二分最大金字塔数量。 Code>folded12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)LL a[100005];int T, n;int main(){ int id = 0; for(int i = 1; i &lt;= 100000; i++){ a[++id] = (3ll * i * i + i) / 2; if(a[id] &gt; 1e9) break; } for(read(T); T; T--){ read(n); int ans = 0; while(n){ int p = lower_bound(a+1, a+id, n) - a; if(a[p] &gt; n) p--; if(p == 0) break; n -= a[p]; ans++; } printf(&quot;%d\\n&quot;, ans); } return 0;} C. Hilbert’s HotelSolution如果 $0\\sim n-1$ 在变换后恰好占据了模 $n$ 的不同余数的位置，那么可行；否则不可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int T, n, a[N], s[N];int main(){ for(read(T); T; T--){ read(n); memset(s, 0, sizeof s); for(int i = 0; i &lt; n; i++){ read(a[i]); int res = ((i + a[i]) % n + n) % n; s[res]++; } bool b = true; for(int i = 0; i &lt; n; i++) if(s[i] != 1){ b = false; break; } if(b) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0;} D. Monopole MagnetsSolution如果某一行或某一列有间隔的黑块，那么一定无解——因为这一行必须要放一个 $S$，而这个 $S$ 可以把走到黑块上的 $N$ 勾引到白块上去。 如果某一行是全白色，那么必须要有一列也是全白色，否则这一行放不了 $S$；某一列全白色同理。 上述两个条件满足后，只需要在所有黑块上放 $S$，那么在每个黑色连通块上放一个 $N$ 就可以了。所以答案就是黑色连通块的个数。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int n, m;char g[N][N];int l[N][N], u[N][N];bool brow[N], bcol[N];int fa[N*N];int findfa(int x){ return fa[x] == x ? x : fa[x] = findfa(fa[x]); }inline void unionn(int x, int y){ if(findfa(x) != findfa(y)) fa[findfa(y)] = findfa(x);}int main(){ read(n, m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, g[i] + 1); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(j == 1) l[i][j] = 0; else l[i][j] = g[i][j-1] == '#' ? j-1 : l[i][j-1]; if(i == 1) u[i][j] = 0; else u[i][j] = g[i-1][j] == '#' ? i-1 : u[i-1][j]; if(g[i][j] == '#'){ if(l[i][j] != 0 &amp;&amp; l[i][j] != j-1) return puts(&quot;-1&quot;), 0; if(u[i][j] != 0 &amp;&amp; u[i][j] != i-1) return puts(&quot;-1&quot;), 0; brow[i] = bcol[j] = true; } } } for(int i = 1; i &lt;= n; i++){ if(brow[i] == false){ bool ok = false; for(int j = 1; j &lt;= m; j++) if(bcol[j] == false) ok = true; if(!ok) return puts(&quot;-1&quot;), 0; } } for(int j = 1; j &lt;= m; j++){ if(bcol[j] == false){ bool ok = false; for(int i = 1; i &lt;= n; i++) if(brow[i] == false) ok = true; if(!ok) return puts(&quot;-1&quot;), 0; } } for(int i = 1; i &lt;= n*m; i++) fa[i] = i; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ int p = (i - 1) * m + j; if(g[i][j] == '.') continue; if(i &gt; 1 &amp;&amp; g[i-1][j] == '#') unionn(p, p-m); if(i &lt; n &amp;&amp; g[i+1][j] == '#') unionn(p, p+m); if(j &gt; 1 &amp;&amp; g[i][j-1] == '#') unionn(p, p-1); if(j &lt; m &amp;&amp; g[i][j+1] == '#') unionn(p, p+1); } } int cnt = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cnt += g[i][j] == '#' &amp;&amp; findfa((i-1)*m+j) == (i-1)*m+j; printf(&quot;%d\\n&quot;, cnt); return 0;} E. Quantifier QuestionSolution如果对于条件 $a&lt;b$，我们连一条从 $a$ 到 $b$ 的有向边，那么得到了一个有向图。如果该有向图有环，那么显然无解；否则该有向图是一个 $DAG$. 对于每一个点，我们可以通过拓扑序和逆拓扑序得到与它具有比较关系的最小编号，如果这个最小编号小于它本身，那么这个点必须填 $\\exists$，否则填 $\\forall$. Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, m;char ans[N];vi edge[2][N];int ind[2][N];int mn[2][N], tot;void topo(int k){ queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!ind[k][i]) q.push(i); while(!q.empty()){ int cur = q.front(); q.pop(); tot++; for(auto to: edge[k][cur]){ ind[k][to]--; mn[k][to] = min(mn[k][to], mn[k][cur]); if(!ind[k][to]) q.push(to); } }}int main(){ read(n, m); for(int i = 1; i &lt;= m; i++){ int j, k; read(j, k); edge[0][j].pb(k); ind[0][k]++; edge[1][k].pb(j); ind[1][j]++; } for(int i = 1; i &lt;= n; i++) mn[0][i] = mn[1][i] = i; topo(0); if(tot &lt; n){ puts(&quot;-1&quot;); return 0; } topo(1); int cnt = 0; for(int i = 1; i &lt;= n; i++){ if(mn[0][i] == i &amp;&amp; mn[1][i] == i) ans[i] = 'A', cnt++; else ans[i] = 'E'; } printf(&quot;%d\\n&quot;, cnt); for(int i = 1; i &lt;= n; i++) putchar(ans[i]); puts(&quot;&quot;); return 0;} F. Résumé ReviewSolution【参考官方题解】如果我们将第 $i$ 个数从 $x-1$ 增加到 $x$，那么答案增量为：$$\\Delta_i(x)=x(a_i-x^2)-(x-1)\\left[a_i-(x-1)^2\\right]=a_i-3x^2+3x-1$$这是一个关于 $x$ 的递减函数。如果正向考虑，我们需要每次找到最大的增量，使该数加一，但是这肯定超时。正向麻烦时考虑反向——我们二分一个增量下限 $A$，对 $1\\sim n$ 的每一个数来说，只要增量大于等于 $A$，就往上加——这一点可以二分上述公式中的 $x$ 完成。统计我们加的数 $cnt$，如果 $cnt&gt;=k$，那么增大下限 $A$，使 $cnt$ 减小；否则减小下限 $A$，使 $cnt$ 增大。如此二分可以最终找到最大增量下限 $A$ 使得 $cnt$ 刚好大于或等于 $k$. 如果 $cnt=k$，那便是极好的；如果 $cnt&gt;k$，我们一定可以找到一些数，它们的最后一个增量恰好等于 $A$——否则的话这个 $A$ 还可以增大，就不是最大增量下限了。对于这些数，我们往回撤销掉它们的增量，直到 $cnt=k$. Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n;LL k, a[N], b[N], cnt;vi v;bool check(LL A){ cnt = 0; v.clear(); for(int i = 1; i &lt;= n; i++){ if(a[i] - 1 &lt; A){ b[i] = 0; continue; } LL l = 1, r = a[i]; while(l &lt; r){ LL mid = (l + r + 1) / 2; if(a[i] - 3 * mid * mid + 3 * mid - 1 &gt;= A) l = mid; else r = mid - 1; } b[i] = l; cnt += l; if(a[i] - 3 * l * l + 3 * l - 1 == A) v.pb(i); } return cnt &gt;= k;}int main(){ read(n, k); for(int i = 1; i &lt;= n; i++) read(a[i]); LL L = -4e18, R = 1e9; while(L &lt; R){ LL mid = (L + R + 1) / 2; if(check(mid)) L = mid; else R = mid - 1; } check(L); for(auto i: v) if(cnt &gt; k &amp;&amp; b[i] &gt; 0) cnt--, b[i]--; for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, b[i]); return 0;}","link":"/blog-xcpc/2020/05/07/Codeforces-Round-639-Div-2/"},{"title":"Codeforces Round #641 (Div.2)","text":"比赛链接 / 官方题解链接 A. Orac and FactorsSolution$n+f(n)$ 一定是偶数，所以在第一次操作后，后面的操作都是加 $2$. Code>folded12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, k;int main(){ for(read(T); T; T--){ read(n, k); int i = 0; for(i = 2; i * i &lt;= n; i++) if(n % i == 0) break; if(n % i != 0) i = n; printf(&quot;%lld\\n&quot;, 1ll * n + i + 2 * (k - 1)); } return 0;} B. Orac and ModelsSolution设 $dp[i]$ 为考虑前 $i$ 个数且选了第 $i$ 个数的最大长度，转移很简单。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, s[N], dp[N];int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(s[i]), dp[i] = 0; int ans = 0; for(int i = 1; i &lt;= n; i++){ dp[i] = 1; for(int j = 1; j * j &lt;= i; j++) if(i % j == 0){ if(s[i] &gt; s[j]) dp[i] = max(dp[i], dp[j] + 1); if(s[i] &gt; s[i/j]) dp[i] = max(dp[i], dp[i/j] + 1); } ans = max(ans, dp[i]); } printf(&quot;%d\\n&quot;, ans); } return 0;} C. Orac and LCMSolution把所有数分解质因数，对于质因子 $x$，设 $a$ 是含有 $x$ 最小次数的数，次数为 $r$（$r\\geq0$）；$b$ 是含有 $x$ 次小次数的数，次数为 $s$（$s\\geq0$），即 $x^r|a,x^s|b$. 那么 $x$ 对答案的贡献为 $x^s$. 因为 $a$ 和 $b$ 的 $\\mathrm{lcm}$ 含有 $x$ 的次数是 $s$，而其他数对含有 $x$ 的次数一定更大，所以最后求出的 $\\gcd$ 含有 $x$ 的次数就是 $s$. Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, a, mx;multiset&lt;int&gt; s[200005];LL ans = 1;LL fpow(LL bs, LL idx){ LL res = 1; while(idx){ if(idx &amp; 1) res *= bs; bs *= bs; idx &gt;&gt;= 1; } return res;}int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(a); mx = max(mx, a); for(int j = 2; j * j &lt;= a; j++){ if(a % j == 0){ int c = 0; while(a % j == 0){ c++; a /= j; } s[j].insert(c); } } if(a != 1) s[a].insert(1); } for(int i = 2; i &lt;= mx; i++){ if(s[i].size() &lt; n - 1) continue; else if(s[i].size() == n - 1) ans *= fpow(i, *s[i].begin()); else{ s[i].erase(s[i].begin()); ans *= fpow(i, *s[i].begin()); } } printf(&quot;%lld\\n&quot;, ans); return 0;} D. Orac and MediansSolution首先，如果没有 $k$ 这个数，肯定是 no。 然后有一个结论：答案存在的充要条件是存在两个下标相差不超过 $2$ 的数均大于等于 $k$。手玩一下发现应该是对的。 特判一下 $n=1$. Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, k, a[N];int main(){ for(read(T); T; T--){ bool ok = false; read(n, k); for(int i = 1; i &lt;= n; i++){ read(a[i]); if(a[i] == k) ok = true; } if(!ok){ puts(&quot;no&quot;); continue; } ok = false; if(n == 1){ puts(&quot;yes&quot;); continue; } for(int i = 1; i &lt;= n; i++){ if(a[i] &gt;= k){ if(i &gt; 1 &amp;&amp; a[i-1] &gt;= k){ ok = true; break; } if(i &gt; 2 &amp;&amp; a[i-2] &gt;= k){ ok = true; break; } } } puts(ok ? &quot;yes&quot; : &quot;no&quot;); } return 0;} E. Orac and Game of LifeSolution如果一个位置在某时刻变色了，那么它在之后的每一秒一定都会变色（比较显然）。所以我们只需要找到每一个位置第一次变色是什么时候。 如果一个位置没有变色，说明此时它周围都是异色，那么它变色的时刻就是它周围的异色方块中最小的变色时刻+1。所以说，以第一秒就会变色的点为源跑一个 $bfs$ 即可得到所有点的第一次变色时刻。 对每一个询问，如果 $p$ 小于它的变色时刻，那么颜色还是原来的原色；否则，奇偶性判断一下颜色即可。 特判一下没有会变色的点的情况。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int n, m, t, dis[N][N];char g[N][N];bool tag[N][N];int dx[] = {-1, 0, 1, 0};int dy[] = {0, 1, 0, -1};inline bool valid(int x, int y){ return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m;}int main(){ read(n, m, t); for(int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, g[i]+1); queue&lt;pii&gt; q; bool allbad = true; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ tag[i][j] = 0; if(i &gt; 1 &amp;&amp; g[i-1][j] == g[i][j]) tag[i][j] = 1; if(i &lt; n &amp;&amp; g[i+1][j] == g[i][j]) tag[i][j] = 1; if(j &gt; 1 &amp;&amp; g[i][j-1] == g[i][j]) tag[i][j] = 1; if(j &lt; m &amp;&amp; g[i][j+1] == g[i][j]) tag[i][j] = 1; if(tag[i][j]) q.push(mp(i, j)), allbad = false; } } while(!q.empty()){ pii cur = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++){ int tx = cur.first + dx[i], ty = cur.second + dy[i]; if(valid(tx, ty) &amp;&amp; !dis[tx][ty] &amp;&amp; !tag[tx][ty]){ dis[tx][ty] = dis[cur.first][cur.second] + 1; q.push(mp(tx, ty)); } } } while(t--){ int i, j; LL p; read(i, j, p); if(allbad || p &lt; dis[i][j]) putchar(g[i][j]); else{ if((dis[i][j] - p) % 2 == 0) putchar(g[i][j]); else putchar(((g[i][j] - '0') ^ 1) + '0'); } puts(&quot;&quot;); } return 0;}","link":"/blog-xcpc/2020/05/13/Codeforces-Round-641-Div-2/"},{"title":"Codeforces Round #638 (Div.2)","text":"比赛链接 / 官方题解链接 A. Phoenix and BalanceSolution$a=1\\underbrace{00\\cdots0}_\\frac{n}{2}11\\cdots1$，$b=0\\underbrace{11\\cdots1}_\\frac{n}{2}00\\cdots0$ Code>folded123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n;int main(){ for(read(T); T; T--){ read(n); LL a = (1ll &lt;&lt; n); for(int i = 1; i &lt; n / 2; i++) a += (1ll &lt;&lt; i); LL b = (1ll &lt;&lt; (n + 1)) - 2 - a; printf(&quot;%lld\\n&quot;, a - b); } return 0;} B. Phoenix and BeautySolution‘beautiful’ 其实就是以 $k$ 为循环节。如果原有数字种类数多于 $k$，则无解，否则任选一个没有出现过的数补满 $k$ 个数构成循环节，输出即可。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 10005;int T, n, k, a[N];bool b[N];int main(){ for(read(T); T; T--){ read(n, k); memset(b, 0, sizeof b); int cnt = 1, diff = 0; for(int i = 1; i &lt;= n; i++){ read(a[i]); if(a[i] &lt;= a[i-1]) cnt++; if(!b[a[i]]){ b[a[i]] = true; diff++; } } if(diff &gt; k){ puts(&quot;-1&quot;); continue; } int mark = 0; for(mark = 1; mark &lt;= 100; mark++) if(!b[mark]) break; vi loop; for(int i = 1; i &lt;= 100; i++) if(b[i]) loop.pb(i); for(int i = 1; i &lt;= k - diff; i++) loop.pb(mark); printf(&quot;%d\\n&quot;, (int)loop.size() * cnt); for(int i = 1; i &lt;= cnt; i++) for(auto t: loop) printf(&quot;%d &quot;, t); puts(&quot;&quot;); } return 0;} C. Phoenix and DistributionSolution排序后取前 $k$ 个字符为 $k$ 个字符串的第一个字符。 如果前 $k$ 个字符不全相同，那么答案就是 $s[k]$，因为可以把后面的所有字符接到 $s[l](l&lt;k且s[l]\\neq s[k])$ 之后 如果前 $k$ 个字符全相同 如果后面的字符全相同，那么平均分配到 $k$ 个字符串上 如果后面的字符不全相同，那么答案就是 $s[k…n]$ Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, k;char s[N];int main(){ for(read(T); T; T--){ read(n, k); scanf(&quot;%s&quot;, s+1); sort(s+1, s+n+1); bool diff = false; for(int i = 1; i &lt;= k; i++){ if(s[i] != s[1]){ diff = true; break; } } if(diff){ putchar(s[k]); puts(&quot;&quot;); continue; } diff = false; for(int i = k + 1; i &lt;= n; i++){ if(s[i] != s[k+1]){ diff = true; break; } } if(diff){ printf(&quot;%s\\n&quot;, s+k); continue; } putchar(s[k]); if(n &gt; k){ for(int i = 1; i &lt;= (n - k - 1) / k + 1; i++) putchar(s[k+1]); } puts(&quot;&quot;); } return 0;} D. Phoenix and ScienceSolution题目可以转换为：找到一个数列 ${x_n}$ 满足 $x_{n-1}\\leq x_n\\leq2x_{n-1}$. 考虑数列 ${2^n}$，找到最后一个前缀和小于等于 $n$ 的位置，设 $n$ 比这个前缀和多出来了 $r$，那么只需要把 $r$ 插入到数列 ${2^n}$ 中，就得到了我们需要的数列，输出其差分数列。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, b[40], c[40], a[40];int main(){ for(int i = 0; i &lt;= 30; i++){ a[i] = (1ll &lt;&lt; (i + 1)) - 1; b[i] = 1 &lt;&lt; i; } for(read(T); T; T--){ read(n); int d = lower_bound(a+1, a+31, n) - a; printf(&quot;%d\\n&quot;, d); int r = n - a[d-1], cnt = 0; for(int i = 1; cnt &lt; d; i++){ if(r &lt; b[i]){ printf(&quot;%d &quot;, r - b[i-1]); cnt++; if(cnt == d) break; printf(&quot;%d &quot;, b[i] - r); cnt++; r = 2147483647; } else{ printf(&quot;%d &quot;, b[i] - b[i-1]); cnt++; } } puts(&quot;&quot;); } return 0;} E. Phoenix and BerriesSolution参考博客：link Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 505;int n, k;LL a[N], b[N], dp[N][N], tot;int main(){ read(n, k); for(int i = 1; i &lt;= n; i++) read(a[i], b[i]); memset(dp, -1, sizeof dp); dp[0][0] = 0; for(int i = 0; i &lt; n; i++){ tot += a[i] + b[i]; for(int j = 0; j &lt; k; j++){ if(dp[i][j] == -1) continue; LL red = j + a[i+1]; LL blue = tot - dp[i][j] * k - j + b[i+1]; for(int r = 1; r &lt;= min(a[i+1], k-1ll); r++) if(b[i+1] &gt;= k - r) dp[i+1][(red-r)%k] = max(dp[i+1][(red-r)%k], dp[i][j] + (red-r)/k + (blue-k+r)/k + 1); dp[i+1][red%k] = max(dp[i+1][red%k], dp[i][j] + red / k + blue / k); } } LL ans = 0; for(int i = 0; i &lt; k; i++) ans = max(ans, dp[n][i]); printf(&quot;%lld\\n&quot;, ans); return 0;} F. Phoenix and MemorySolution【参考官方题解】首先考虑如何求出一个合法序列：将所有线段按左端点排序，然后依次考虑每一个数字应该放在哪一个线段上，由贪心，应该放到左端点小于等于该数的线段中右端点最小的线段上——这可以通过 set 完成。 现在考虑序列是否唯一。如果不唯一的话，我们一定可以交换序列中的两数而序列仍然合法。在将线段排序后，如果我们能够交换第 $i$ 条线段上的数字 $p[i]$ 和第 $j$ 条线段上的数字 $p[j]$，那么一定有：$l[j]\\leq p[i]&lt;p[j]\\leq r[i]$ 或 $l[i]\\leq p[j]&lt;p[i]\\leq r[j]$，于是我们可以通过线段树完成查找。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, pos[N], ans[N], f[N];struct Node{ int l, r, id; bool operator &lt; (const Node &amp;A) const{ return l == A.l ? r &lt; A.r : l &lt; A.l; }}a[N];set&lt;pii&gt; s;struct segTree{ int l, r, mx, idx;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ if(tr[lid].mx &gt; tr[rid].mx){ tr[id].mx = tr[lid].mx; tr[id].idx = tr[lid].idx; } else if(tr[rid].mx &gt;= tr[lid].mx){ tr[id].mx = tr[rid].mx; tr[id].idx = tr[rid].idx; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].mx = tr[id].idx = 0; if(l == r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void modify(int id, int pos, int val){ if(tr[id].l == tr[id].r){ tr[id].mx = val; tr[id].idx = tr[id].l; return; } if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); pushup(id);}pii query(int id, int l, int r){ if(l &gt; r) return mp(-1, -1); if(tr[id].l == l &amp;&amp; tr[id].r == r) return mp(tr[id].mx, tr[id].idx); if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else{ pii resl = query(lid, l, mid); pii resr = query(rid, mid+1, r); if(resl.first &gt;= resr.first) return resl; else return resr; } }int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(a[i].l, a[i].r); a[i].id = i; } sort(a+1, a+n+1); int now = 0; for(int i = 1; i &lt;= n; i++){ while(now &lt; n &amp;&amp; a[now+1].l &lt;= i){ now++; s.emplace(mp(a[now].r, now)); } while(!s.empty() &amp;&amp; s.begin() -&gt; first &lt; i) s.erase(s.begin()); pos[i] = s.begin() -&gt; second; f[s.begin() -&gt; second] = i; s.erase(s.begin()); } for(int i = 1; i &lt;= n; i++) ans[a[pos[i]].id] = i; bool ok = true; now = 0; int mark1 = 0, mark2 = 0; build(1, 1, n); for(int i = 1; i &lt;= n; i++) modify(1, f[i], a[i].r); for(int i = 1; i &lt;= n; i++){ pii res = query(1, a[i].l, f[i]-1); if(res.first &gt;= f[i]){ ok = false; mark1 = a[pos[res.second]].id; mark2 = a[i].id; break; } } if(ok){ puts(&quot;YES&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); return 0; } else{ puts(&quot;NO&quot;); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); swap(ans[mark1], ans[mark2]); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); return 0; }}","link":"/blog-xcpc/2020/05/03/Codeforces-Round-638-Div-2/"},{"title":"Codeforces Round #643 (Div.2)","text":"比赛链接 / 官方题解链接 A. Sequence with DigitsSolution一直算到某一位出现 $0$ 为止。 Code>folded123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL n, k;int main(){ for(read(T); T; T--){ read(n, k); LL ans = n; for(int i = 1; i &lt; k; i++){ LL mn = 1e18, mx = -1e18; LL t = ans; while(t){ mn = min(mn, t % 10); mx = max(mx, t % 10); t /= 10; } if(mn == 0) break; ans += mn * mx; } printf(&quot;%lld\\n&quot;, ans); } return 0;} B. Young ExplorersSolution贪心，从小到大排序，依次遍历，能构成 group 就构成 group。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int T, n, a[N];int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1); int cnt = 0; for(int i = 1; i &lt;= n; i++){ int mx = a[i]; int j = i; while(j &lt;= n){ mx = max(mx, a[j]); if(j - i + 1 &gt;= mx){ cnt++; break; } j++; } i = j; } printf(&quot;%d\\n&quot;, cnt); } return 0;} C. Count TrianglesSolution枚举 $z$，对于每个 $z$，需要 $O(1)$ 地找到 $(x,y)$ 的对数，满足：$x\\in[A,B]$，$y\\in[B,C]$，$x+y&gt;z$. 推这个表达式的过程太过恶心（主要是边界恶心），先不写了，心累～ Code>folded1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)LL A, B, C, D;LL cal(LL r, LL l){ return (l + r) * (r - l + 1) / 2;}int main(){ read(A, B, C, D); LL ans = 0; for(int z = C; z &lt;= D; z++){ if(z-C &gt;= B) continue; ans += cal(B-z+C, max(1ll, B-z+B)); if(z - C &lt; A - 1) ans -= cal(A-1-z+C, max(1ll, A-1-z+B)); } printf(&quot;%lld\\n&quot;, ans); return 0;} D. Game With ArraySolution当 $S\\geq2n$ 时，构造 $2,2,\\cdots,2,S-2n+2$，取 $K=1$ 即可。 当 $S&lt;2n$ 时，可以证明无解。 证明：取前缀和，那么一段连续数字的和就是前缀和序列中两个数字的差值。在前缀和序列中，如果出现数字 $x$，就不能出现数字 $y=(x+K)%S$，因为如果 $x+K&lt;S$，那么 $y-x=K$；如果 $x+K\\geq S$，那么 $y=x+K-S$，$x-y=S-K$，均不符合条件。所以数字 $x$ 相当于占据了两个位置：$x$ 和 $(x+K)%S$，而最多有 $S$ 个位置，不够 $n$ 个数分。 Code>folded1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int n, s;int main(){ read(n, s); if(s &gt;= 2 * n){ puts(&quot;YES&quot;); for(int i = 1; i &lt; n; i++) printf(&quot;%d &quot;, 2); printf(&quot;%d\\n&quot;, s - 2 * (n - 1)); printf(&quot;1\\n&quot;); return 0; } puts(&quot;NO&quot;); return 0;} E. Restorer DistanceSolution如果确定了最终的高度的话，我们容易 $O(n)$ 地求出花费的代价。 然后比赛的时候猜测代价是高度的单峰函数，所以套个三分就惊喜地过了…… Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, A, R, M;LL h[N];LL func(LL mid){ LL inc = 0, dec = 0; for(int i = 1; i &lt;= n; i++){ if(h[i] &gt; mid) dec += h[i] - mid; else inc += mid - h[i]; } LL res = M * min(inc, dec); if(inc &gt; dec) res += A * (inc - dec); else res += R * (dec - inc); return res;}LL tripartition(LL l, LL r){ int mid1 = l, mid2 = r; while(mid1 &lt; mid2){ mid1 = l + (r - l) / 3; mid2 = r - (r - l) / 3; if(func(mid1) &gt; func(mid2)) l = mid1 + 1; else r = mid2 - 1; } return func(l);}int main(){ read(n, A, R, M); M = min(M, A + R); LL mn = 1e18, mx = -1e18; for(int i = 1; i &lt;= n; i++){ read(h[i]); mn = min(mn, h[i]); mx = max(mx, h[i]); } printf(&quot;%lld\\n&quot;, tripartition(mn, mx)); return 0;} F. Guess Divisors Count留坑……待填","link":"/blog-xcpc/2020/05/16/Codeforces-Round-643-Div-2/"},{"title":"Codeforces Round #645 (Div.2)","text":"比赛链接 / 官方题解链接 A. Park LightingSolution每两个格子用一盏灯点亮，如果总数为奇数就再增加一盏灯。 Code>folded1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, m;int main(){ for(read(T); T; T--){ read(n, m); printf(&quot;%d\\n&quot;, n * m / 2 + (n * m % 2 == 1)); } return 0;} B. Maria Breaks the Self-isolationSolution从小到大排序，然后依次枚举，但凡能邀请就邀请进来。 Code>folded123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, a[N];int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]), a[i]++; sort(a+1, a+n+1); int now = 1; for(int i = 1; i &lt;= n; i++){ int j = i; while(j &lt;= n &amp;&amp; now + j - i + 1 &lt; a[j]) j++; if(j == n + 1) break; now += j - i + 1; i = j; } printf(&quot;%d\\n&quot;, now); } return 0;} C. Celex UpdateSolution在由 $(x_1,y_1)$ 和 $(x_2,y_2)$ 确定的矩形中，和最小的路径是往右走到底再往下走，和最大的路径是往下走到底再往右走，凡落在这个最大值和最小值之间的数字都可以通过走某条路径得到（因为和数加一就是将一个“右-下”改成“下-右”），所以答案就是这个最大值减去这个最小值加一。 设 $m$ 是矩形小的边长，$n$ 是矩形大的边长，那么最大值减去最小值就是 $1+2+\\cdots+(m-1)+(m-1)+\\cdots+(m-1)+\\cdots+2+1$，一共 $n+m-3$ 项，所以 $上式=(m-1)(m-2)+(n+m-3-2(m-2))(m-1)=(m-1)(n-1)$. Code>folded12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, X1, Y1, X2, Y2;int main(){ for(read(T); T; T--){ read(X1, Y1, X2, Y2); int mn = min(X2 - X1 + 1, Y2 - Y1 + 1); int mx = max(X2 - X1 + 1, Y2 - Y1 + 1); printf(&quot;%lld\\n&quot;, 1ll * (mn - 1) * (mx - 1) + 1); } return 0;} D. The Best VacationSolution解决循环只需要把原数组扩倍。 首先发现性质：答案的端点一定是某区间的端点。所以双指针扫一遍即可。 复杂度：$O(n)$ P.S. 其实上面的性质弱了，官方题解里面证明了答案的右端点一定是某区间的右端点，这样代码可以写得简单些。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 400005;LL n, x, d[N], sum[N];inline LL get(LL l, LL r){ return (l + r) * (r - l + 1) / 2;}int main(){ read(n, x); for(int i = 1; i &lt;= n; i++) read(d[i]), d[i+n] = d[i]; for(int i = 1; i &lt;= 2 * n; i++) sum[i] = sum[i-1] + d[i]; LL ans = 0; LL l = 1, ll = 1, r = 1, rr = 1; while(sum[r] - sum[l-1] &lt; x){ ans += d[r] * (d[r] + 1) / 2; r++; } rr = x - sum[r-1]; ans += (x - sum[r-1]) * (x - sum[r-1] + 1) / 2; LL res = ans; while(r &lt;= 2 * n){ LL step = min(d[l] - ll, d[r] - rr); if(step &gt; 0){ res -= get(ll, ll + step - 1); res += get(rr + 1, rr + step); ll += step, rr += step; ans = max(ans, res); } ll++; if(ll &gt; d[l]){ res -= d[l]; l++; ll = 1; } else{ res -= ll - 1; } rr++; if(rr &gt; d[r]){ res += 1; r++; rr = 1; } else{ res += rr; } ans = max(ans, res); } printf(&quot;%lld\\n&quot;, ans); return 0;} E. Are You Fired?Solution首先有性质：存在 $k&gt;\\left\\lfloor\\frac{n}{2}\\right\\rfloor$ 满足要求，这是因为如果我们找到了某个 $k\\leq\\left\\lfloor\\frac{n}{2}\\right\\rfloor$ 满足要求，那么 $2k$ 一定也满足要求。 如果 $x\\geq0$，我们只需要看所有数的和是否大于 $0$。因为如果所有数的和小于 $0$，我们一定可以把 $1\\sim \\left\\lceil\\frac{n}{2}\\right\\rceil$ 分成两段，前一段和为正，后一段和为负，但凡包含了和为负的这一段的区间总和一定为负，所以无解。 如果 $x&lt;0$，设一个初始区间为 $[1,n]$（$k=n$），如果这一段区间和非正，那么我们缩减 $k$，也就是新区间左端点是前一个区间左端点加一，然后前面所有区间的右端点减一，由于这些右端点一定在后 $\\left\\lfloor\\frac{n}{2}\\right\\rfloor$ 这一段里，所以这些区间总和均减 $x$。查看现在是否有某区间的和非正（记录一个区间和最小值即可），如果有，继续缩减 $k$，否则输出答案。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 500005;int n;LL a[N], x, s[N];int main(){ read(n); for(int i = 1; i &lt;= (n + 1) / 2; i++) read(a[i]); read(x); for(int i = (n + 1) / 2 + 1; i &lt;= n; i++) a[i] = x; for(int i = 1; i &lt;= n; i++) s[i] = a[i] + s[i-1]; if(x &lt; 0){ LL mn = s[n]; if(mn &gt; 0){ printf(&quot;%d\\n&quot;, n); return 0; } for(int i = 2; i &lt;= (n + 1) / 2; i++){ mn -= x; mn = min(mn, s[n] - s[i-1]); if(mn &gt; 0){ printf(&quot;%d\\n&quot;, n-i+1); return 0;} } puts(&quot;-1&quot;); return 0; } else{ if(s[n] &gt; 0) printf(&quot;%d\\n&quot;, n); else puts(&quot;-1&quot;); return 0; }}","link":"/blog-xcpc/2020/05/28/Codeforces-Round-645-Div-2/"},{"title":"Codeforces Round #646 (Div.2)","text":"比赛链接 / 官方题解链接 A. Odd SelectionSolution直接枚举奇数个数，避免讨论，好写好调。 Code>folded123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, x;int main(){ for(read(T); T; T--){ read(n, x); int cnt = 0; for(int i = 1; i &lt;= n; i++){ int a; read(a); if(a &amp; 1) cnt++; } bool ok = false; for(int i = 0; i &lt;= x; i++){ if((i + 2 * (x - i)) % 2 == 0) continue; if(i &lt;= cnt &amp;&amp; x - i &lt;= n - cnt){ ok = true; break; } } puts(ok ? &quot;Yes&quot; : &quot;No&quot;); } return 0;} B. Subsequence HateSolutiongood string 一定形如 $00\\cdots011\\cdots1$ 或 $11\\cdots100\\cdots0$. 枚举分段位置，用前缀和来计算即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, sum[1005][2];char s[1005];int main(){ for(read(T); T; T--){ memset(sum, 0, sizeof sum); scanf(&quot;%s&quot;, s+1); int n = strlen(s+1); for(int i = 1; i &lt;= n; i++){ sum[i][0] = sum[i-1][0] + (s[i] == '0'); sum[i][1] = sum[i-1][1] + (s[i] == '1'); } int ans = 1e9; for(int i = 1; i &lt;= n + 1; i++){ ans = min(ans, sum[i-1][0] + sum[n][1] - sum[i-1][1]); ans = min(ans, sum[i-1][1] + sum[n][0] - sum[i-1][0]); } printf(&quot;%d\\n&quot;, ans); } return 0;} C. Game On LeavesSolution如果根是叶子那么先手胜；否则，每个人的最优策略就是不要在根只剩下两个子树的时候选一个根的子节点，所以 $n$ 偶数则先手胜，$n$ 奇数则后手胜。 Code>folded1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int T, n, x, d[N];int main(){ for(read(T); T; T--){ memset(d, 0, sizeof d); read(n, x); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); d[u]++, d[v]++; } if(d[x] &lt;= 1){ puts(&quot;Ayush&quot;); continue; } n -= 3; puts(n &amp; 1 ? &quot;Ayush&quot; : &quot;Ashish&quot;); } return 0;} D. Guess The MaximumsSolution考虑整个数列中的最大值，除了包含这个数的子集以外（当然也有可能没有包含这个数的子集），其他子集的答案就是这个最大值。所以先把所有数拿出来问一遍得到最大值，接下来我们只需要确定这个最大值在哪个子集里。确定位置就是个二分，$1000$ 个子集最多问 $10$ 次就确定下来了。那对于这个子集，把其他数拿去问得到的最大值就是它的答案。前后各问 $1$ 次，二分最多 $10$ 次，总共不超过 $12$ 次。 a funny picture from Codeforces tutorial: Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int T, n, k, c[N];vi s[N];inline int ask(int l, int r){ vi a; for(int i = l; i &lt;= r; i++) for(auto k: s[i]) a.pb(k); printf(&quot;? %d &quot;, (int)a.size()); for(auto k: a) printf(&quot;%d &quot;, k); puts(&quot;&quot;); fflush(stdout); int res = 0; read(res); return res;}int main(){ for(read(T); T; T--){ read(n, k); for(int i = 1; i &lt;= k; i++){ s[i].clear(); read(c[i]); for(int j = 1; j &lt;= c[i]; j++){ int x; read(x); s[i].pb(x); } } int mxall = 0; printf(&quot;? %d &quot;, n); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, i); puts(&quot;&quot;); fflush(stdout); read(mxall); int l = 1, r = k; while(l &lt; r){ int mid = (l + r) &gt;&gt; 1; if(ask(l, mid) == mxall) r = mid; else l = mid + 1; } vi a; vector&lt;bool&gt; b(n+5, false); for(auto k: s[l]) b[k] = true; for(int i = 1; i &lt;= n; i++) if(!b[i]) a.pb(i); printf(&quot;? %d &quot;, (int)a.size()); for(auto k: a) printf(&quot;%d &quot;, k); puts(&quot;&quot;); fflush(stdout); int ansforl = 0; read(ansforl); if(ansforl == -1) exit(0); printf(&quot;! &quot;); for(int i = 1; i &lt;= k; i++){ if(i == l) printf(&quot;%d &quot;, ansforl); else printf(&quot;%d &quot;, mxall); } puts(&quot;&quot;); fflush(stdout); string feedback; cin &gt;&gt; feedback; if(feedback == &quot;Correct&quot;) continue; else exit(0); } return 0;} E. Tree ShufflingSolution显然当前和需求的 $0,1$ 数量不同就无解，否则有解。 如果称当前值和需求值不同为“未匹配点”，反之为“匹配点”，那么观察可以得到一些性质： 只有“未匹配点”之间会交换，否则一个“未匹配点”与一个“匹配点”交换之后，“匹配点”变成“未匹配点”，终将与另一个“未匹配点”交换，划不着； 在以 $x$ 为根的子树中发生交换的两个点，其最小代价是 $x$ 的所有祖先（包括自己）的代价最小值。 根据上述第二条性质，我们进行预处理，把所有点的代价 $a$ 变成它祖先里面的最小的代价。于是现在从根沿一条路径到叶子，代价单调不增。 那么很容易贪心地知道能在某子树里交换的两个点就一定会在子树里交换，而不会上升到更高层再交换。 所以 $dfs$ 式地递归一次，每次把当前子树内能交换的点全都交换。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, cntb, cntc;LL ans;struct Node{ LL a; int b, c;}t[N];vi edge[N];void dfs(int x, int f, LL mncost){ t[x].a = mncost; for(auto to: edge[x]){ if(to == f) continue; dfs(to, x, min(mncost, t[to].a)); }}int one[N], zero[N];void solve(int x, int f){ if(t[x].b == 0 &amp;&amp; t[x].c == 1) one[x]++; if(t[x].b == 1 &amp;&amp; t[x].c == 0) zero[x]++; for(auto to: edge[x]){ if(to == f) continue; solve(to, x); one[x] += one[to]; zero[x] += zero[to]; } ans += t[x].a * 2 * min(one[x], zero[x]); if(one[x] &gt;= zero[x]) one[x] -= zero[x], zero[x] = 0; else zero[x] -= one[x], one[x] = 0;}int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(t[i].a, t[i].b, t[i].c); cntb += t[i].b, cntc += t[i].c; } if(cntb ^ cntc) return puts(&quot;-1&quot;), 0; for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); } dfs(1, 0, t[1].a); solve(1, 0); printf(&quot;%lld\\n&quot;, ans); return 0;} F. Rotating SubstringsSolution【参考官方题解】重点：这个顺时针旋转操作可以看作把最后一个数挑出来插入到前面某个位置，挑出一个数的代价是 $1$。 如果 $s,t$ 含有字母种类或个数不同，显然无解；否则有解。 设 $dp[i][j]$ 表示使 $s[1\\cdots i]$ 与 $t[1\\cdots j]$ 匹配的最小代价，这里说的匹配是指用 $s[i+1\\cdots n]$ 里面挑出的一些数去往 $s[1\\cdots i]$ 里面插，最后插成跟 $t[1\\cdots j]$ 一样，所以这里 $i\\leq j$。 考虑 $dp[i][j]$ 可以从哪些状态转移过来： 如果我们把 $s[i]$ 挑出来在以后用，那么我们需要 $s[1\\cdots i-1]$ 和 $t[1\\cdots j]$ 匹配，所以可以从 $dp[i-1][j]$ 转移而来且代价加一； 如果 $s[i] == t[j]$，那么我们只需要 $s[1\\cdots i-1]$ 和 $t[1\\cdots j-1]$ 匹配就行了，随后 $s[i]$ 和 $t[j]$ 自然匹配上，所以这种情况下可以从 $dp[i-1][j-1]$ 转移而来； 如果 $s[i+1\\cdots n]$ 里面有多余的 $t[j]$ 字母可供使用，就可以拿一个来和 $t[j]$ 匹配上，我们只需要关心 $s[1\\cdots i]$ 和 $t[1\\dots j-1]$ 的匹配，所以当 $s[i+1\\cdots n]$ 中 $t[j]$ 的出现次数多于 $t[j+1\\cdots n]$ 中的出现次数，就可以从 $dp[i][j-1]$ 转移而来。 边界条件：$dp[0][j]=0$，就是说 $s$ 为空的时候，要去匹配 $t[1\\cdots j]$，只需要把挑出来待用的数一个个对应地填上去就行了。 综上，写作记忆化搜索式的 $dp$ 最为方便。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2005;int T, n;char s[N], t[N];int cnts[N][30], cntt[N][30];int dp[N][N];int DP(int i, int j){ if(i &gt; j) return 0; if(dp[i][j] != -1) return dp[i][j]; int res = 1e9; if(i) res = min(res, DP(i-1, j) + 1); if(i &amp;&amp; j &amp;&amp; s[i] == t[j]) res = min(res, DP(i-1, j-1)); if(j &amp;&amp; cnts[i+1][t[j]-'a'] &gt; cntt[j+1][t[j]-'a']) res = min(res, DP(i, j-1)); return dp[i][j] = res;}int main(){ for(read(T); T; T--){ read(n); scanf(&quot;%s%s&quot;, s+1, t+1); for(int i = 1; i &lt;= n + 1; i++) for(int j = 0; j &lt; 26; j++) cnts[i][j] = cntt[i][j] = 0; for(int i = n; i &gt;= 1; i--){ for(int j = 0; j &lt; 26; j++){ cnts[i][j] = cnts[i+1][j] + (s[i] == j + 'a'); cntt[i][j] = cntt[i+1][j] + (t[i] == j + 'a'); } } bool ok = true; for(int j = 0; j &lt; 26; j++){ if(cnts[1][j] != cntt[1][j]){ ok = false; break; } } if(!ok){ puts(&quot;-1&quot;); continue; } for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) dp[i][j] = i == 0 ? 0 : -1; printf(&quot;%d\\n&quot;, DP(n, n)); } return 0;}","link":"/blog-xcpc/2020/06/01/Codeforces-Round-646-Div-2/"},{"title":"Codeforces Round #642 (Div.3)","text":"比赛链接 / 官方题解链接 A. Most Unstable ArraySolution如果 $n=1$，那么答案只能是 $0$. 如果 $n=2$，那么最优构造是 $[0,m]$，答案是 $m$. 如果 $n&gt;2$，那么最优构造是 $[0,m,0,\\cdots,0]$，答案是 $2m$. Code>folded12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, m;int main(){ for(read(T); T; T--){ read(n, m); if(n == 1) puts(&quot;0&quot;); else if(n == 2) printf(&quot;%d\\n&quot;, m); else printf(&quot;%d\\n&quot;, m &lt;&lt; 1); } return 0;} B. Two Arrays And SwapsSolution$a$ 从小到大排序，$b$ 从大到小排序，然后能交换就交换。 Code>folded1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 35;int T, n, k, a[N], b[N];int main(){ for(read(T); T; T--){ read(n, k); int sum = 0; for(int i = 1; i &lt;= n; i++) read(a[i]), sum += a[i]; for(int i = 1; i &lt;= n; i++) read(b[i]); sort(a+1, a+n+1); sort(b+1, b+n+1); reverse(b+1, b+n+1); for(int i = 1; i &lt;= k; i++){ if(a[i] &gt;= b[i]) break; sum += b[i] - a[i]; } printf(&quot;%d\\n&quot;, sum); } return 0;} C. Board MovesSolution推一波公式就可以了：$ans=8\\times\\frac{\\left\\lfloor n/2\\right\\rfloor\\cdot\\left(\\left\\lfloor n/2\\right\\rfloor+1\\right)\\cdot\\left(2\\left\\lfloor n/2\\right\\rfloor+1\\right)}{6}$. Code>folded123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n;int main(){ for(read(T); T; T--){ read(n); LL k = n / 2; printf(&quot;%lld\\n&quot;, k * (k + 1) * (2 * k + 1) / 6 * 8); } return 0;} D. Constructing the ArraySolution递归填这个数列，把填的位置和填之前的 $0$ 的块长记录下来，排序后就是 $1\\sim n$ 的填写顺序。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int T, n;struct Node{ int pos, len; bool operator &lt; (const Node &amp;A) const{ return len == A.len ? pos &gt; A.pos : len &lt; A.len; }};priority_queue&lt;Node&gt; q;void solve(int l, int r){ if(l &gt; r) return; q.push((Node){(l + r) &gt;&gt; 1, r - l + 1}); solve(l, (l + r) / 2 - 1); solve((l + r) / 2 + 1, r);}int main(){ for(read(T); T; T--){ read(n); solve(1, n); vi ans(n+5); int now = 0; while(!q.empty()){ ans[q.top().pos] = ++now; q.pop(); } for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } return 0;} E. K-periodic GarlandSolution把原序列按照下标模 $k$ 的余数分组，那么一个合法序列的所有 $1$ 一定同时出现在某一组中。 枚举每一组作为 $1$ 出现的组，其他组的所有元素置为 $0$。对于组内的元素，我们要将其转换为一段连续的 $0$ 接上一段连续的 $1$ 再接上一段连续的 $0$ 的形式，询问最小转换次数。这可以 dp 解决。 复杂度：$O(k\\cdot\\frac{n}{k})=O(n)$ Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2000005;int T, n, k, dp[N][3], sum[N];char s[N];int main(){ for(read(T); T; T--){ int ans = 1e9; read(n, k); scanf(&quot;%s&quot;, s+1); dp[0][0] = dp[0][1] = dp[0][2] = 1e9; for(int i = 1; i &lt;= n; i++){ sum[i] = sum[i-1] + (s[i] == '1'); dp[i][0] = dp[i][1] = dp[i][2] = 1e9; } for(int i = n + 1; i &lt;= n + k; i++){ sum[i] = sum[n]; dp[i][0] = dp[i][1] = dp[i][2] = 1e9; } for(int i = 1; i &lt;= k; i++){ int j = i; for(j = i; j &lt;= n; j += k){ if(j == i){ dp[j][0] = (s[j] == '1') + sum[j-1]; dp[j][1] = (s[j] == '0') + sum[j-1]; } else{ dp[j][0] = min(dp[j][0], dp[j-k][0] + (s[j] == '1') + sum[j-1] - sum[j-k]); dp[j][1] = min(dp[j][1], min(dp[j-k][0], dp[j-k][1]) + (s[j] == '0') + sum[j-1] - sum[j-k]); dp[j][2] = min(dp[j][2], min(dp[j-k][1], dp[j-k][2]) + (s[j] == '1') + sum[j-1] - sum[j-k]); } } dp[j][0] = min(dp[j][0], dp[j-k][0] + sum[j-1] - sum[j-k]); dp[j][1] = min(dp[j][1], min(dp[j-k][0], dp[j-k][1]) + sum[j-1] - sum[j-k]); dp[j][2] = min(dp[j][2], min(dp[j-k][1], dp[j-k][2]) + sum[j-1] - sum[j-k]); ans = min(ans, min(dp[j][0], min(dp[j][1], dp[j][2]))); } printf(&quot;%d\\n&quot;, ans); } return 0;} F. Decreasing HeightsSolution在一条满足答案的路径中，一定有至少一个格子的数没有被减，因为如果所有数都被减了，那么全都加上最小的减数后仍是符合要求的路径且答案更优。 枚举这个数字没变的格子，由于到达每个格子的步数其实是确定的（例如，$(2,3)$ 一定是走 $5$ 步到达的），所以我们可以知道走过每个格子的话这个格子上面应该填多少。然后就是一个简单的从 $(0,0)$ 到 $(n,m)$ 的 dp了。 复杂度：$O(n^4)$ Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 105;int T, n, m;LL a[N][N], t[N][N], dp[N][N];int main(){ for(read(T); T; T--){ LL ans = 1e18; read(n, m); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) read(a[i][j]); for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ for(int ii = 0; ii &lt; n; ii++){ for(int jj = 0; jj &lt; m; jj++){ t[ii][jj] = a[ii][jj] - (ii + jj - i - j); dp[ii][jj] = 1e18; } } if(t[0][0] &lt; a[i][j]) continue; dp[0][0] = t[0][0] - a[i][j]; for(int ii = 0; ii &lt; n; ii++){ for(int jj = 0; jj &lt; m; jj++){ if(ii &amp;&amp; t[ii][jj] &gt;= a[i][j]) dp[ii][jj] = min(dp[ii][jj], dp[ii-1][jj] + t[ii][jj] - a[i][j]); if(jj &amp;&amp; t[ii][jj] &gt;= a[i][j]) dp[ii][jj] = min(dp[ii][jj], dp[ii][jj-1] + t[ii][jj] - a[i][j]); } } ans = min(ans, dp[n-1][m-1]); } } printf(&quot;%lld\\n&quot;, ans); } return 0;}","link":"/blog-xcpc/2020/05/15/Codeforces-Round-642-Div-3/"},{"title":"Codeforces Round #647 (Div.2)","text":"比赛链接 / 官方题解链接 A. Johnny and Ancient ComputerSolution转换成对大的那个数不断做除法。 Code>folded1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL a, b;int main(){ for(read(T); T; T--){ read(a, b); int cnt = 0; while(a != b){ if(a &gt; b) swap(a, b); if(b % 8 == 0) b /= 8, cnt++; else if(b % 4 == 0) b /= 4, cnt++; else if(b % 2 == 0) b /= 2, cnt++; else break; if(b * 2 == a) b *= 2; else if(b * 4 == a) b *= 4; } if(a == b) printf(&quot;%d\\n&quot;, cnt); else puts(&quot;-1&quot;); } return 0;} B. Johnny and His HobbiesSolution枚举 $k$ 验证即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n;set&lt;int&gt; s;inline bool check(int x){ set&lt;int&gt; t; for(auto k: s) t.insert(k ^ x); return s == t;}int main(){ for(read(T); T; T--){ read(n); bool ok = false; s.clear(); for(int i = 1; i &lt;= n; i++){ int x; read(x); s.insert(x); } for(int i = 1; i &lt;= 1024; i++){ if(check(i)){ printf(&quot;%d\\n&quot;, i); ok = true; break; } } if(!ok) puts(&quot;-1&quot;); } return 0;} C. Johnny and Another Rating DropSolution一位一位地考虑，第 $i$ 位是连续 $2^i$ 个 $0$，然后连续 $2^i$ 个 $1$，然后再连续 $2^i$ 个 $0$ ……如此反复。每个 $0,1$ 转换的地方对答案有贡献，所以第 $i$ 对答案的贡献就是 $\\left\\lceil\\frac{n+1}{2^i}\\right\\rceil-1$. Code>folded123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL n;int main(){ for(read(T); T; T--){ read(n); LL ans = 0; for(int i = 0; i &lt;= 60; i++){ if((1ll &lt;&lt; i) &gt; n) break; ans += (n + 1) / (1ll &lt;&lt; i) - 1; ans += ((n + 1) % (1ll &lt;&lt; i) != 0); } printf(&quot;%lld\\n&quot;, ans); } return 0;} D. Johnny and ContributionSolution如果给定的图合法，那么排序后输出就行了。所以我们只需要判断给定的图是否合法，也就是是否对于每个点，所有小于这个点的值都出现在与之相邻的点中，且不存在与之相等的点。那只需要把小于这个点的值都加起来，看是否等于 $\\frac{t_i\\cdot(t_i-1)}{2}$. Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 500005;int n, m;vi edge[N];bool b[N];struct Node{ int t, id; bool operator &lt; (const Node &amp;A) const{ return t &lt; A.t; }}a[N];int main(){ read(n, m); for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); } for(int i = 1; i &lt;= n; i++) read(a[i].t), a[i].id = i; for(int i = 1; i &lt;= n; i++){ LL sum = 0; for(auto to: edge[i]){ if(a[to].t == a[i].t) return puts(&quot;-1&quot;), 0; if(a[to].t &lt; a[i].t &amp;&amp; !b[a[to].t]){ b[a[to].t] = true; sum += a[to].t; } } if(sum != 1ll * a[i].t * (a[i].t - 1) / 2) return puts(&quot;-1&quot;), 0; for(auto to: edge[i]) if(a[to].t &lt; a[i].t) b[a[to].t] = false; } sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i].id); return 0;} E. Johnny and GrandmasterSolution从大到小对 $k$ 排序，显然最优策略是：把最大的放进 $A$ 集合，然后不断放 $B$ 集合直到其和与 $A$ 集合相等，然后重复这个过程。由于取模的存在，我们存两集合的差值——放进 $A$ 集合就是加，放进 $B$ 集合就是减，同时为了避免取模后变成 $0$，再选取一个模数，类似双哈希。 P.S. 像 $998244353$ 这个常见的模数被卡了……所以还是用个不常见的质数好了。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1000005;const LL mod1 = 1e9 + 7;const LL mod2 = 10000019;int T, n;LL p, k[N];LL fpow(LL bs, LL idx, LL MOD){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int main(){ for(LL i = 2; i * i &lt;= mod2; i++) if(mod2 % i == 0) printf(&quot;%lld\\n&quot;, i); for(read(T); T; T--){ read(n, p); for(int i = 1; i &lt;= n; i++) read(k[i]); sort(k+1, k+n+1), reverse(k+1, k+n+1); LL ans = 0, diff = 0; for(int i = 1; i &lt;= n; i++){ if(ans == 0 &amp;&amp; diff == 0){ ans += fpow(p, k[i], mod1); diff += fpow(p, k[i], mod2); } else{ (((ans -= fpow(p, k[i], mod1)) %= mod1) += mod1) %= mod1; (((diff -= fpow(p, k[i], mod2)) %= mod2) += mod2) %= mod2; } } printf(&quot;%lld\\n&quot;, ans); } return 0;} F. Johnny and Megan’s NecklaceSolution很有趣的一道题！从大到小枚举答案 $k$，那么两个数字能够被“粘合”当且仅当它们的末 $k$ 位相同，所以对于端点值为 $a,b$ 的边，我们在 $a\\text{ AND }(2^k-1)$ 和 $b\\text{ AND }(2^k-1)$ 之间连一条边，那么从一条边经过一个点走到另一条边，就相当于粘合了两段项链，所以问题转化成了找一条欧拉回路！ 找欧拉回路的算法叫做 $Hierholzer$ 算法，基本过程就是 $dfs$，然后用一个栈把欧拉路/回路记录下来。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = (1 &lt;&lt; 20) + 5;int n;struct Node{ int a, b;}a[N];vector&lt;pii&gt; edge[N];bool vis[N];void dfs(int x){ vis[x] = true; for(auto &amp;to: edge[x]) if(!vis[to.first]) dfs(to.first);}stack&lt;int&gt; sta;void dfs(int x, int pre){ while(!edge[x].empty()){ pii to = edge[x].back(); edge[x].pop_back(); if(vis[(to.second+1)/2]) continue; vis[(to.second+1)/2] = true; dfs(to.first, to.second); } if(pre != -1){ sta.push(pre); if(pre &amp; 1) sta.push(pre + 1); else sta.push(pre - 1); }}inline bool check(int B){ for(int i = 0; i &lt;= B; i++) edge[i].clear(), vis[i] = false; for(int i = 1; i &lt;= n; i++){ edge[a[i].a &amp; B].pb(mp(a[i].b &amp; B, 2 * i)); edge[a[i].b &amp; B].pb(mp(a[i].a &amp; B, 2 * i - 1)); } for(int i = 1; i &lt;= n; i++){ if(edge[a[i].a &amp; B].size() &amp; 1) return false; if(edge[a[i].b &amp; B].size() &amp; 1) return false; } int comps = 0; for(int i = 0; i &lt;= B; i++) if(!vis[i] &amp;&amp; !edge[i].empty()) dfs(i), comps++; if(comps != 1) return false; for(int i = 1; i &lt;= n; i++) vis[i] = false; for(int i = 0; i &lt;= B; i++) if(!edge[i].empty()) dfs(i, -1); return true;}int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i].a, a[i].b); for(int b = 20; b &gt;= 0; b--){ if(check((1&lt;&lt;b)-1)){ printf(&quot;%d\\n&quot;, b); break; } } while(!sta.empty()){ printf(&quot;%d &quot;, sta.top()); sta.pop(); } return 0;}","link":"/blog-xcpc/2020/06/06/Codeforces-Round-647-Div-2/"},{"title":"Codeforces Round #648 (Div.2)","text":"比赛链接 / 官方题解链接 A. Matrix GameSolutionKey：每填一个空，可用的行和列同时减一。 有了上述观察，就容易知道判断可用的行与列的最小值的奇偶性即可。 Code>folded12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, m;int main(){ for(read(T); T; T--){ read(n, m); set&lt;int&gt; row, col; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ int a; read(a); if(a) row.insert(i), col.insert(j); } } n = n - row.size(), m = m - col.size(); puts(min(n, m) &amp; 1 ? &quot;Ashish&quot; : &quot;Vivek&quot;); } return 0;} B. Trouble SortSolution如果已经有序，输出 Yes；否则，只要存在不同类型的数，就一定可以排好序。 证明：只要存在不同类型的数，那么我们可以借助第三个数对任意两个数进行交换——类似交换两个整数那样。于是可排序。 Code>folded12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 505;int T, n, a[N], b[N];int main(){ for(read(T); T; T--){ read(n); bool sorted = true; for(int i = 1; i &lt;= n; i++){ read(a[i]); if(i &gt; 1 &amp;&amp; a[i] &lt; a[i-1]) sorted = false; } bool ok = false; for(int i = 1; i &lt;= n; i++){ read(b[i]); if(i &gt; 1 &amp;&amp; b[i] != b[1]) ok = true; } if(sorted) puts(&quot;Yes&quot;); else puts(ok ? &quot;Yes&quot; : &quot;No&quot;); } return 0;} C. Rotation MatchingSolution把 $b$ 数组扩倍，用 $a$ 数组去匹配。只需要找到 $a$ 数组中每一个数要匹配到 $b$ 数组的同一个数时需要移动的步数，统计“属于”每种步数的元素个数，取最大即是答案。 Code>folded1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, a[N], b[N], pos[N], cnt[N], ans;int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(a[i]); pos[a[i]] = i; } for(int i = 1; i &lt;= n; i++){ read(b[i]); cnt[(pos[b[i]] - i + n) % n]++; ans = max(ans, cnt[(pos[b[i]] - i + n) % n]); } printf(&quot;%d\\n&quot;, ans); return 0;} D. Solve The MazeSolution要把 $B$ 困住，就干脆把 $B$ 周围的方块全部置为墙（如果某个方块是 $G$ 就显然是 No），这之后如果从 $(n,m)$ 还能到达所有的 $G$，就可行。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 55;int n, m, T;char g[N][N];bool reach[N][N];int dx[] = {0, 1, 0, -1};int dy[] = {-1, 0, 1, 0};void dfs(int x, int y){ reach[x][y] = true; for(int i = 0; i &lt; 4; i++){ int tx = x + dx[i], ty = y + dy[i]; if(1 &lt;= tx &amp;&amp; tx &lt;= n &amp;&amp; 1 &lt;= ty &amp;&amp; ty &lt;= m &amp;&amp; g[tx][ty] != '#' &amp;&amp; !reach[tx][ty]){ dfs(tx, ty); } }}int main(){ for(read(T); T; T--){ bool ok = true; read(n, m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, g[i] + 1); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(g[i][j] == 'B'){ if(i &gt; 1 &amp;&amp; g[i-1][j] == 'G'){ ok = false; break; } if(i &gt; 1 &amp;&amp; g[i-1][j] == '.') g[i-1][j] = '#'; if(j &gt; 1 &amp;&amp; g[i][j-1] == 'G'){ ok = false; break; } if(j &gt; 1 &amp;&amp; g[i][j-1] == '.') g[i][j-1] = '#'; if(i &lt; n &amp;&amp; g[i+1][j] == 'G'){ ok = false; break; } if(i &lt; n &amp;&amp; g[i+1][j] == '.') g[i+1][j] = '#'; if(j &lt; m &amp;&amp; g[i][j+1] == 'G'){ ok = false; break; } if(j &lt; m &amp;&amp; g[i][j+1] == '.') g[i][j+1] = '#'; } } if(!ok) break; } if(!ok){ puts(&quot;No&quot;); continue; } memset(reach, 0, sizeof reach); if(g[n][m] != '#') dfs(n, m); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(g[i][j] == 'G' &amp;&amp; !reach[i][j]){ ok = false; break; } } } if(!ok) puts(&quot;No&quot;); else puts(&quot;Yes&quot;); } return 0;} E. Maximum Subsequence ValueSolution对于大小小于 $3$ 的集合，它的值显然是所有数的或；对于大小大于等于 $3$ 的集合，任选出 $3$ 个数，它们的或一定大于等于这个集合的答案。因为假设这个集合的值的第 $i$ 位是 $1$，那么第 $i$ 位最多有 $2$ 个 $0$，于是任选 $3$ 个数，它们的值第 $i$ 位一定是 $1$。 所以 $O(n^3)$ 地枚举即可。 Code>folded1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 505;int n;LL a[N];int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); if(n == 1) return printf(&quot;%lld\\n&quot;, a[1]), 0; if(n == 2) return printf(&quot;%lld\\n&quot;, a[1] | a[2]), 0; LL ans = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt; i; j++) for(int k = 1; k &lt; j; k++) ans = max(ans, a[i] | a[j] | a[k]); printf(&quot;%lld\\n&quot;, ans); return 0;} F. Swaps AgainSolution手玩一些数据后可以猜想，只要 $a,b$ 中对称的无序数对相同，那就可行。 Code>folded1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 505;int T, n, a[N], b[N];int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= n; i++) read(b[i]); if((n &amp; 1) &amp;&amp; a[n/2+1] != b[n/2+1]){ puts(&quot;No&quot;); continue; } multiset&lt;pii&gt; A, B; for(int i = 1; i &lt;= n / 2; i++){ if(a[i] &lt;= a[n-i+1]) A.insert(mp(a[i], a[n-i+1])); else A.insert(mp(a[n-i+1], a[i])); if(b[i] &lt;= b[n-i+1]) B.insert(mp(b[i], b[n-i+1])); else B.insert(mp(b[n-i+1], b[i])); } puts(A == B ? &quot;Yes&quot; : &quot;No&quot;); } return 0;} G. Secure Password留坑……","link":"/blog-xcpc/2020/06/09/Codeforces-Round-648-Div-2/"},{"title":"Codeforces Round #649 (Div.2)","text":"比赛链接 / 官方题解链接 A. XXXXXSolution如果所有数都是 $x$ 的倍数，则答案为 $0$；否则，如果所有数的和不是 $x$ 的倍数，答案是 $n$；否则，找到第一个和最后一个不是 $x$ 的倍数的数，删去前缀或后缀。 Code>folded123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, x;int main(){ for(read(T); T; T--){ read(n, x); int mx = -1, mn = 1e9, sum = 0; for(int i = 1; i &lt;= n; i++){ int a; read(a); sum += a; if(a % x) mx = max(mx, i), mn = min(mn, i); } if(mx == -1) puts(&quot;-1&quot;); else if(sum % x) printf(&quot;%d\\n&quot;, n); else printf(&quot;%d\\n&quot;, n - min(mn, n - mx + 1)); } return 0;} B. Most socially-distanced subsequenceSolution保留“山峰”和“山谷”，以及第一个和最后一个数。 Code>folded1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n, a[N];int main(){ for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); vi ans; ans.pb(a[1]); for(int i = 2; i &lt; n; i++){ if(a[i] &gt; a[i-1] &amp;&amp; a[i] &gt; a[i+1]) ans.pb(a[i]); else if(a[i] &lt; a[i-1] &amp;&amp; a[i] &lt; a[i+1]) ans.pb(a[i]); } ans.pb(a[n]); printf(&quot;%d\\n&quot;, (int)ans.size()); for(auto &amp;k: ans) printf(&quot;%d &quot;, k); puts(&quot;&quot;); } return 0;} C. Ehab and Prefix MEXsSolution如果 $a_i\\neq a_{i-1}$，那么必有 $b_i=a_{i-1}$。然后只需要把未出现在 $a$ 中的其他数依次填到空缺的位置上去。 Code>folded12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, a[N], b[N];bool exi[1000005];int main(){ memset(b, -1, sizeof b); read(n); for(int i = 1; i &lt;= n; i++){ read(a[i]); if(i &gt; 1 &amp;&amp; a[i] != a[i-1]) b[i] = a[i-1]; exi[a[i]] = true; } queue&lt;int&gt; q; for(int i = 0; i &lt;= 1e6; i++) if(!exi[i]) q.push(i); for(int i = 1; i &lt;= n; i++) if(b[i] == -1) b[i] = q.front(), q.pop(); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, b[i]); return 0;} D. Ehab’s Last CorollarySolution我们只需要找到一个内部没有边的回路（也就是说，对于回路 $a_1\\to a_2\\to\\cdots\\to a_m\\to a_1$，$a_i$ 和 $a_j$ 之间没有边，$i,j$ 不相邻）就行了，因为如果这个回路长度小于等于 $k$，那么满足条件 $2$；否则，隔一个选一个可以选出大小至少是 $\\left\\lceil\\frac{k}{2}\\right\\rceil$ 的独立集。 如何找到这样的回路？考虑 $dfs$ 树，只要我们取第一个返祖边与树边构成的回路即可。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;const int M = 200005;int n, m, k;vi edge[N];bool ins[N], vis[N];int dep[N];stack&lt;int&gt; sta;void dfs(int x, int f, int depth){ vis[x] = ins[x] = true; sta.push(x); dep[x] = depth; for(auto &amp;to: edge[x]){ if(to == f) continue; if(ins[to]){ for(auto &amp;t: edge[x]) if(ins[t] &amp;&amp; dep[t] &gt; dep[to] &amp;&amp; t != f) to = t; if(dep[x] - dep[to] + 1 &lt;= k){ puts(&quot;2&quot;); printf(&quot;%d\\n&quot;, dep[x] - dep[to] + 1); while(!sta.empty()){ if(dep[sta.top()] &gt;= dep[to]) printf(&quot;%d &quot;, sta.top()); sta.pop(); } exit(0); } else{ puts(&quot;1&quot;); vi ans; bool take = true; int cnt = 0; while(!sta.empty()){ if(dep[sta.top()] &gt;= dep[to]){ if(take){ printf(&quot;%d &quot;, sta.top()); cnt++; if(cnt == (k + 1) / 2) exit(0); } take ^= 1; } sta.pop(); } } } if(!vis[to]) dfs(to, x, depth + 1); } ins[x] = false; sta.pop();}int main(){ read(n, m, k); for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); } dfs(1, 0, 1); puts(&quot;1&quot;); vi ans, _ans; for(int i = 1; i &lt;= n; i++) if(dep[i] &amp; 1) ans.pb(i); else _ans.pb(i); if(ans.size() &lt; (k + 1) / 2) ans = _ans; for(int i = 0; i &lt; (k + 1) / 2; i++) printf(&quot;%d &quot;, ans[i]); return 0;} E. X-ORSolution【参考官方题解】如果我们找到了 $0$ 的位置，那么用它去询问其他位置就可以得到整个数列。所以问题在于如何找到 $0$ 的位置。 如果我们知道了第一个位置的数字是 $val$，那么顺序遍历下去，如果当前位置的数是 $val$ 的子集，那么把 $val$ 改为当前位置的数，存下当前位置 $idx$。如此遍历结束后，$idx$ 位置上就是 $0$。所以问题转化为如何求某一个位置上的数。 考虑数列 $z[i]$，存储任一个第 $i$ 位是 $0$ 的数的位置。那么位置 $r$ 的值就是 $(p_r\\text{ OR }p_{z[0]})\\text{ AND }(p_r\\text{ OR }p_{z[1]})\\text{ AND }\\cdots\\text{ AND }(p_r\\text{ OR }p_{z[10]})$。 如何构造数列 $z[]$？随机取两个数进行询问，设结果的第 $r$ 位是 $0$，那么取 $z[r]$ 为这两个数中任一个位置。重复该过程直到 $z[]$ 被填满。由于每一位至少有一半的数为 $0$，所以这个过程比较快。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 2500;int n, z[20];bool asked[N][N];inline int ask(int x, int y){ printf(&quot;? %d %d\\n&quot;, x, y); fflush(stdout); int res = -1; read(res); if(res == -1) exit(0); else return res;}inline int get(int x){ int res = (1 &lt;&lt; 11) - 1; for(int i = 0; i &lt;= 10; i++){ if(x != z[i]) res &amp;= ask(x, z[i]); else if(res &amp; (1 &lt;&lt; i)) res ^= (1 &lt;&lt; i); } return res;}int main(){ default_random_engine generator; read(n); memset(z, -1, sizeof z); while(count(z, z+11, -1)){ int a = uniform_int_distribution&lt;int&gt; (1, n)(generator); int b = uniform_int_distribution&lt;int&gt; (1, n)(generator); if(a == b || asked[a][b]) continue; asked[a][b] = asked[b][a] = true; int res = ask(a, b); for(int i = 0; i &lt;= 10; i++) if(((res &gt;&gt; i) &amp; 1) == 0 &amp;&amp; z[i] == -1) z[i] = a; } int idx = 1, val = get(1); for(int i = 2; i &lt;= n; i++) if(ask(idx, i) == val) val = get(i), idx = i; vi ans; for(int i = 1; i &lt;= n; i++){ if(i == idx) ans.pb(0); else ans.pb(ask(i, idx)); } printf(&quot;! &quot;); for(auto &amp;k: ans) printf(&quot;%d &quot;, k); fflush(stdout); return 0;}","link":"/blog-xcpc/2020/06/14/Codeforces-Round-649-Div-2/"},{"title":"Codeforces Round #665 (Div.2)","text":"比赛链接 / 官方题解链接 橙名留念！ A. Distance and AxisSolution不动 $A$ 点的话，距离差最大就是 $x_A$，所以如果 $k&gt;x_A$，把 $A$ 移动 $k-x_A$ 就好。 如果 $k&lt;x_A$，如果 $k$ 与 $x_A$ 同奇偶，那么一定可以找到这么个 $k$；否则 $A$ 需要挪一格。 Code12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ int T; for(read(T); T; T--){ int n, k; read(n, k); if(k &gt;= n) printf(&quot;%d\\n&quot;, k - n); else printf(&quot;%d\\n&quot;, ((n ^ k) &amp; 1)); } return 0;} B. Ternary SequenceSolution考虑 $b$ 序列，它的 $2$ 一定是优先去和 $a$ 的 $0$ 去匹配，多了的拿去和 $a$ 的 $2$ 匹配，再多就只能和 $a$ 的 $1$ 匹配了。稍微分类讨论一下就解决了。 Code123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ int T; for(read(T); T; T--){ int x1, y1, z1, x2, y2, z2; read(x1, y1, z1, x2, y2, z2); int ans = 0; if(z2 &gt;= x1 + z1){ printf(&quot;%d\\n&quot;, -(z2 - x1 - z1) * 2); continue; } else if(z2 &gt;= x1){ z2 -= x1; z1 -= z2; printf(&quot;%d\\n&quot;, 2 * min(y2, z1)); } else printf(&quot;%d\\n&quot;, 2 * min(y2, z1)); } return 0;} C. Mere ArraySolution设最小值为 $mn$，那么所有 $mn$ 的倍数都可以以 $mn$ 作为“桥梁”任意交换位置，所以 $mn$ 的倍数们一定可以排成有序的。这之后再检验一下整个序列是否有序即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int gcd(int a, int b){ return b == 0 ? a : gcd(b, a % b); }int n, a[N];int main(){ int T; for(read(T); T; T--){ read(n); int mn = 1e9 + 1; for(int i = 1; i &lt;= n; i++){ read(a[i]); mn = min(mn, a[i]); } vi v; for(int i = 1; i &lt;= n; i++){ if(a[i] % mn == 0){ v.pb(a[i]); a[i] = 0; } } sort(v.begin(), v.end()); int pos = 1; for(auto &amp;k : v){ while(pos &lt;= n &amp;&amp; a[pos]) pos++; a[pos] = k; } bool ok = true; for(int i = 2; i &lt;= n; i++){ if(a[i] &lt; a[i-1]){ ok = false; break; } } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} D. Maximum Distributed TreeSolution显然是考虑每条边的贡献——一条边的贡献就是它两端连接的子树大小乘积，记为 $w$。于是乎，$\\text{ANS}=\\sum_{i=1}^{n-1}w_ia_i$，$a_i$ 就是我们为这条边分配的值。首先根据排序不等式易知，要想答案最大，一定是最大的 $w$ 配最大的 $a$，最小的 $w$ 配最小的 $a$。其次贪心很容易证明：如果质因数个数超过了 $n-1$，就把最大的几个质因数乘起来，这样答案最大。问题解决。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;const LL MOD = 1e9+7;int n, m;vi edge[N];LL p[N], w[N], sz[N];void dfs(int x, int f){ sz[x] = 1; for(auto &amp;to : edge[x]){ if(to == f) continue; dfs(to, x); sz[x] += sz[to]; } w[x] = sz[x] * (n - sz[x]);}inline void initCASES(){ for(int i = 1; i &lt;= n; i++){ edge[i].clear(); p[i] = w[i] = sz[i] = 0; }}int main(){ int T; for(read(T); T; T--){ read(n); initCASES(); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); } dfs(n, 0); n--; sort(w+1, w+n+1); read(m); vector&lt;LL&gt; p(m); for(int i = 0; i &lt; m; i++) read(p[i]); sort(p.begin(), p.end()), reverse(p.begin(), p.end()); int size = p.size(); while(size &lt; n) p.pb(1), size++; reverse(p.begin(), p.end()); LL ans = 0; for(int i = 1; i &lt;= n; i++){ if(i == n){ LL prod = 1; for(int j = n - 1; j &lt; size; j++) (prod *= p[j]) %= MOD; (ans += prod * w[i] % MOD) %= MOD; } else (ans += w[i] * p[i-1]) %= MOD; } printf(&quot;%lld\\n&quot;, ans); } return 0;} E. Divide SquareSolution有两种情况会使答案加一：有一条贯穿整个矩形的直线，或两条直线在矩形内部产生一个交点。 换句话说，答案等于贯穿矩形的直线数量加上矩形内部交点的数量。 前者很好求，对于后者，把所有水平直线按左端点排序，把所有竖直直线按横坐标排序，枚举竖直直线的同时一个优先队列存储能与之产生交点的水平直线有哪些，在线段树中维护它们的纵坐标，于是在线段树中就可以查询交点数了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;const int M = 1000005;struct segTree{ int l, r; LL sum;}tr[M&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ tr[id].sum = tr[lid].sum + tr[rid].sum;}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r, tr[id].sum = 0; if(l == r) return; build(lid, l, mid), build(rid, mid+1, r); pushup(id);}void add(int id, int pos, LL val){ if(tr[id].l == tr[id].r){ tr[id].sum += val; return; } if(pos &lt;= mid) add(lid, pos, val); else add(rid, pos, val); pushup(id);}int sum(int id, int l, int r){ if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].sum; if(r &lt;= mid) return sum(lid, l, r); else if(l &gt; mid) return sum(rid, l, r); else return sum(lid, l, mid) + sum(rid, mid+1, r);}struct Horizontal{ int y, lx, rx; bool operator &lt; (const Horizontal &amp;A) const{ return lx &lt; A.lx; }}h[N];struct Vertical{ int x, ly, ry; bool operator &lt; (const Vertical &amp;A) const{ return x &lt; A.x; }}v[N];struct Node{ int val, id; bool operator &lt; (const Node &amp;A) const{ return val &gt; A.val; }};int main(){ build(1, 0, 1e6); int n, m; read(n, m); LL ans = 1; for(int i = 1; i &lt;= n; i++){ read(h[i].y, h[i].lx, h[i].rx); ans += h[i].lx == 0 &amp;&amp; h[i].rx == 1e6; } for(int i = 1; i &lt;= m; i++){ read(v[i].x, v[i].ly, v[i].ry); ans += v[i].ly == 0 &amp;&amp; v[i].ry == 1e6; } sort(h+1, h+n+1), sort(v+1, v+m+1); priority_queue&lt;Node&gt; q; int pt = 0; for(int i = 1; i &lt;= m; i++){ while(pt &lt; n &amp;&amp; h[pt+1].lx &lt;= v[i].x){ pt++; add(1, h[pt].y, 1); q.push((Node){h[pt].rx, pt}); } while(!q.empty() &amp;&amp; h[q.top().id].rx &lt; v[i].x){ add(1, h[q.top().id].y, -1); q.pop(); } ans += sum(1, v[i].ly, v[i].ry); } printf(&quot;%lld\\n&quot;, ans); return 0;} F. Reverse and SwapSolution考虑线段树维护原序列，设线段树从上往下是第 $0$ 层、第 $1$ 层、……第 $n$ 层。容易发现，$Swap(k)$ 操作就是给第 $n-k-1$ 层的所有节点打上子树交换标记，而 $Reverse(k)$ 操作就是给第 $n-k$ 到第 $n$ 层的所有节点打上子树交换标记。既然如此，我们就记录一下每一层的标记状况，修改或查询的时候按照标记状况决定往左子树还是右子树走——原本该往左子树走的，如果有标记，就往右子树的对应区间走；原本该往右子树走的，如果有标记，就往左子树的对应区间走。换句话说，序列还是原来那个顺序，我们把对序列的操作变成了对操作区间的操作，如此解决问题。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 550005;int n, q;LL a[N];int tag[N], lg[N&lt;&lt;2];struct segTree{ LL sum;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((l + r) &gt;&gt; 1)inline void pushup(int id){ tr[id].sum = tr[lid].sum + tr[rid].sum;}void build(int id, int l, int r){ tr[id].sum = 0; if(l == r){ tr[id].sum = a[l]; return; } build(lid, l, mid), build(rid, mid+1, r); pushup(id);}void replace(int id, int l, int r, int pos, LL val){ if(l == r){ tr[id].sum = val; return; } if(pos &lt;= mid){ if(!tag[lg[id]]) replace(lid, l, mid, pos, val); else replace(rid, mid+1, r, r-mid+pos, val); } else{ if(!tag[lg[id]]) replace(rid, mid+1, r, pos, val); else replace(lid, l, mid, pos-mid-1+l, val); } pushup(id);}LL sum(int id, int l, int r, int ql, int qr){ if(l == ql &amp;&amp; r == qr) return tr[id].sum; if(qr &lt;= mid){ if(!tag[lg[id]]) return sum(lid, l, mid, ql, qr); else return sum(rid, mid+1, r, r-mid+ql, r-mid+qr); } else if(ql &gt; mid){ if(!tag[lg[id]]) return sum(rid, mid+1, r, ql, qr); else return sum(lid, l, mid, ql-mid-1+l, qr-mid-1+l); } else{ if(!tag[lg[id]]) return sum(lid, l, mid, ql, mid) + sum(rid, mid+1, r, mid+1, qr); else return sum(rid, mid+1, r, r-mid+ql, r) + sum(lid, l, mid, l, qr-mid-1+l); }}int main(){ read(n, q); lg[1] = 0; for(int i = 2; i &lt; (1 &lt;&lt; (n + 1)); i++) lg[i] = lg[i/2] + 1; for(int i = 1; i &lt;= (1 &lt;&lt; n); i++) read(a[i]); build(1, 1, 1&lt;&lt;n); while(q--){ int opt; read(opt); if(opt == 1){ int x, k; read(x, k); replace(1, 1, 1&lt;&lt;n, x, k); } else if(opt == 2){ int k; read(k); for(int i = n - k; i &lt;= n; i++) tag[i] ^= 1; } else if(opt == 3){ int k; read(k); tag[n-k-1] ^= 1; } else{ int l, r; read(l, r); printf(&quot;%lld\\n&quot;, sum(1, 1, 1&lt;&lt;n, l, r)); } } return 0;}","link":"/blog-xcpc/2020/08/22/Codeforces-Round-665-Div-2/"},{"title":"Codeforces Round #678 (Div.2)","text":"比赛链接 / 官方题解链接 A. Reorder$$\\sum_{i=1}^n\\sum_{j=i}^n\\frac{a_j}{j}=\\sum_{j=1}^n\\sum_{i=1}^j\\frac{a_j}{j}=\\sum_{j=1}^n a_j$$ 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 105;int n, m;int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); LL sum = 0; for(int i = 1; i &lt;= n; i++){ LL a; scanf(&quot;%lld&quot;, &amp;a); sum += a; } puts(sum == m ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} B. Prime Square形如$$\\begin{matrix}1&amp;0&amp;0&amp;\\cdots&amp;0&amp;1\\1&amp;1&amp;0&amp;\\cdots&amp;0&amp;0\\0&amp;1&amp;1&amp;\\cdots&amp;0&amp;0\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\0&amp;0&amp;0&amp;\\cdots&amp;1&amp;0\\0&amp;0&amp;0&amp;\\cdots&amp;1&amp;1\\end{matrix}$$即可。 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ int n; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(i == j) printf(&quot;%d%c&quot;, 1, &quot; \\n&quot;[j==n]); else if(i == j + 1) printf(&quot;%d%c&quot;, 1, &quot; \\n&quot;[j==n]); else if(i == 1 &amp;&amp; j == n) printf(&quot;%d%c&quot;, 1, &quot; \\n&quot;[j==n]); else printf(&quot;%d%c&quot;, 0, &quot; \\n&quot;[j==n]); } } } return 0;} C. Binary Search根据题目给的代码走，当当前区间中点为 $mid$ 时，为了满足最后能找到 $pos$ 处，要求： 如果 $mid \\leqslant pos$，则需要执行 l=mid+1，因此要求 $mid$ 处的值 $\\leqslant x$； 否则 $mid&gt;pos$，则需要执行 r=mid，因此要求 $mid$ 处的值 $&gt;x$。 设要求小于 $x$ 的数有 $a$ 个，要求大于 $x$ 的数有 $b$ 个，则答案为 $A_{x-1}^a\\times A_{n-x}^b\\times (n-a-b-1)!$. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MOD = 1e9+7;LL fpow(LL bs, LL idx){ bs %= MOD; LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}LL fact[1005] = {1}, invfact[1005] = {1};int main(){ for(int i = 1; i &lt;= 1000; i++){ fact[i] = fact[i-1] * i % MOD; invfact[i] = fpow(fact[i], MOD-2); } int x, n, pos; cin &gt;&gt; n &gt;&gt; x &gt;&gt; pos; int l = 0, r = n, a = 0, b = 0; while(l &lt; r){ int mid = (l + r) &gt;&gt; 1; if(pos &lt; mid) r = mid, b++; else l = mid+1, a += (pos &gt; mid); } if(x-1-a &lt; 0 || n-x-b &lt; 0) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; fact[x-1] * invfact[x-1-a] % MOD * fact[n-x] % MOD * invfact[n-x-b] % MOD * fact[n-a-b-1] % MOD &lt;&lt; endl; return 0;} D. Bandit in a City二分答案，$mid$ 表示叶节点最多容纳的人数，check 是否能够满足该条件。 设 $sum[x]$ 表示以 $x$ 为根的子树中 $a_i$ 的和，$cnt[x]$ 表示以 $x$ 为根的子树的叶节点数量，则 $cnt[x]\\times mid$ 表示当前二分的答案下子树 $x$ 能容纳的最多人数。结论是当且仅当$$sum[x]\\leqslant cnt[x]\\times mid,\\quad\\forall x\\in[1,n]$$时满足 check 条件，可以自下向上数学归纳证明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 200005;int n;vector&lt;int&gt; edge[N];LL a[N];LL cnt[N], sum[N];void dfs(int x){ cnt[x] = (edge[x].size() == 0), sum[x] = a[x]; for(auto &amp;to : edge[x]){ dfs(to); cnt[x] += cnt[to], sum[x] += sum[to]; }}inline bool check(LL mid){ memset(cnt, 0, sizeof cnt); memset(sum, 0, sizeof sum); dfs(1); for(int i = 1; i &lt;= n; i++) if(sum[i] &gt; (unsigned long long)mid * cnt[i]) return false; return true;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 2; i &lt;= n; i++){ int f; scanf(&quot;%d&quot;, &amp;f); edge[f].emplace_back(i); } LL l = 0, r = 0; for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), r += a[i]; while(l &lt; r){ LL mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; } printf(&quot;%lld\\n&quot;, l); return 0;} E. Complicated Computations$x$ 不是答案 $\\iff$ 存在一个不包含 $x$ 的区间包含了 $1\\sim x-1$。 于是我们只需要考虑 $x$ 两次出现之间包夹的区间，如果这里面的数字种数为 $x-1$，那么 $x$ 不是答案。 所有这样的区间是 $O(n)$ 的，所以只需要 $O(\\lg n)$ 地查询即可。 我们开一颗线段树，以数值为值域，在从左往右扫描的过程中存储该数值最近一次的编号（即一个存储最近一次编号的桶）。当加入数字 $a[i]$ 时，查询 $1\\sim a[i]-1$ 这些桶内的最小编号 $l$，如果 $l$ 大于 $a[i]$ 上一次出现的位置，则说明从 $a[i]$ 上一次出现到当前出现这一段区间内，$1\\sim a[i]-1$ 全部出现了，于是 $a[i]$ 不是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int n, a[N], lst[N];bool notAns[N];struct segTree{ int l, r, id;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].id = min(tr[lid].id, tr[rid].id);}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].id = 0; if(l == r) return; build(lid, l, mid), build(rid, mid+1, r); pushup(id);}void modify(int id, int pos, int val){ if(tr[id].l == tr[id].r){ tr[id].id = val; return; } if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); pushup(id);}int query(int id, int l, int r){ if(l &gt; r) return 0; if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].id; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else return min(query(lid, l, mid), query(rid, mid+1, r));}int main(){ scanf(&quot;%d&quot;, &amp;n); build(1, 1, n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d&quot;, &amp;a[i]); if(query(1, 1, a[i] - 1) &gt; lst[a[i]]) notAns[a[i]] = true; if(a[i] == 1 &amp;&amp; i-1 &gt; lst[a[i]]) notAns[a[i]] = true; lst[a[i]] = i; modify(1, a[i], i); } for(int i = 1; i &lt;= n+1; i++){ notAns[i] |= (query(1, 1, i-1) &gt; lst[i]); if(i == 1) notAns[i] |= (n &gt; lst[a[i]]); if(!notAns[i]){ printf(&quot;%d\\n&quot;, i); return 0; } } printf(&quot;%d\\n&quot;, n+2); return 0;}","link":"/blog-xcpc/2021/06/11/Codeforces-Round-678-Div-2/"},{"title":"Codeforces Round #705 (Div.2)","text":"比赛链接 / 官方题解链接 A. Anti-knapsack选出 $\\geqslant \\lceil k/2\\rceil$ 且 $\\neq k$ 的所有数即可。 证明：$&gt;k$ 的所有数一定是都可以选的，所以我们关注点主要放在 $1\\sim k-1$ 这些数上。首先，容易知道选出 $\\geqslant \\lceil k/2\\rceil$ 的数一定是满足题意的；其次，两两配对，容易知道最多从这 $k-1$ 个数中选出 $\\lfloor k/2\\rfloor$ 个数；因而我们的方案是最优解。证毕。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ int T; for(read(T); T; T--){ int n, k; read(n, k); vector&lt;int&gt; ans; for(int i = (k + 1) / 2; i &lt;= n; i++) if(i != k) ans.pb(i); printf(&quot;%d\\n&quot;, (int)ans.size()); for(auto &amp;k : ans) printf(&quot;%d &quot;, k); puts(&quot;&quot;); } return 0;} B. Planet Lapituletti遍历所有的时间，判断是否合法即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int h, m;char s[10], t[10];int mir[15] = {0, 1, 5, -1, -1, 2, -1, -1, 8, -1};bool ref(){ if(~mir[s[0]-'0']) t[4] = mir[s[0]-'0'] + '0'; else return false; if(~mir[s[1]-'0']) t[3] = mir[s[1]-'0'] + '0'; else return false; if(~mir[s[3]-'0']) t[1] = mir[s[3]-'0'] + '0'; else return false; if(~mir[s[4]-'0']) t[0] = mir[s[4]-'0'] + '0'; else return false; int th = (t[0]-'0')*10 + (t[1]-'0'); int tm = (t[3]-'0')*10 + (t[4]-'0'); if(th &lt; h &amp;&amp; tm &lt; m) return true; else return false;}int main(){ int T; for(read(T); T; T--){ read(h, m); scanf(&quot;%s&quot;, s); int sh = (s[0]-'0')*10 + (s[1]-'0'); int sm = (s[3]-'0')*10 + (s[4]-'0'); while(!ref()){ sm++; if(sm &gt;= m) sh++, sm = 0; if(sh &gt;= h) sh = 0; s[0] = sh / 10 + '0'; s[1] = sh % 10 + '0'; s[3] = sm / 10 + '0'; s[4] = sm % 10 + '0'; } printf(&quot;%s\\n&quot;, s); } return 0;} C. K-beautiful Strings如果 $k\\nmid n$，那答案不存在；否则答案一定存在，因为 $zz\\ldots z$ 是满足题意的一个 beautiful string。 如果 $s$ 本身是 beautiful 的，那么答案就是 $s$；否则，答案一定是从某一位开始与 $s$ 不一样的。枚举这个位置 $\\text{pos}$ 以及该位置上的字母（从大于 $s_\\text{pos}$ 的字符开始枚举），计算之前出现过的字母还需要出现多少次才能被 $k$ 整除，由于 $\\text{pos}$ 处已经保证答案的字典序比 $s$ 大了，所以我们只需要把还差的字母按字典序依次填在 $\\text{pos}$ 之后，如果还有剩余的位置，那就补字符 a。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, k;char s[N];vector&lt;int&gt; cnt[N];inline int calc(int now){ int o = now / k; while(o * k &lt; now) o++; return o * k - now;}int main(){ int T; for(read(T); T; T--){ read(n, k); scanf(&quot;%s&quot;, s+1); if(n % k){ puts(&quot;-1&quot;); continue; } cnt[0].clear(); cnt[0].resize(26); for(int i = 1; i &lt;= n; i++){ cnt[i].clear(); cnt[i].resize(26); cnt[i][s[i]-'a']++; } for(int i = 1; i &lt;= n; i++) for(int c = 0; c &lt; 26; c++) cnt[i][c] += cnt[i-1][c]; bool ok = true; for(int i = 0; i &lt; 26; i++) if(cnt[n][i] % k){ ok = false; break; } if(ok){ printf(&quot;%s\\n&quot;, s+1); continue; } vector&lt;int&gt; need(30, 0); for(int i = n; i &gt;= 1; i--){ for(int j = s[i]-'a'+1; j &lt; 26; j++){ int sumneed = 0; for(int c = 0; c &lt; 26; c++){ need[c] = calc(cnt[i-1][c] + (c == j)); sumneed += need[c]; } if(sumneed &lt;= n - i){ int id = 0; string ans; for(int c = 25; c &gt;= 0; c--) while(need[c]--) ans += c + 'a'; while(ans.size() &lt; n - i) ans += 'a'; for(int j = 0; j &lt; n - i; j++) s[n-j] = ans[j]; s[i] = j + 'a'; ok = true; break; } } if(ok) break; } printf(&quot;%s\\n&quot;, s+1); } return 0;} D. GCD of an Array对 $[1,200000]$ 中的每一个质数维护一个数据结构，能够完成对第 $i$ 个数加 $x$ 、求 $1\\sim n$ 的最小值的操作。由于每个数最多有 $6$ 个不同的质因子，每次询问做单点加法的位置很有限，或者说，整个 $n\\times P$ 的矩阵是很稀疏的，我们可以用一些 $\\text{STL}$ 完成。比如我是对每一个质数开一个 unordered_map 和 multiset 完成的。 注意一个 trick：求 $\\gcd$ 时需要作除法，为了避免每次做除法都求逆元耗时过大，可以先把要除的数乘起来，最后求一次逆元就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;const LL MOD = 1e9 + 7;LL fpow(LL base, LL idx){ LL res = 1; base %= MOD; while(idx){ if(idx &amp; 1) (res *= base) %= MOD; idx &gt;&gt;= 1; (base *= base) %= MOD; } return res % MOD;}bool notP[N];LL pList[N], pID;void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0) break; } }}int n, q;LL GCD = 1, divGCD = 1;multiset&lt;LL&gt; st[N];unordered_map&lt;LL, LL&gt; ids[N];inline void add(LL p, LL i, LL k){ if(ids[p].find(i) == ids[p].end()) ids[p][i] = 0; else{ if(k == 1 &amp;&amp; ids[p].size() == n) (divGCD *= fpow(p, *st[p].begin()) % MOD) %= MOD; st[p].erase(st[p].find(ids[p][i])); } ids[p][i]++; st[p].insert(ids[p][i]); if(k == 1 &amp;&amp; ids[p].size() == n) (GCD *= fpow(p, *st[p].begin()) % MOD) %= MOD;}int main(){ Euler(200000); read(n, q); for(int i = 1; i &lt;= n; i++){ LL t; read(t); for(int pid = 1; pList[pid] * pList[pid] &lt;= t &amp;&amp; pid &lt;= pID; pid++){ LL p = pList[pid]; while(t % p == 0) add(p, i, 0), t /= p; } if(t &gt; 1) add(t, i, 0); } for(int pid = 1; pid &lt;= pID; pid++){ LL p = pList[pid]; if(ids[p].size() == n) (GCD *= fpow(p, *st[p].begin()) % MOD) %= MOD; } while(q--){ LL i, t; read(i, t); for(int pid = 1; pList[pid] * pList[pid] &lt;= t &amp;&amp; pid &lt;= pID; pid++){ LL p = pList[pid]; while(t % p == 0) add(p, i, 1), t /= p; } if(t &gt; 1) add(t, i, 1); (GCD *= fpow(divGCD, MOD-2) % MOD) %= MOD; divGCD = 1; printf(&quot;%lld\\n&quot;, GCD); } return 0;}","link":"/blog-xcpc/2021/03/07/Codeforces-Round-705-Div-2/"},{"title":"Codeforces Round #698 (Div.1)","text":"比赛链接 / 官方题解链接 A. Nezzar and BoardSolution手玩一下可以发现，对于两个数 $x,y$，我们能生成所有形如 $(n+1)x-ny=n(x-y)+x$ 的数字，其中 $n\\in \\mathbb N_+$. 于是乎，取 $x=x_1$，遍历 $y\\in{x_2,\\ldots,x_n}$，我们就有了 $n-1$ 个包含 $x_1$ 的等差数列，它们能遍历到的数一定构成一个等差数列，且它的公差为各个等差数列公差的 $\\gcd$. Code123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)LL gcd(LL a, LL b){return b == 0 ? a : gcd(b, a % b);}const int N = 200005;LL n, k, x[N];int main(){ int T; for(read(T); T; T--){ read(n, k); for(int i = 1; i &lt;= n; i++) read(x[i]); sort(x+1, x+n+1); LL g = x[2] - x[1]; for(int i = 3; i &lt;= n; i++) g = gcd(g, x[i] - x[1]); if(abs(k - x[1]) % g) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } return 0;} B. Nezzar and Binary StringSolution从 $f$ 向 $s$ 反向思考，对于最后一步，在将串更改为 $f$ 之前，$[l[q],r[q]]$ 一定全为 $0$ 或全为 $1$，由于只能更改不超过一半的字符，所以如果 $f$ 中 $1$ 更多，那么之前一定全为 $1$，如果 $0$ 更多，之前一定全为 $0$；这样我们就唯一确定了最后一次操作前的字符串，以此往前推即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, q, T, l[N], r[N];string s, f;struct segTree{ int l, r, cov, cnt;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ tr[id].cnt = tr[lid].cnt + tr[rid].cnt;}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].cov != -1){ tr[lid].cov = tr[id].cov; tr[lid].cnt = len(lid) * tr[lid].cov; tr[rid].cov = tr[id].cov; tr[rid].cnt = len(rid) * tr[rid].cov; tr[id].cov = -1; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].cov = -1, tr[id].cnt = 0; if(tr[id].l == tr[id].r){ tr[id].cnt = (f[tr[id].l-1] == '1'); return; } build(lid, l, mid), build(rid, mid+1, r); pushup(id);}void cover(int id, int l, int r, int val){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].cov = val; tr[id].cnt = len(id) * val; return; } if(r &lt;= mid) cover(lid, l, r, val); else if(l &gt; mid) cover(rid, l, r, val); else cover(lid, l, mid, val), cover(rid, mid+1, r, val); pushup(id);}int query(int id, int l, int r){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].cnt; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else return query(lid, l, mid) + query(rid, mid+1, r);}string t;void getStr(int id){ pushdown(id); if(tr[id].l == tr[id].r){ t += (tr[id].cnt == 1) + '0'; return; } getStr(lid), getStr(rid);}int main(){ for(read(T); T; T--){ read(n, q); cin &gt;&gt; s &gt;&gt; f; build(1, 1, n); for(int i = 1; i &lt;= q; i++) read(l[i], r[i]); bool ok = true; for(int i = q; i &gt;= 1; i--){ int num = query(1, l[i], r[i]); if(num * 2 == r[i] - l[i] + 1){ ok = false; break; } cover(1, l[i], r[i], num * 2 &gt; r[i] - l[i] + 1); } t.clear(); getStr(1); ok &amp;= (t == s); puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} C. Nezzar and Nice BeatmapSolution任取一个点作为起点，只需不断取距离当前点最远的还没取过的点即可。 证明可行性：假设当前点为 $b$，上一个点为 $a$，距离 $b$ 最远的还没取过的点是 $c$，倘若 $a\\to b\\to c$ 是直角或钝角，则 $a\\to c$ 的距离比 $a\\to b$ 更远，那么上一步就不应取 $b$. 证毕。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 5005;int n;bool b[N];struct Node{ LL x, y;}a[N];LL dis(int i, int j){ return (a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y);}int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i].x, a[i].y); printf(&quot;%d &quot;, 1); b[1] = true; int p = 1; for(int i = 2; i &lt;= n; i++){ int k = -1; LL mxd = 0; for(int j = 1; j &lt;= n; j++){ if(b[j]) continue; if(mxd &lt; dis(p, j)){ mxd = dis(p, j); k = j; } } printf(&quot;%d &quot;, k); b[k] = true, p = k; } return 0;}","link":"/blog-xcpc/2021/01/29/Codeforces-Round-698-Div-1/"},{"title":"Codeforces Round #709 (Div.1, based on Technocup 2021 Final Round)","text":"比赛链接 / 官方题解链接 A. Basic Diplomacy比赛时没多想，直接上二分图跑最大流了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;const int M = 400005;const LL INF = 1e14;namespace FLOW{ int n, S, T; struct Edge{ int nxt, to; LL flow; }edge[M&lt;&lt;1]; int head[N], edgeNum = 1; void addEdge(int from, int to, LL flow){ edge[++edgeNum] = (Edge){head[from], to, flow}; head[from] = edgeNum; } inline void ae(int from, int to, LL flow){ addEdge(from, to, flow); addEdge(to, from , 0); } bool inq[N]; int dep[N], curArc[N]; inline bool bfs(){ for(int i = 1; i &lt;= n; i++) dep[i] = 1e9, inq[i] = 0, curArc[i] = head[i]; queue&lt;int&gt; q; q.push(S); inq[S] = 1; dep[S] = 0; while(!q.empty()){ int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt){ if(dep[edge[i].to] &gt; dep[cur] + 1 &amp;&amp; edge[i].flow){ dep[edge[i].to] = dep[cur] + 1; if(!inq[edge[i].to]){ q.push(edge[i].to); inq[edge[i].to] = 1; } } } } if(dep[T] != 1e9) return 1; return 0; } LL dfs(int x, LL minFlow){ LL flow = 0; if(x == T) return minFlow; for(int i = curArc[x]; i; i = edge[i].nxt){ curArc[x] = i; if(dep[edge[i].to] == dep[x] + 1 &amp;&amp; edge[i].flow){ flow = dfs(edge[i].to, min(minFlow, edge[i].flow)); if(flow){ edge[i].flow -= flow; edge[i^1].flow += flow; return flow; } } } return 0; } inline LL Dinic(){ LL maxFlow = 0, flow = 0; while(bfs()){ while(flow = dfs(S, INF)) maxFlow += flow; } return maxFlow; }}int main(){ int T; for(read(T); T; T--){ int n, m; read(n, m); FLOW::T = FLOW::n = n + m + 2; FLOW::S = n + m + 1; for(int i = 1; i &lt;= FLOW::n; i++) FLOW::head[i] = 0; FLOW::edgeNum = 1; for(int i = 1; i &lt;= m; i++){ int k; read(k); while(k--){ int j; read(j); FLOW::ae(j, i + n, 1); } FLOW::ae(i + n, FLOW::T, 1); } for(int i = 1; i &lt;= n; i++) FLOW::ae(FLOW::S, i, (m + 1) / 2); LL mxflow = FLOW::Dinic(); if(mxflow == m){ puts(&quot;YES&quot;); for(int i = 1; i &lt;= m; i++){ for(int j = FLOW::head[i+n]; j; j = FLOW::edge[j].nxt){ int to = FLOW::edge[j].to; if(to == FLOW::T) continue; if(FLOW::edge[j^1].flow == 0) printf(&quot;%d &quot;, to); } } puts(&quot;&quot;); } else puts(&quot;NO&quot;); } return 0;} B. Playlist实现起来有点恶心，用链表来方便删除元素，用类似并查集的思想来查找下一个互质的元素，但是要处理并查集上每个点都以下一个点为父节点而构成环的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int gcd(int a, int b){ return b == 0 ? a : gcd(b, a % b); }const int N = 100005;int n, a[N], nxt[N], to[N];bool circle[N];vi inc;int getto(int x){ if(circle[x]) return -1; circle[x] = true; inc.pb(x); return to[x] == x ? x : to[x] = getto(to[x]);}int main(){ // freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); int T; for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= n; i++){ nxt[i] = i == n ? 1 : i + 1; if(gcd(a[i], a[nxt[i]]) &gt; 1) to[i] = nxt[i]; else to[i] = i; circle[i] = false; } inc.clear(); int now = 1; vi ans; vector&lt;bool&gt; del(n+1, false); while(1){ if(del[now]) break; now = getto(now); if(now == -1) break; for(auto &amp;d : inc) circle[d] = false; inc.clear(); if(gcd(a[nxt[now]], a[now]) == 1){ ans.pb(nxt[now]); del[nxt[now]] = true; nxt[now] = nxt[nxt[now]]; if(gcd(a[nxt[now]], a[now]) &gt; 1) to[now] = nxt[now]; now = nxt[now]; } else break; } printf(&quot;%d &quot;, (int)ans.size()); for(auto &amp;k : ans) printf(&quot;%d &quot;, k); puts(&quot;&quot;); } return 0;} C. Skyline Photo很容易想到一个 $\\text{dp}$ 的思路：设 $dp[i]$ 表示前 $i$ 个房子能得到的最大 beauty，那么：$$dp[i]=\\max_{0\\leqslant j&lt;i}\\left{dp[j]+b[p_{j+1,i}]\\right}$$其中 $p_{a,b}=\\arg\\min\\limits_{a\\leqslant k\\leqslant b} h[k]$. 也就是枚举分割点 $j$，然后把 $j+1\\sim i$ 分到一段。 直接按此做是 $O(n^2)$ 的，我们需要优化。设 $t$ 是最后一个 $h[t]&lt;h[i]$ 的位置（单调队列+二分可以处理出来），那么当 $t\\leqslant j&lt;i$ 时，$b[p_{j+1,i}]$ 就等于 $b[i]$，换句话说，我们称 $b[i]$ 覆盖了 $[t,i)$ 这个区间；同理，我们可以找到每个位置能覆盖到的区间，然后进行区间覆盖即可。最后，我们只需要维护 $dp+b$ 的区间最大值，所以一个线段树就可以搞定。 复杂度：$O(n\\lg n)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 300005;const LL INF = 1e14;int n, h[N];LL b[N], dp[N];vector&lt;pii&gt; v;struct segTree{ int l, r; LL dp, dpb, lazyb;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].dp = max(tr[lid].dp, tr[rid].dp); tr[id].dpb = max(tr[lid].dpb, tr[rid].dpb);}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazyb != -INF){ tr[lid].dpb = tr[lid].dp + tr[id].lazyb; tr[lid].lazyb = tr[id].lazyb; tr[rid].dpb = tr[rid].dp + tr[id].lazyb; tr[rid].lazyb = tr[id].lazyb; tr[id].lazyb = -INF; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].dp = tr[id].dpb = 0; tr[id].lazyb = -INF; if(l == r){ tr[id].dpb = b[l]; return; } build(lid, l, mid), build(rid, mid+1, r); pushup(id);}void modify(int id, int l, int r, LL val){ if(l &gt; r) return; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazyb = val; tr[id].dpb = tr[id].dp + val; return; } if(r &lt;= mid) modify(lid, l, r, val); else if(l &gt; mid) modify(rid, l, r, val); else modify(lid, l, mid, val), modify(rid, mid+1, r, val); pushup(id);}void add(int id, int pos, LL val){ pushdown(id); if(tr[id].l == tr[id].r){ tr[id].dpb = tr[id].dpb - tr[id].dp + val; tr[id].dp = val; return; } if(pos &lt;= mid) add(lid, pos, val); else add(rid, pos, val); pushup(id);}LL querydpb(int id, int l, int r){ if(l &gt; r) return -INF; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].dpb; if(r &lt;= mid) return querydpb(lid, l, r); else if(l &gt; mid) return querydpb(rid, l, r); else return max(querydpb(lid, l, mid), querydpb(rid, mid+1, r)); }int main(){ read(n); build(1, 0, n); for(int i = 1; i &lt;= n; i++) read(h[i]); for(int i = 1; i &lt;= n; i++) read(b[i]), modify(1, i, i, b[i]); for(int i = 1; i &lt;= n; i++){ dp[i] = -INF; while(!v.empty() &amp;&amp; h[i] &lt; v.back().second) v.pop_back(); v.pb(mp(i, h[i])); int l = 0, r = v.size() - 1; while(l &lt; r){ int md = (l + r + 1) &gt;&gt; 1; if(v[md].second &lt; h[i]) l = md; else r = md - 1; } int pos = v[l].second &lt; h[i] ? v[l].first : 0; modify(1, pos, i, b[i]); dp[i] = max(dp[i], querydpb(1, 0, i-1)); add(1, i, dp[i]); } printf(&quot;%lld\\n&quot;, dp[n]); return 0;}","link":"/blog-xcpc/2021/03/23/Codeforces-Round-709-Div-1-based-on-Technocup-2021-Final-Round/"},{"title":"Codeforces Round #721 (Div.2)","text":"比赛链接 / 官方题解链接 A. And Then There Were K答案显然是 $2^{\\lfloor\\log_2 n\\rfloor}-1$. 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ int T; for(read(T); T; T--){ int n; read(n); int k = -1, ans = 1; while(n){ n &gt;&gt;= 1; k++; if(k &gt; 0) ans &lt;&lt;= 1; } printf(&quot;%d\\n&quot;, ans-1); } return 0;} B1. Palindrome Game (easy version)由于初始情况一定是回文串，所以 Alice 只能更改某个 0，于是只要 Bob 更改对称位置的那个 0，Alice 就永远只能进行操作 1。直到最后只剩 2 个 0 时，Bob 在 Alice 更改一个 0 后进行翻转操作就可以胜利。 唯一的例外是 $n$ 是奇数且中心位置是 0 且 0 的数量多于 1 个，那么 Alice 只需要改中心位置的 0，这个困境就交到了 Bob 手里。 B2. Palindrome Game (hard version)如果是回文串转到 B1，现在只考虑初始串不是回文的情况。 首先证明 Alice 一定不会输：假设初始串在第一步不做翻转的条件下是先手不输的，那么 Alice 一定不输；否则，如果初始串在第一步不做翻转的条件下是先手必输的，那么 Alice 做一次翻转操作，必输态就给到了 Bob 手里，于是 Alice 必胜。（这个证明感觉上很类似于「证明存在一个无理数的无理数次方是有理数」）。 所以我们只需要考虑什么时候会 DRAW 即可。 假设初始串只进行一次更改之后不能变成回文串，那么根据上述分析，现在的先手不输，又由于对手之前进行了一次操作，所以现在的先手必胜。因此，只要 Alice 先做翻转操作，Bob 只能做一次更改操作，那么 Alice 就胜利了。 否则，一次更改之后初始串能变成回文串。那么，当且仅当这个回文串只有一个中心 0 时结果是 DRAW，否则结果一定是 Alice 胜。这是因为：如果变成的回文串是必胜的，那么 Alice 只需要先翻转初始串，然后 Bob 将其变成回文（Bob 一定会这么干，否则 Alice 一直进行翻转操作而 Bob 只能进行更改操作，这对 Bob 不利），然后 Alice 胜利；否则回文串是必败的，那么 Alice 先把初始串变成该回文串，然后 Bob 必败且根据 B1 的分析知至少输 $2，于是 Alice 胜利。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x) const int N = 1005; char s[N]; int main(){ int T; for(read(T); T; T--){ int n; read(n); scanf(&quot;%s&quot;, s+1); int cnt0 = 0, cnt = 0; for(int i = 1; i &lt;= n; i++){ cnt0 += (s[i] == '0'); cnt += (s[i] != s[n-i+1]); } cnt &gt;&gt;= 1; if(cnt == 0){ if((n &amp; 1) == 1 &amp;&amp; s[n/2+1] == '0' &amp;&amp; cnt0 &gt; 1) puts(&quot;ALICE&quot;); else puts(&quot;BOB&quot;); } else{ if(cnt == 1 &amp;&amp; cnt0 == 2) puts(&quot;DRAW&quot;); else puts(&quot;ALICE&quot;); } } return 0;} C. Sequence Pair Weight把同一个值出现的位置拿出来单独考虑：设 $v$ 出现的位置为 $p_1,,p_2,\\cdots,,p_m$，则 $v$ 对答案的贡献是：$$\\begin{align}&amp;\\sum_{i=1}^m \\sum_{j=i+1}^m p_i\\cdot (n-p_j+1)\\=&amp;\\sum_{i=1}^m(n+1)(m-i)p_i-\\sum_{i=1}^m p_i\\sum_{j=i+1}^m p_j\\end{align}$$前缀和一下就可以做到 $O(m)$ 了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n;LL a[N], t[N], ans;vector&lt;LL&gt; p[N], s[N];inline void init(){ ans = 0; for(int i = 1; i &lt;= n; i++) p[i].clear(), s[i].clear();}int main(){ int T; for(read(T); T; T--){ read(n); init(); for(int i = 1; i &lt;= n; i++) read(a[i]), t[i] = a[i]; sort(t+1, t+n+1); int len = unique(t+1, t+n+1) - (t+1); for(int i = 1; i &lt;= n; i++){ a[i] = lower_bound(t+1, t+len+1, a[i]) - t; p[a[i]].pb(i); } for(int v = 1; v &lt;= n; v++){ if(p[v].empty()) break; int m = p[v].size(); s[v].pb(p[v][0]); for(int i = 1; i &lt; m; i++) s[v].pb(s[v][i-1] + p[v][i]); for(int i = 0; i &lt; m; i++){ ans += 1ll * (n+1) * (m-i-1) * p[v][i]; ans -= p[v][i] * (s[v][m-1] - s[v][i]); } } printf(&quot;%lld\\n&quot;, ans); } return 0;} D. MEX Tree把 $0$ 视为树的根，那么 $\\text{mex}=0$ 的答案就是各个子树内部配对的数量。 求 $\\text{mex}=i$ 时采取 $\\text{mex}\\geqslant i$ 的数量减去 $\\text{mex}&gt;i$ 的数量的方法。由于 $\\text{mex}\\geqslant i$ 就是 $\\text{mex}&gt;i-1$，所以现在只需要解决如何求解 $\\text{mex}&gt;i$ 的数量即可。 $\\text{mex}&gt;i$ 意味着必须要经过 $0,1,\\cdots,i$ 这些点，如果它们不在一条链上，那么一定无解；否则，维护这条链，经过这条链的路径数量可以简单的算出来，这就是 $\\text{mex}&gt;i$ 的点对数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, fa[N];vi edge[N];LL ans[N], sz[N];bool vis[N];void dfs(int x, int f){ fa[x] = f, sz[x] = 1; for(auto &amp;to : edge[x]){ if(to == f) continue; dfs(to, x); sz[x] += sz[to]; }}inline void init(){ for(int i = 0; i &lt;= n; i++){ ans[i] = fa[i] = sz[i] = 0; vis[i] = false; edge[i].clear(); }}int main(){ int T; for(read(T); T; T--){ read(n); init(); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); edge[u].pb(v), edge[v].pb(u); } dfs(0, -1); for(auto &amp;to : edge[0]) ans[0] += sz[to]*(sz[to]-1)/2; vis[0] = true; LL P = 1ll*n*(n-1)/2 - ans[0]; int edl = 0, edr = 0; for(int i = 1; i &lt;= n; i++){ if(vis[i]) continue; int now = i, pre = 0; while(!vis[now]){ vis[now] = true; pre = now; now = fa[now]; } sz[now] -= sz[pre]; if(now != edl &amp;&amp; now != edr){ ans[i] = P; break; } if(now == edl) edl = i; else if(now == edr) edr = i; ans[i] = P - sz[edl] * sz[edr]; P = sz[edl] * sz[edr]; } for(int i = 0; i &lt;= n; i++) printf(&quot;%lld%c&quot;, ans[i], &quot; \\n&quot;[i==n]); } return 0;} E. Partition Game和前一天刚做到的这道题如出一辙，可惜比赛的时候没时间看了，血亏～ 题解参考之前的博客，不单独对这道题写一遍了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 35005;const int K = 105;struct segTree{ int l, r; LL mn, lazy;}tr[N&lt;&lt;2];#define lid (id&lt;&lt;1)#define rid (id&lt;&lt;1|1)#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].mn = min(tr[lid].mn, tr[rid].mn);}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazy){ tr[lid].lazy += tr[id].lazy; tr[lid].mn += tr[id].lazy; tr[rid].lazy += tr[id].lazy; tr[rid].mn += tr[id].lazy; tr[id].lazy = 0; }}void build(LL a[], int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].lazy = 0, tr[id].mn = 0; if(l == r){ tr[id].mn = a[l]; return; } build(a, lid, l, mid), build(a, rid, mid+1, r); pushup(id);}void add(int id, int l, int r, LL val){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazy += val; tr[id].mn += val; return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}LL query(int id, int l, int r){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].mn; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else return min(query(lid, l, mid), query(rid, mid+1, r));}int n, k;LL a[N], dp[K][N], pos[N], pre[N];int main(){ read(n, k); for(int i = 1; i &lt;= n; i++){ read(a[i]); pre[i] = pos[a[i]]; dp[1][i] = dp[1][i-1] + (i - pos[a[i]]) * (pos[a[i]] != 0); pos[a[i]] = i; } for(int j = 2; j &lt;= k; j++){ build(dp[j-1], 1, 1, n); for(int i = j; i &lt;= n; i++){ if(1 &lt;= pre[i] - 1) add(1, 1, pre[i]-1, i - pre[i]); dp[j][i] = query(1, 1, i-1); } } printf(&quot;%lld\\n&quot;, dp[k][n]); return 0;}","link":"/blog-xcpc/2021/05/21/Codeforces-Round-721-Div-2/"},{"title":"DSU on tree 学习笔记","text":"参考博客：1 2 3 简述DSU on tree，其实和 dsu(并查集) 没有太大关系，唯一的一点关系可能就是“启发性合并”的思想吧，所以它的中文名称为“树上启发性合并”。 这是一个看起来很暴力的算法。我们拿到一道树上针对顶点询问且无修改的问题，首先考虑如何暴力求解——我们用全局变量存储需要维护的信息，整体 $dfs$ 一遍枚举顶点，对每个枚举的顶点 $dfs$ 它的子树计算这个顶点的答案，当然计算答案前先把全局变量里之前的答案清空。暴力求解的时间复杂度显然是 $O(n^2)$，但我们只需要调节 $dfs$ 的顺序和适时保留全局变量里存的答案就能降低复杂度。 每枚举到一个顶点时，先去计算它的轻儿子的答案，最后再计算重儿子的答案。但是重儿子的答案计算完毕后不再清空全局变量，而是沿用里面的信息去更新它的父节点的答案——这个时候只需要暴力统计轻儿子们对父节点的贡献。 由于从根开始的任意路径上轻边数量不超过 $\\lg n$，所以每个点因暴力统计被访问的次数是 $O(\\lg n)$ 的，所以 DSU on tree 的复杂度是 $O(n\\lg n)$. 模板流程： 预处理重儿子 $dfs$ 遍历节点 先遍历轻儿子，求出答案后消除影响 最后遍历重儿子，求出答案后不消除影响 回溯后，暴力统计轻儿子对当前节点的答案 如果当前节点对于其父节点是轻儿子，则消除影响 代码模板以 Codeforces 600E. Lomsat gelral 为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344int fa[N], sz[N], son[N];void dfs(int x, int f){ fa[x] = f, sz[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}LL ans[N], mx, sum, cnt[N]; // GLOBAL variants to store the answerint mark; // mark the heavy son which needs to be ignoredvoid getData(int x, int val){ // get data with brute-force cnt[c[x]] += val; if(mx &lt; cnt[c[x]]) mx = cnt[c[x]], sum = c[x]; else if(mx == cnt[c[x]]) sum += c[x]; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; if(edge[i].to == mark) continue; // ignore the marked subtree getData(edge[i].to, val); }}void dsu(int x, bool opt){ // opt == true: answer needs to be erased for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); // solve for light sons first } if(son[x]) dsu(son[x], false), mark = son[x]; // solve for heavy son // now the global variants have already stored heavy son's answer getData(x, 1); mark = 0; // don't forget this! // now the global variants store the answer for vertex x ans[x] = sum; if(opt){ // erase the answer getData(x, -1); mx = 0, sum = 0; }} 练习Codeforces 600E. Lomsat gelral题目链接 开全局变量 mx,sum,cnt[] 来记录最大数量、最大数量的颜色和、每种颜色的数量。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 100005;int n, c[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N], sz[N], son[N];void dfs(int x, int f){ fa[x] = f, sz[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}LL ans[N], mx, sum, cnt[N]; // GLOBAL variants to store the answerint mark; // mark the heavy son which needs to be ignoredvoid getData(int x, int val){ // get data with brute-force cnt[c[x]] += val; if(mx &lt; cnt[c[x]]) mx = cnt[c[x]], sum = c[x]; else if(mx == cnt[c[x]]) sum += c[x]; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; if(edge[i].to == mark) continue; // ignore the marked subtree getData(edge[i].to, val); }}void dsu(int x, bool opt){ // opt == true: answer needs to be erased for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); // solve for light sons first } if(son[x]) dsu(son[x], false), mark = son[x]; // solve for heavy son // now the global variants have already stored heavy son's answer getData(x, 1); mark = 0; // now the global variants store the answer for vertex x ans[x] = sum; if(opt){ // erase the answer getData(x, -1); mx = 0, sum = 0; }}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]); for(int i = 1; i &lt; n; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); } dfs(1, 0); dsu(1, true); for(int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]); return 0;} Codeforces 570D. Tree Requests题目链接 开全局变量——bitset&lt;26&gt;b[] 记录每一层的字母数量奇偶性。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 500005;int n, m;char s[N];vector&lt;int&gt; vec[N];struct Query{ int v, h; bool ans;}q[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N], sz[N], son[N], dep[N];void dfs(int x, int f, int depth){ fa[x] = f, sz[x] = 1, son[x] = 0, dep[x] = depth; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth + 1); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}bitset&lt;26&gt; b[N];int mark;void getData(int x){ b[dep[x]].flip(s[x]-'a'); for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; if(edge[i].to == mark) continue; getData(edge[i].to); }}void dsu(int x, bool opt){ for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); } if(son[x]) dsu(son[x], false), mark = son[x]; getData(x); mark = 0; for(auto id: vec[x]) q[id].ans = b[q[id].h].count() &lt;= 1; if(opt) getData(x);}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 2; i &lt;= n; i++){ int p; scanf(&quot;%d&quot;, &amp;p); addEdge(i, p), addEdge(p, i); } dfs(1, 0, 1); scanf(&quot;%s&quot;, s+1); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d&quot;, &amp;q[i].v, &amp;q[i].h); vec[q[i].v].emplace_back(i); } dsu(1, true); for(int i = 1; i &lt;= m; i++) puts(q[i].ans ? &quot;Yes&quot; : &quot;No&quot;); return 0;} SGU 507. Treediff题目链接 开全局变量——set&lt;int&gt; s 来记录现在有哪些叶节点的值，更新差值最小值时在 set 里面查前驱后继即可。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 2147483647;const int N = 50005;int n, m, a[N], ans[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum, deg[N];void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum; deg[to]++;}int fa[N], son[N], sz[N];void dfs(int x, int f){ fa[x] = f, son[x] = 0, sz[x] = 1; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}set&lt;int&gt; s;int mn = INF, mark;void getData(int x){ if(deg[x] == 1 &amp;&amp; x != 1){ // is a leaf auto pre = s.lower_bound(a[x]); if(pre != s.begin()){ pre--; mn = min(mn, a[x] - (*pre)); } auto suf = s.lower_bound(a[x]); if(suf != s.end()){ mn = min(mn, (*suf) - a[x]); } s.emplace(a[x]); } for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; if(edge[i].to == mark) continue; getData(edge[i].to); }}void dsu(int x, bool opt){ for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); } if(son[x]) dsu(son[x], false), mark = son[x]; getData(x); ans[x] = mn; mark = 0; if(opt){ s.clear(); mn = INF; }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 2; i &lt;= n; i++){ int p; scanf(&quot;%d&quot;, &amp;p); addEdge(i, p), addEdge(p, i); } for(int i = n - m + 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); dfs(1, 0); dsu(1, true); for(int i = 1; i &lt;= n - m; i++) printf(&quot;%d &quot;, ans[i]); return 0;} Codeforces 208E. Blood Cousins题目链接 开全局变量——cnt[] 来记录每个深度的节点数。 另外，这道题还有一种巧妙并且更好写的做法：记录下每个深度有哪些 $dfs$ 序，然后询问就是在某个深度的 $dfs$ 序列中二分找某个区间内的数的数量。 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 100005;int n, m;struct Query{ int v, p, ans;}q[N];vector&lt;int&gt; vec[N], rt;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum, deg[N];void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum; deg[to]++;}int fa[N][25], son[N], sz[N], dep[N];void dfs(int x, int f, int depth){ fa[x][0] = f, son[x] = 0, sz[x] = 1, dep[x] = depth; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth + 1); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}void init(){ for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for(int i = 1; i &lt;= n; i++) if(fa[i][j-1]) fa[i][j] = fa[fa[i][j-1]][j-1];}int getFa(int x, int p){ for(int i = 20; i &gt;= 0; i--){ if((1 &lt;&lt; i) &lt;= p){ x = fa[x][i]; p -= (1 &lt;&lt; i); } } return x;}int mark, cnt[N];void getData(int x, int val){ cnt[dep[x]] += val; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x][0]) continue; if(edge[i].to == mark) continue; getData(edge[i].to, val); }}void dsu(int x, bool opt){ for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x][0] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); } if(son[x]) dsu(son[x], false), mark = son[x]; getData(x, 1); for(auto k: vec[x]){ q[k].ans = cnt[dep[x] + q[k].p]; if(q[k].ans) q[k].ans--; } mark = 0; if(opt) getData(x, -1);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ int p; scanf(&quot;%d&quot;, &amp;p); if(p == 0) rt.emplace_back(i); addEdge(i, p), addEdge(p, i); } scanf(&quot;%d&quot;, &amp;m); for(auto r: rt) dfs(r, 0, 0); init(); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d&quot;, &amp;q[i].v, &amp;q[i].p); vec[getFa(q[i].v, q[i].p)].emplace_back(i); } for(auto r: rt) dsu(r, true); for(int i = 1; i &lt;= m; i++) printf(&quot;%d &quot;, q[i].ans); return 0;} Codeforces 246E. Blood Cousins Return题目链接 开全局变量——map&lt;string, int&gt;cnt[N] 来记录每一层某个名字的出现次数。 map&lt;&gt; 的使用：map&lt;string, int&gt; 减到 $0$ 之后 erase() 掉相应的字符串，然后用 size() 就能统计 map 里面有多少键值，即不同的字符串数。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 100005;int n, m;string name[N];struct Query{ int v, p, ans;}q[N];vector&lt;int&gt; vec[N], rt;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N], son[N], sz[N], dep[N];void dfs(int x, int f, int depth){ fa[x] = f, son[x] = 0, sz[x] = 1, dep[x] = depth; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth + 1); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}int mark;map&lt;string, int&gt; cnt[N&lt;&lt;1];void getData(int x, int val){ cnt[dep[x]][name[x]] += val; if(cnt[dep[x]][name[x]] == 0) cnt[dep[x]].erase(name[x]); for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; if(edge[i].to == mark) continue; getData(edge[i].to, val); }}void dsu(int x, bool opt){ for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); } if(son[x]) dsu(son[x], false), mark = son[x]; getData(x, 1); for(auto k: vec[x]) q[k].ans = cnt[dep[x] + q[k].p].size(); mark = 0; if(opt) getData(x, -1);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; name[i]; int p; scanf(&quot;%d&quot;, &amp;p); if(p == 0) rt.emplace_back(i); addEdge(i, p), addEdge(p, i); } scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d&quot;, &amp;q[i].v, &amp;q[i].p); vec[q[i].v].emplace_back(i); } for(auto r: rt) dfs(r, 0, 0); for(auto r: rt) dsu(r, true); for(int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, q[i].ans); return 0;} Codeforces 1009F. Dominant Indices题目链接 开全局变量——cnt[],mx,mxDep 分别记录每个深度的节点数、最大节点数和最大节点数所在层数。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1000005;int n, ans[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int sz[N], son[N], dep[N], fa[N];void dfs(int x, int f, int depth){ fa[x] = f, son[x] = 0, dep[x] = depth, sz[x] = 1; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth+1); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}int mark, mxDep, mx, cnt[N];void getData(int x, int val){ cnt[dep[x]] += val; if(cnt[dep[x]] &gt; mx){ mx = cnt[dep[x]]; mxDep = dep[x]; } if(cnt[dep[x]] == mx) mxDep = min(mxDep, dep[x]); for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; if(edge[i].to == mark) continue; getData(edge[i].to, val); }}void dsu(int x, bool opt){ for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); } if(son[x]) dsu(son[x], false), mark = son[x]; getData(x, 1); ans[x] = mxDep - dep[x]; mark = 0; if(opt){ getData(x, -1); mxDep = 0, mx = 0; }}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); } dfs(1, 0, 1); dsu(1, true); for(int i = 1; i &lt;= n; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} Codeforces 375D. Tree and Queries题目链接 开全局变量——num[],d[]. num[c] 记录颜色 $c$ 的数量，d[k] 表示数量大于等于 $k$ 的颜色种数。 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int n, m, col[N];struct Query{ int v, k, ans;}q[N];vector&lt;int&gt; a[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N], sz[N], son[N];void dfs(int x, int f){ fa[x] = f, sz[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}int mark;int d[N], num[N];// num[i]: number of color ivoid getData(int x, int kind){ if(kind == -1) d[num[col[x]]]--; num[col[x]] += kind; if(kind == 1) d[num[col[x]]]++; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; if(edge[i].to == mark) continue; getData(edge[i].to, kind); }}void dsu(int x, bool opt){ for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dsu(edge[i].to, true); } if(son[x]) dsu(son[x], false), mark = son[x]; getData(x, 1); mark = 0; for(auto id: a[x]) q[id].ans = d[q[id].k]; if(opt) getData(x, -1);}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;col[i]); for(int i = 1; i &lt; n; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); } for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d&quot;, &amp;q[i].v, &amp;q[i].k); a[q[i].v].emplace_back(i); } dfs(1, 0); dsu(1, true); for(int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, q[i].ans); return 0;}","link":"/blog-xcpc/2020/04/18/DSU-on-tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Educational Codeforces Round 104","text":"比赛链接 / 官方题解链接 A. Arena显然只有最小的数没法增大，而其他数都能无限增大。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 105;int n, a[N];int main(){ int T; for(read(T); T; T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1); int cnt = 0; for(int i = 1; i &lt;= n; i++){ if(a[i] == a[1]) cnt++; else break; } printf(&quot;%d\\n&quot;, n - cnt); } return 0;} B. Cat Cycle如果 $n$ 是偶数，那么 $A,B$ 永远不会冲突，答案很好计算。 否则，自上一次冲突后，$A,B$ 的下一次冲突将发生在 $\\frac{n-1}{2}$ 步后，也就是说，$B$ 会先以步长为 $1$ 走 $\\frac{n-3}{2}$ 次，然后以步长为 $2$ 走 $1$ 次，以此循环。答案乱搞搞就算出来了。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)LL n, k;int main(){ int T; for(read(T); T; T--){ read(n, k); if(n % 2 == 0){ printf(&quot;%lld\\n&quot;, (k - 1) % n + 1); continue; } if(k * 2 &lt;= n - 1){ printf(&quot;%lld\\n&quot;, k); continue; } if(k * 2 == n + 1){ printf(&quot;%lld\\n&quot;, k + 1); continue; } k -= (n + 1) / 2; LL t = (n - 3) / 2; LL st = (n + 1) / 2 + 1; st += k / (t + 1) * (t + 2); st += k % (t + 1); st = (st - 1) % n + 1; printf(&quot;%lld\\n&quot;, st); } return 0;} C. Minimum Ties以步长 $1$ 转着圈赢：$1\\to2,,2\\to3,,3\\to4,\\ldots$； 然后以步长为 $2$ 转着圈赢：$1\\to3,,2\\to4,,3\\to5,\\ldots$； 然后以步长为 $3$ 转着圈赢：$1\\to4,,2\\to5,\\ldots$； 如果 $n$ 是奇数，这样就保证了每个点出度和入度相等；如果 $n$ 是偶数，多的出度/少的入度变成平局即可。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ int T; for(read(T); T; T--){ int n; read(n); if(n &amp; 1){ for(int l = n - 1; l &gt;= 1; l--) for(int i = 1; i &lt;= l; i++) printf(&quot;%d &quot;, i &lt;= n / 2 ? 1 : -1); puts(&quot;&quot;); } else{ for(int l = n - 1; l &gt;= 1; l--) for(int i = 1; i &lt;= l; i++) printf(&quot;%d &quot;, i == n / 2 ? 0 : (i &lt; n / 2 ? 1 : -1)); puts(&quot;&quot;); } } return 0;} D. Pythagorean Triples$$\\begin{cases}c^2=a^2+b^2\\c=a^2-b\\end{cases}\\implies\\begin{cases}a^2=2b+1\\c=b+1\\end{cases}$$ 为满足 $1\\leqslant a\\leqslant b\\leqslant c\\leqslant n$，首先需要：$n\\geqslant 5$，其次 $a=2k+1$ 是奇数，再次：$c=2k^2+2k+1\\leqslant n$. 可以直接解方程，不过为了避免奇怪的精度问题，我这里采用二分。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int main(){ int T; for(read(T); T; T--){ LL n; read(n); if(n &lt; 5){ printf(&quot;%d\\n&quot;, 0); continue; } LL l = 1, r = n; while(l &lt; r){ LL mid = (l + r + 1) &gt;&gt; 1; if(2 * mid * mid + 2 * mid + 1 &lt;= n) l = mid; else r = mid - 1; } printf(&quot;%lld\\n&quot;, l); } return 0;} E. Cheap Dinner按当前代价顺序考虑当前层的点，向下一层可以转移到的点转移即可。使用堆进行处理，由于每个点最多转移一次，每个限制条件最多被遍历一次，所以转移个数是 $O(n+m)$ 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 150005;int n1, n2, n3, n4, a[N], b[N], c[N], d[N], m[5];set&lt;int&gt; edge[5][N];set&lt;int&gt; s1, s2, s3, s4;int main(){ read(n1, n2, n3, n4); for(int i = 1; i &lt;= n1; i++) read(a[i]), s1.insert(i); for(int i = 1; i &lt;= n2; i++) read(b[i]), s2.insert(i); for(int i = 1; i &lt;= n3; i++) read(c[i]), s3.insert(i); for(int i = 1; i &lt;= n4; i++) read(d[i]), s4.insert(i); for(int i = 1; i &lt;= 3; i++){ read(m[i]); for(int j = 1; j &lt;= m[i]; j++){ int u, v; read(u, v); edge[i][u].insert(v); } } priority_queue&lt; pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q, tmp1, tmp2, tmp3; for(int i = 1; i &lt;= n1; i++) q.push(mp(a[i], i)); while(!q.empty()){ pii cur = q.top(); q.pop(); vi ers; for(auto &amp;elem : s2){ if(edge[1][cur.second].find(elem) == edge[1][cur.second].end()){ tmp1.push(mp(cur.first + b[elem], elem)); ers.pb(elem); } } for(auto &amp;e : ers) s2.erase(e); if(s2.empty()) break; } q = tmp1; while(!q.empty()){ pii cur = q.top(); q.pop(); vi ers; for(auto &amp;elem : s3){ if(edge[2][cur.second].find(elem) == edge[2][cur.second].end()){ tmp2.push(mp(cur.first + c[elem], elem)); ers.pb(elem); } } for(auto &amp;e : ers) s3.erase(e); if(s3.empty()) break; } q = tmp2; while(!q.empty()){ pii cur = q.top(); q.pop(); vi ers; for(auto &amp;elem : s4){ if(edge[3][cur.second].find(elem) == edge[3][cur.second].end()){ tmp3.push(mp(cur.first + d[elem], elem)); ers.pb(elem); } } for(auto &amp;e : ers) s4.erase(e); if(s4.empty()) break; } q = tmp3; if(q.empty()) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;, q.top().first); return 0;}","link":"/blog-xcpc/2021/02/17/Educational-Codeforces-Round-104/"},{"title":"Educational Codeforces Round 105","text":"比赛链接 / 官方题解链接 A. ABC String枚举各字母对应的括弧即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 55;int n;char s[N], t[N];inline bool check(){ int cnt = 0; for(int i = 1; i &lt;= n; i++){ if(t[i] == '(') cnt++; else{ if(cnt &gt; 0) cnt--; else return false; } } return cnt == 0;}int main(){ int T; for(read(T); T; T--){ scanf(&quot;%s&quot;, s+1); n = strlen(s+1); bool ok = false; for(int i = 0; i &lt; 8; i++){ for(int j = 1; j &lt;= n; j++) t[j] = ((i &gt;&gt; (s[j]-'A')) &amp; 1) ? ')' : '('; if(check()){ ok = true; break; } } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} B. Berland Crossword枚举四个顶点的颜色即可。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int n, u, r, d, l;inline int get(int x, int i){ return (x &gt;&gt; i) &amp; 1; }int main(){ int T; for(read(T); T; T--){ read(n, u, r, d, l); bool ok = false; for(int i = 0; i &lt; 16; i++){ if(u - get(i, 0) - get(i, 1) &gt; n - 2 || u - get(i, 0) - get(i, 1) &lt; 0) continue; if(r - get(i, 1) - get(i, 2) &gt; n - 2 || r - get(i, 1) - get(i, 2) &lt; 0) continue; if(d - get(i, 2) - get(i, 3) &gt; n - 2 || d - get(i, 2) - get(i, 3) &lt; 0) continue; if(l - get(i, 3) - get(i, 0) &gt; n - 2 || l - get(i, 3) - get(i, 0) &lt; 0) continue; ok = true; break; } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} C. 1D Sokoban仅考虑正方向，负方向做对称即可。 推完之后的箱子一定是这样的清形：往正方向走，先遇到一段连续的箱子，再遇到一些处于原位置没动的箱子。于是我们只需要枚举连续箱子的末尾的位置，就可以通过 lower_bound 等方式算出这种情形下的得分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;map&lt;int, bool&gt; isp;inline int count(vector&lt;int&gt; &amp;b, int l, int r){ auto ll = lower_bound(b.begin(), b.end(), l); auto rr = lower_bound(b.begin(), b.end(), r); return rr - ll + 1;}inline int solve(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b, int k){ int n = a.size(), m = b.size(); int res = 0; vector&lt;int&gt; sum(n+10), nega(n); for(int i = 0; i &lt; n; i++) nega[i] = -a[i]; reverse(nega.begin(), nega.end()); for(int i = 0; i &lt; n; i++) if(isp[k*a[i]]) sum[i]++; for(int i = n - 2; i &gt;= 0; i--) sum[i] += sum[i+1]; for(int i = m - 1; i &gt;= 0; i--){ auto ita = lower_bound(nega.begin(), nega.end(), -b[i]); int num = nega.end() - ita; res = max(res, count(b, b[i] - num + 1, b[i]) + sum[num]); } return res;}int main(){ int T; for(read(T); T; T--){ isp.clear(); int n, m; read(n, m); vi a1, a2, b1, b2; for(int i = 1; i &lt;= n; i++){ int a; read(a); if(a &lt; 0) a1.pb(-a); else a2.pb(a); } for(int i = 1; i &lt;= m; i++){ int b; read(b); isp[b] = true; if(b &lt; 0) b1.pb(-b); else b2.pb(b); } reverse(a1.begin(), a1.end()); reverse(b1.begin(), b1.end()); printf(&quot;%d\\n&quot;, solve(a1, b1, -1) + solve(a2, b2, 1)); } return 0;} D. Dogeforces递归。考察当前矩阵，其中的最大数必然是根结点的值，于是最大数对应的行和列必定处于根结点的不同子树中，如此我们可以得到各个叶节点所在的子树，然后分别对各子树递归处理即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int n, a[N][N], tot, fa[N], salary[N];bool vis[N];vi edge[N];void dfs(int x, vi &amp;sub){ vis[x] = true; sub.pb(x); for(auto &amp;to : edge[x]){ if(vis[to]) continue; dfs(to, sub); }}int solve(vi v){ if(v.size() == 1){ salary[v[0]] = a[v[0]][v[0]]; return v[0]; } int mxa = -1; for(auto &amp;i : v){ for(auto &amp;j : v) mxa = max(mxa, a[i][j]); vis[i] = false, edge[i].clear(); } for(auto &amp;i : v) for(auto &amp;j : v) if(a[i][j] &lt; mxa &amp;&amp; i != j) edge[i].pb(j), edge[j].pb(i); vector&lt;vi&gt; sub; for(auto &amp;i : v){ if(!vis[i]){ sub.pb(vi()); dfs(i, sub.back()); } } vi ids; for(auto &amp;sv : sub) ids.pb(solve(sv)); tot++; for(auto &amp;id : ids) fa[id] = tot; salary[tot] = mxa; return tot;}int main(){ read(n); tot = n; vi v; for(int i = 1; i &lt;= n; i++){ v.pb(i); for(int j = 1; j &lt;= n; j++) read(a[i][j]); } solve(v); printf(&quot;%d\\n&quot;, tot); for(int i = 1; i &lt;= tot; i++) printf(&quot;%d &quot;, salary[i]); puts(&quot;&quot;); printf(&quot;%d\\n&quot;, tot); for(int i = 1; i &lt;= tot - 1; i++) printf(&quot;%d %d\\n&quot;, i, fa[i]); return 0;} E. A-Z Graph首先，要存在这样的路径，必然至少有一对 $(u,v)$ 满足有向边 $u\\to v$ 和 $v\\to u$ 同时存在。 这时，如果 $k$ 是奇数，那么 $u\\to v\\to u\\to\\cdots\\to v\\to u$ 就是一条合法路径； 如果 $k$ 是偶数，假设 $a_1\\to\\cdots\\to a_k$ 是一条合法路径，则必然其正中间的那条边 $u\\to v$ 要和 $v\\to u$ 的权重相同，也就是说存在一对 $(u,v)$ 满足 $u\\to v$ 和 $v\\to u$ 同时存在且相等；于是我们取 $u\\to v\\to\\cdots\\to u\\to v$ 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, m, cnt, cnteq;map&lt;pii, char&gt; edge;int main(){ read(n, m); while(m--){ char opt[10]; scanf(&quot;%s&quot;, opt); if(opt[0] == '+'){ int u, v; char c[10]; scanf(&quot;%d%d%s&quot;, &amp;u, &amp;v, c); edge[mp(u, v)] = c[0]; if(edge.find(mp(v, u)) != edge.end()){ cnt++; if(edge[mp(v, u)] == c[0]) cnteq++; } } else if(opt[0] == '-'){ int u, v; read(u, v); if(edge.find(mp(v, u)) != edge.end()){ cnt--; if(edge[mp(v, u)] == edge[mp(u, v)]) cnteq--; } edge.erase(mp(u, v)); } else{ int u; read(u); if((u &amp; 1) &amp;&amp; cnt &gt; 0) puts(&quot;YES&quot;); else if(!(u &amp; 1) &amp;&amp; cnteq &gt; 0) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } } return 0;}","link":"/blog-xcpc/2021/03/06/Educational-Codeforces-Round-105/"},{"title":"Educational Codeforces Round 82","text":"比赛链接 / 官方题解链接 A. Erasing ZeroSolution删去第一个 $1$ 和最后一个 $1$ 之间的 $0$. Code>folded1234567891011121314151617181920212223242526272829303132#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}int T;char s[105];int main(){ read(T); while(T--){ int fir = 105, lst = 0, cnt = 0; scanf(&quot;%s&quot;, s+1); int n = strlen(s+1); for(int i = 1; i &lt;= n; i++){ if(s[i] == '1'){ fir = min(fir, i); lst = max(lst, i); } } for(int i = fir; i &lt;= lst; i++) if(s[i] == '0') cnt++; printf(&quot;%d\\n&quot;, cnt); } return 0;} B. National ProjectSolution找到达到要求的 “good day” 在第几块（一个连续 $g$ 天算一“块”），计算此时够不够 $n$ 天。 Code>folded12345678910111213141516171819202122232425262728#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T;LL n, g, b;int main(){ read(T); while(T--){ read(n, g, b); LL m = (n + 1) / 2; LL x = m / g; LL remain = m - x * g; if(m % g != 0) x++; if(m % g == 0) remain += g; if((x - 1) * (b + g) + remain &gt;= n) printf(&quot;%lld\\n&quot;, (x - 1) * (b + g) + remain); else printf(&quot;%lld\\n&quot;, n); } return 0;} C. Perfect KeyboardSolution检查字母是否形成一条链，特判一个字母的情况。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 205;int T;char s[N];bool vis[N], g[N][N];vector&lt;int&gt; v[N];vector&lt;char&gt; ans;void dfs(int x){ vis[x] = 1; ans.push_back(x+'a'-1); for(int i = 0; i &lt; v[x].size(); i++){ if(vis[v[x][i]]) continue; dfs(v[x][i]); }}int main(){ read(T); while(T--){ scanf(&quot;%s&quot;, s+1); int n = strlen(s+1); if(n == 1){ puts(&quot;YES&quot;); for(int i = 1; i &lt;= 26; i++) putchar(i+'a'-1); puts(&quot;&quot;); continue; } ans.clear(); for(int i = 1; i &lt;= 26; i++) v[i].clear(); memset(vis, 0, sizeof vis); memset(g, 0, sizeof g); for(int i = 1; i &lt; n; i++){ if(!g[s[i]-'a'+1][s[i+1]-'a'+1]){ g[s[i]-'a'+1][s[i+1]-'a'+1] = g[s[i+1]-'a'+1][s[i]-'a'+1] = true; v[s[i]-'a'+1].push_back(s[i+1]-'a'+1); v[s[i+1]-'a'+1].push_back(s[i]-'a'+1); } } bool cntbigger2 = false; int cnt1 = 0, mark = 0; for(int i = 1; i &lt;= 26; i++){ if(v[i].size() &gt; 2){ cntbigger2 = true; break; } if(v[i].size() == 1){ cnt1++; if(!mark) mark = i; } } if(cntbigger2 || cnt1 != 2){ puts(&quot;NO&quot;); continue; } dfs(mark); puts(&quot;YES&quot;); for(int i = 0; i &lt; ans.size(); i++) printf(&quot;%c&quot;, ans[i]); for(int i = 1; i &lt;= 26; i++) if(!vis[i]) putchar(i+'a'-1); puts(&quot;&quot;); } return 0;} D. Fill The BagSolution显然 $n&gt;\\sum a_i$ 时无解，否则一定有解。 设 $bn$ 是 $n$ 的二进制表示，$bt$ 每一位是对应 $a_i$ 的出现次数，那么题述操作可转化为： $bt$ 低位 $2$ 变高位 $1$，花费 $0$. 例如：$105020\\rightarrow121100$ $bt$ 高位 $1$ 拆成低位 $2$，花费 $1$. 例如：$101000\\rightarrow100200$ 从低到高依次考虑 $bn$ 中的 $1$，先尝试用 $bt$ 的低位合成高位消去它（花费 $0$），不行的话就用 $bt$ 的高位拆成低位消去它（花费 $=$ 高位与低位的差）。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int T, m, pt1, pt2;LL n, a[N], ans;int bt[100], bn[100];int main(){ read(T); while(T--){ memset(bt, 0, sizeof bt); memset(bn, 0, sizeof bn); read(n, m); LL sum = 0; for(int i = 1; i &lt;= m; i++) read(a[i]), sum += a[i]; if(n &gt; sum){ puts(&quot;-1&quot;); continue; } for(int i = 1; i &lt;= m; i++) bt[(int)log2(a[i])]++; while(n){ bn[(int)log2(n)]++; n -= (LL)pow(2, (LL)log2(n)); } pt1 = pt2 = 0; ans = 0; while(1){ while(pt1 &lt;= 60 &amp;&amp; bn[pt1] == 0) pt1++; if(pt1 &gt; 60) break; for(int i = 0; i &lt; pt1; i++){ if(bt[i] &gt;= 2){ bt[i+1] += bt[i] / 2; bt[i] %= 2; } } if(bt[pt1]){ bt[pt1] -= bn[pt1], bn[pt1] = 0; continue; } pt2 = pt1; while(pt2 &lt;= 60 &amp;&amp; bt[pt2] == 0) bt[pt2]++, pt2++; bt[pt2]--; ans += pt2 - pt1; bt[pt1] -= bn[pt1], bn[pt1] = 0; } printf(&quot;%lld\\n&quot;, ans); } return 0;} E. Erase SubsequencesSolution【参考官方题解】$t$ 是由两部分拼成的，自然可以想到枚举拼接点，把 $t$ 拆成 $a,b$ 两块。问题转化成：已知 $a,b$，判断 $s$ 能否通过题目操作生成 $a,b$. 考虑 $dp$： $dp$ 状态：设 $dp[i][j]$ 表示能生成 $a$ 的前 $i$ 位和 $b$ 的前 $j$ 位的 $s$ 中最小位置。 转移方程：设 $k=dp[i-1][j]$，则我们已经知道 $a$ 的前 $i-1$ 位和 $b$ 的前 $j$ 位至少需要从 $s_{1…k}$ 生成出来，现在在 $t$ 后面加上 $a_i$，则 $s$ 中的最小位置就是 $k$ 之后第一个出现 $a_i$ 的位置。为此，我们预处理一个 $nxt[pos][ch]$，用来表示 $s$ 中 $pos$ 位置之后第一个 $ch$ 的位置。于是乎，$dp[i][j] = nxt[k][a_i]$；同理，设 $l = dp[i][j-1]$，有 $dp[i][j]=nxt[l][b_j]$，二者取最小即可。 转移顺序：由方程可知，循环 $i,j$ 即可。 边界条件：$dp[0][0] = 0$ Code&gt;folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 405;int T;char s[N], t[N];int dp[N][N], nxt[N][200];int main(){ read(T); while(T--){ scanf(&quot;%s&quot;, s+1); scanf(&quot;%s&quot;, t+1); memset(dp, 0, sizeof dp); int n = strlen(s+1), m = strlen(t+1); for(int k = 'a'; k &lt;= 'z'; k++) nxt[n][k] = nxt[n+1][k] = n+1; for(int i = n-1; i &gt;= 0; i--){ for(int k = 'a'; k &lt;= 'z'; k++){ if(s[i+1] == k) nxt[i][k] = i + 1; else nxt[i][k] = nxt[i+1][k]; } } bool ok = false; for(int k = 1; k &lt;= m; k++){ for(int i = 0; i &lt; k; i++){ for(int j = 0; j &lt;= m - k + 1; j++){ dp[i][j] = 1e9; if(!i &amp;&amp; !j){ dp[i][j] = 0; continue; } if(i) dp[i][j] = min(dp[i][j], nxt[dp[i-1][j]][t[i]]); if(j) dp[i][j] = min(dp[i][j], nxt[dp[i][j-1]][t[j+k-1]]); } } if(dp[k-1][m-k+1] &lt;= n &amp;&amp; dp[k-1][m-k+1] &gt; 0) ok = true; } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} F. Number of ComponentsSolution【参考官方题解】我们单独考虑每个颜色。由于 $c_i\\leq c_{i+1}$，所以对于每个颜色来说，一定是先加再删，不会在删之后有加入的情况。加的过程用并查集维护当前时间与上一时间的连通块改变量；删的过程是一个经典的删边并查集，即倒序加入，维护的倒序改变量即正序的负的改变量。 Tricks：为编程方便，我们可以增加在 $q+1$ 时间处删掉所有颜色的操作；然后并查集维护改变量，也就是说答案数组是一个差分数组。 Code&gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int N = 305;const int Q = 2000005;int n, m, q, g[N][N], maxc;bool b[N][N];int ans[Q];inline int num(int x, int y){ return (x - 1) * m + y; }vector&lt; pair&lt;pii, int&gt; &gt; add[Q];vector&lt; pair&lt;pii, int&gt; &gt; del[Q];int fa[N*N];int findfa(int x){ return fa[x] == x ? x : fa[x] = findfa(fa[x]); }inline bool unionn(int x, int y){ if(findfa(x) == findfa(y)) return false; fa[findfa(y)] = findfa(x); return true;}inline void cal(vector&lt; pair&lt;pii, int&gt; &gt; &amp;vec, int coeff){ for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) fa[num(i, j)] = num(i, j), b[i][j] = false; for(int k = 0; k &lt; vec.size(); k++){ int res = 1; int t = vec[k].second, x = vec[k].first.first, y = vec[k].first.second; b[x][y] = true; if(x &gt; 1 &amp;&amp; b[x-1][y]) res -= unionn(num(x, y), num(x-1, y)); if(x &lt; n &amp;&amp; b[x+1][y]) res -= unionn(num(x, y), num(x+1, y)); if(y &gt; 1 &amp;&amp; b[x][y-1]) res -= unionn(num(x, y), num(x, y-1)); if(y &lt; m &amp;&amp; b[x][y+1]) res -= unionn(num(x, y), num(x, y+1)); ans[t] += coeff * res; }}int main(){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= q; i++) { int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); if(g[x][y] == c) continue; maxc = max(maxc, c); del[g[x][y]].pb(mp(mp(x, y), i)); add[c].pb(mp(mp(x, y), i)); g[x][y] = c; } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) del[g[i][j]].pb(mp(mp(i, j), q + 1)); for(int i = 0; i &lt;= maxc; i++){ cal(add[i], 1); reverse(del[i].begin(), del[i].end()); cal(del[i], -1); } ans[0] = 1; for(int i = 1; i &lt;= q; i++) printf(&quot;%d\\n&quot;, ans[i] += ans[i-1]); return 0;} G. Sum of Prefix SumsSolution【参考官方题解】树上路径问题，考虑点分治。 先思考一个简化版本：求 $s_1+s_2+\\cdots+s_k$ 的最大值。那么我们在计算经过重心的路径时，只需要统计来自不同子树的权值最大路径即可，而且这些路径的一端一定是叶节点。 现在观察要求的式子：$$s_1+(s_1+s_2)+\\cdots+(s_1+s_2+\\cdots+s_k)=k\\cdot s_1+(k-1)s_2+\\cdots+s_k=\\sum\\limits_{i=1}^k(k-i+1)s_i$$其值与路径长度挂钩，我们只好无奈地对于每个叶节点都去考虑其他子树中的叶节点对它的答案。一对一考虑是 $O(n^2)$ 的，需要对上式进行一些调整：设分治点为 $c$，它的一个子树 $A$ 有叶节点 $x$，另一个子树 $B$ 有叶节点 $y$，从 $x$ 到 $c$ 的路径上的数字是 $a_1,a_2,\\cdots,a_k$（包括 $c$），从 $c$ 到 $y$ 路径上的数字是 $b_1,b_2,\\cdots,b_l$（不包括 $c$）。 设 $sum_A=\\sum\\limits_{i=1}^ka_i$，$psum_A=\\sum\\limits_{i=1}^k(k-i+1)a_i$，$psum_B=\\sum\\limits_{i=1}^l(l-i+1)b_i$，那么原式可写作：$$\\sum\\limits_{i=1}^k(k-i+1)s_i=psum_A+psum_B+l\\cdot sum_A$$上文提到，我们要枚举每个叶节点，计算它与其他子树的叶节点的答案。假设我们正在枚举一个叶节点 $y$，也就固定了 $l$ 和 $psum_B$，视 $sum_A$ 为斜率，$psum_A$ 为截距，那么上式是一条直线在 $x=l$ 处的值加上 $psum_B$. 要求所有这些直线在 $x=l$ 处的最大值，就是一个李超线段树的模板了。 枚举按照一下顺序：正着扫一遍子树，每扫到一个子树先在李超树中询问，然后将其加入李超树，然后再反过来扫一遍（因为路径答案与方向有关）。 注意： 特判只有一个子树的情况 清空李超树时用一个回收队列记录，不要直接全部清空（破坏复杂度） Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int N = 150005;const int INF = 1e9;struct LiChaoTree{ static inline LL getVal(int x, double k, double b){ return k * x + b; } struct segTree{ int l, r; LL k, b; }tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((l + r) &gt;&gt; 1) queue&lt;int&gt; recycle; void clear(){ while(!recycle.empty()){ tr[recycle.front()].k = tr[recycle.front()].b = 0; recycle.pop(); } } void insert(int id, int l, int r, double k, double b){ if(l == r){ if(getVal(mid, k, b) &gt; getVal(mid, tr[id].k, tr[id].b)) tr[id].k = k, tr[id].b = b, recycle.push(id); return; } if(k &gt; tr[id].k){ if(getVal(mid, k, b) &gt; getVal(mid, tr[id].k, tr[id].b)){ insert(lid, l, mid, tr[id].k, tr[id].b); tr[id].k = k, tr[id].b = b, recycle.push(id); } else insert(rid, mid+1, r, k, b); } else{ if(getVal(mid, k, b) &gt; getVal(mid, tr[id].k, tr[id].b)){ insert(rid, mid+1, r, tr[id].k, tr[id].b); tr[id].k = k, tr[id].b = b, recycle.push(id); } else insert(lid, l, mid, k, b); } } LL query(int id, int l, int r, int x){ if(l == r) return getVal(x, tr[id].k, tr[id].b); if(x &lt;= mid) return max(getVal(x, tr[id].k, tr[id].b), query(lid, l, mid, x)); else return max(getVal(x, tr[id].k, tr[id].b), query(rid, mid+1, r, x)); }}lichao;int n;LL a[N], ans;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int root, sum, mxson[N], siz[N];bool vis[N];void getRoot(int x, int f){ mxson[x] = 0, siz[x] = 1; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f || vis[edge[i].to]) continue; getRoot(edge[i].to, x); siz[x] += siz[edge[i].to]; mxson[x] = max(mxson[x], siz[edge[i].to]); } mxson[x] = max(mxson[x], sum - siz[x]); if(mxson[root] &gt; mxson[x]) root = x;}LL sumA[N], psumA[N], psumB[N], lB[N];vector&lt;int&gt; vec[N];void getVal(int x, int f, int d, LL SumA, LL SumB){ sumA[x] = SumA, psumA[x] = psumA[f] + d * a[x]; lB[x] = d - 1, psumB[x] = psumB[f] + SumB; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f || vis[edge[i].to]) continue; getVal(edge[i].to, x, d + 1, SumA + a[edge[i].to], SumB + a[edge[i].to]); }}void getVec(int k, int x, int f){ bool isLeaf = true; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f || vis[edge[i].to]) continue; isLeaf = false; getVec(k, edge[i].to, x); } if(isLeaf) vec[k].push_back(x);}void solve(int x){ int cnt = 0; // count the number of subtrees for(int i = head[x]; i; i = edge[i].nxt){ if(vis[edge[i].to]) continue; cnt++; } if(cnt == 0){ // no subtree ans = max(ans, a[x]); return; } getVal(x, 0, 1, a[x], 0); vector&lt;int&gt; nxt; // store subtree for(int i = head[x]; i; i = edge[i].nxt){ if(vis[edge[i].to]) continue; nxt.push_back(edge[i].to); vec[edge[i].to].clear(); getVec(edge[i].to, edge[i].to, x); // store the leaves } if(cnt == 1){ // only 1 subtree for(int k = 0; k &lt; vec[edge[head[x]].to].size(); k++){ int p = vec[edge[head[x]].to][k]; ans = max(ans, psumA[p]); ans = max(ans, psumB[p] + a[x] * (lB[p] + 1)); } } else{ // &gt;= 2 subtrees --- use Li Chao Tree to update the answer lichao.clear(); for(int j = 0; j &lt; nxt.size(); j++){ for(int k = 0; k &lt; vec[nxt[j]].size(); k++){ int p = vec[nxt[j]][k]; ans = max(ans, lichao.query(1, 1, n, lB[p]) + psumB[p]); } for(int k = 0; k &lt; vec[nxt[j]].size(); k++){ int p = vec[nxt[j]][k]; lichao.insert(1, 1, n, sumA[p], psumA[p]); } } lichao.clear(); for(int j = nxt.size() - 1; j &gt;= 0; j--){ for(int k = 0; k &lt; vec[nxt[j]].size(); k++){ int p = vec[nxt[j]][k]; ans = max(ans, lichao.query(1, 1, n, lB[p]) + psumB[p]); } for(int k = 0; k &lt; vec[nxt[j]].size(); k++){ int p = vec[nxt[j]][k]; lichao.insert(1, 1, n, sumA[p], psumA[p]); } } } vis[x] = true; for(int i = head[x]; i; i = edge[i].nxt){ if(vis[edge[i].to]) continue; root = 0, sum = siz[edge[i].to], mxson[0] = INF; getRoot(edge[i].to, 0); solve(root); }}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); } for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); root = 0, sum = n, mxson[0] = INF; getRoot(1, 0); solve(root); printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/02/13/Educational-Codeforces-Round-82/"},{"title":"Educational Codeforces Round 83","text":"比赛链接 / 官方题解链接 A. Two Regular PolygonsSolution原问题等价于 $m$ 能否整除 $n$. Code>folded12345678910111213141516171819202122#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T, n, m;int main(){ read(T); while(T--){ read(n, m); if(n % m) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } return 0;} B. BogosortSolution倒序排序即可。 Code>folded12345678910111213141516171819202122232425#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T, n, a[105];bool cmp(int A, int B){ return A &gt; B; }int main(){ read(T); while(T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1, cmp); for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); putchar(10); } return 0;} C. Adding PowersSolution把每一个数表示成 $k$ 进制数，若不能表示成 $k$ 进制或有两个 $k$ 进制数同时存在某一位，输出 NO。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T, n;LL a, k;bool b[100];inline bool div(LL x){ if(!x) return true; int i; LL t = 1; for(i = 1; ; i++){ if(t * k &gt; x || t * k &lt; 0) break; t *= k; } for(int j = i - 1; j &gt;= 0; j--, t /= k){ if(x &gt;= t){ if(b[j]) return false; b[j] = true; x -= t; } } if(x &gt; 0) return false; return true;}int main(){ read(T); while(T--){ read(n, k); memset(b, 0, sizeof b); bool ok = true; for(int i = 1; i &lt;= n; i++){ read(a); if(!div(a)) ok = false; } if(!ok) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } return 0;} D. Count the ArraysSolution推一波式子。 枚举最高点 $k$，设其值为 $r\\ (n-1\\leq r\\leq m)$，则从 $1\\sim r-1$ 中选出 $n-2$ 个数，有 $C_{r-1}^{n-2}$ 种选法；然后从这 $n-2$ 个数之中选一个数重复一遍，有 $C_{n-2}^1$ 种选法；现在得到了 $n-1$ 个数（$1$ 个重复），从除开重复的 $n-3$ 个数中选 $k-2$ 个放在 $k$ 之前，其余的自然放在 $k$ 之后，共 $C_{n-3}^{k-2}$ 种选法。故答案为：$$\\sum\\limits_{k=2}^{n-1}\\sum\\limits_{r=n-1}^m C_{r-1}^{n-2}C_{n-2}^1C_{n-3}^{k-2}=(n-2)\\cdot\\left[\\sum\\limits_{k=2}^{n-1}C_{n-3}^{k-2}\\right]\\cdot\\left[\\sum\\limits_{r=n-1}^mC_{r-1}^{n-2}\\right]=(n-2)\\cdot2^{n-3}\\cdot C_{m}^{n-1}$$组合数预处理阶乘及其逆元即可。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const LL MOD = 998244353;int n, m;LL fac[200005], invfac[200005], ans;LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res % MOD;}inline LL C(LL a, LL b){ return fac[a] * invfac[b] % MOD * invfac[a-b] % MOD; }int main(){ fac[0] = 1, invfac[0] = 1; for(int i = 1; i &lt;= 200000; i++){ fac[i] = fac[i-1] * i % MOD; invfac[i] = fpow(fac[i], MOD - 2); } read(n, m); printf(&quot;%lld\\n&quot;, n == 2 ? 0 : (n - 2) * fpow(2, n-3) % MOD * C(m, n-1) % MOD); return 0;} E. Array ShrinkingSolution区间 dp. 设 $dp[i][j]$ 表示 $a[i\\cdots j]$ 的最小长度，那么枚举中间的断点进行转移：$dp[i][j]=dp[i][k]+dp[k+1][j]$（不考虑合并）；我们只在 $dp[i][k]=dp[k+1][j]=1$ 且可以合并的情况下考虑合并，因为所有的合并都一定可以拆成若干长度为 $1$ 的项的合并。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 505;int n, a[N], dp[N][N], v[N][N];int main(){ memset(dp, 0x7f, sizeof dp); read(n); for(int i = 1; i &lt;= n; i++){ read(a[i]); dp[i][i] = 1; v[i][i] = a[i]; } for(int l = 1; l &lt;= n; l++){ for(int i = 1; i &lt;= n; i++){ int j = i + l; if(j &gt; n) break; for(int k = i; k &lt; j; k++){ if(dp[i][k] == 1 &amp;&amp; dp[k+1][j] == 1 &amp;&amp; v[i][k] == v[k+1][j]){ dp[i][j] = 1; v[i][j] = v[i][k] + 1; } else dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]); } } } printf(&quot;%d\\n&quot;, dp[1][n]); return 0;} F. Attack on Red Kingdom G. AutocompletionSolution题目的输入方式其实自然构成了一棵 Trie 树。我们按字典序 $dfs$ 这棵 Trie 树，维护每个点的答案。具体的，当前点的答案至少是上一个点的答案 $+1$（即在上一个点之后输入一个字符）；然后如果当前点在 $S$ 中，它也有可能来自其某个祖先的 autocompletion，考虑怎么处理这部分。 我们对每个点记录它的列表中第一个还没被遍历到的点是列表的第几个点，所以初始情况是所有点的记录均为 $1$。随后，凡遍历到一个 $S$ 中的点，就将它的所有祖先以及它自己的记录 $+1$，表示以后的点想要使用 autocompletion 功能时，必须要在列表中花费一秒走过这个点；由于我们是按照字典序遍历的，所以这些 $+1$ 累加起来就是走过已经遍历过的点一共需要花费的时间。处理完当前点之后，把当前点答案加入记录，意思是从这个点往下转移时先要加上到达这个点的时间。这样遇到下一个 $S$ 中的点时，用其所有祖先的最小记录值更新答案即可。 上述过程涉及到区间加与区间求最小值，可以开线段树做。线段树的下标选用树的深度最为方便（用 $dfs$ 序也可，实现上稍微麻烦一点）。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 1000005;int n, k, ans[N], a[N];bool mark[N];struct Node{ char ch; int id; Node(char ch, int id): ch(ch), id(id) {} bool operator &lt; (const Node &amp;A) const{ return ch &lt; A.ch; }};vector&lt;Node&gt; trie[N];struct segTree{ int l, r, mn, lazy;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].mn = min(tr[lid].mn, tr[rid].mn);}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazy){ tr[lid].lazy += tr[id].lazy; tr[lid].mn += tr[id].lazy; tr[rid].lazy += tr[id].lazy; tr[rid].mn += tr[id].lazy; tr[id].lazy = 0; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].mn = 1; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazy += val; tr[id].mn += val; return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}int query(int id, int l, int r){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].mn; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else return min(query(lid, l, mid), query(rid, mid+1, r));}void setVal(int id, int pos, int val){ pushdown(id); if(tr[id].l == tr[id].r){ tr[id].mn = val; tr[id].lazy = 0; return; } if(pos &lt;= mid) setVal(lid, pos, val); else setVal(rid, pos, val); pushup(id);}void dfs(int x, int f, int dep){ if(x){ ans[x] = ans[f] + 1; if(mark[x]){ ans[x] = min(ans[x], query(1, 1, dep - 1)); add(1, 1, dep, 1); } add(1, dep, dep, ans[x]); } for(auto to: trie[x]) dfs(to.id, x, dep+1); setVal(1, dep, 1);}int main(){ read(n); build(1, 1, n+1); for(int i = 1; i &lt;= n; i++){ int p; char ch[2]; read(p); scanf(&quot;%s&quot;, ch); trie[p].push_back(Node(ch[0], i)); } for(int i = 0; i &lt; n; i++) sort(trie[i].begin(), trie[i].end()); read(k); for(int i = 1; i &lt;= k; i++){ read(a[i]); mark[a[i]] = true; } dfs(0, -1, 1); for(int i = 1; i &lt;= k; i++) printf(&quot;%d &quot;, ans[a[i]]); return 0;}","link":"/blog-xcpc/2020/03/10/Educational-Codeforces-Round-83/"},{"title":"Educational Codeforces Round 84","text":"比赛链接 / 官方题解链接 A. Sum of Odd IntegersSolution先判断奇偶性，再判断是否 $n\\geq1+3+\\cdots(2k-1)=k^2$. 比赛时 $k^2$ 没开 long long WA 了一发…… Code>folded123456789101112131415161718192021222324252627#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;long long T, n, k;int main(){ read(T); while(T--){ read(n, k); if((n &amp; 1) ^ (k &amp; 1)) puts(&quot;NO&quot;); else{ if(n &lt; k * k) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } } return 0;} B. Princesses and PrincesSolution先按题意模拟，如果有剩余没匹配上的就加上去；否则输出 OPTIMAL. Code以下是比赛代码，很丑～ >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 100005;int T, n;vector&lt;int&gt; v[N];bool b[N], p[N];inline void init(){ memset(b, 0, sizeof b); memset(p, 0, sizeof p); for(int i = 1; i &lt;= n; i++) v[i].clear();}int main(){ read(T); while(T--){ read(n); init(); for(int i = 1; i &lt;= n; i++){ int k; read(k); for(int j = 1; j &lt;= k; j++){ int t; read(t); v[i].push_back(t); } } int cnt = 0; for(int i = 1; i &lt;= n; i++){ for(auto k: v[i]){ if(!b[k]){ b[k] = p[i] = true; cnt++; break; } } } if(cnt == n) puts(&quot;OPTIMAL&quot;); else{ puts(&quot;IMPROVE&quot;); int k = 0; for(k = 1; k &lt;= n; k++) if(!b[k]) break; int t = 0; for(t = 1; t &lt;= n; t++) if(!p[t]) break; printf(&quot;%d %d\\n&quot;, t, k); } } return 0;} C. Game with ChipsSolution把所有点堆到 $(1,1)$，然后一起遍历整个棋盘即可。 Code>folded12345678910111213141516171819202122232425262728293031#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int n, m, k, t;int main(){ read(n, m, k); for(int i = 1; i &lt;= k; i++) scanf(&quot;%*d%*d&quot;, &amp;t, &amp;t); for(int i = 1; i &lt;= k; i++) scanf(&quot;%*d%*d&quot;, &amp;t, &amp;t); if(n == 1 &amp;&amp; m == 1) return puts(&quot;0&quot;), 0; printf(&quot;%d\\n&quot;, n * m + n + m - 3); for(int i = 1; i &lt; m; i++) putchar('L'); for(int i = 1; i &lt; n; i++) putchar('U'); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt; m; j++) putchar((i &amp; 1) ? 'R' : 'L'); if(i &lt; n) putchar('D'); } return 0;} D. Infinite PathSolution由于 $p[]$ 是一个排列，所以 $p[]$ 事实上构成了多个不交叉的有向环。**$p$ 的 $k$ 层迭代其实就是走 $k$ 步能到达的节点**。于是乎找出所有环，枚举环长度的因数，拆出小环，判断是否颜色相同，答案取 $\\min$ 即可。 复杂度：$O(n\\sqrt n)$ Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;int T, n, p[N], c[N], ans = 1e9;bool b[N];vector&lt;int&gt; v[N];inline void getAns(int i, vector&lt;int&gt; a){ for(int k = 0; k &lt; i; k++){ bool ok = true; for(int j = k; j &lt; a.size(); j += i){ if(c[a[j]] != c[a[k]]){ ok = false; break; } } if(ok) ans = min(ans, i); }}inline void solve(vector&lt;int&gt; a){ int t = a.size(); for(int i = 1; i * i &lt;= a.size(); i++){ if(a.size() % i) continue; while(t % i == 0 &amp;&amp; i != 1) t /= i; getAns(i, a); if(i * i == a.size()) break; getAns(a.size() / i, a); } if(t &gt; 1) getAns(t, a);}inline void init(){ ans = 1e9; memset(b, 0, sizeof b); for(int i = 1; i &lt;= n; i++) v[i].clear();}int main(){ read(T); while(T--){ read(n); init(); for(int i = 1; i &lt;= n; i++){ read(p[i]); v[i].emplace_back(p[i]); } for(int i = 1; i &lt;= n; i++) read(c[i]); for(int i = 1; i &lt;= n; i++){ if(b[i]) continue; vector&lt;int&gt; a; int now = i; while(!b[now]){ b[now] = true; a.emplace_back(now); now = p[now]; } solve(a); } printf(&quot;%d\\n&quot;, ans); } return 0;} E. Count the BlocksSolution推一波式子。 考虑某个长度为 $i$ 的块，有多少种序列能包含它。首先，若它被放在序列中间，则与它两端相邻的数字有 $9$ 种填法，剩余 $(n-i-2)$ 个数字有 $10$ 种填法，再乘上有 $10$ 种数字填充这个块，且这个块能被放到 $(n-i-1)$ 种中间位置上去，所以位于序列中间的长度为 $i$ 的块共有 $9^2\\times10^{n-i-2}\\times10\\times(n-i-1)$ 种；若它被放到两端，则与它另一端相邻的数字有 $9$ 种填法，剩余 $(n-i-1)$ 个数字有 $10$ 种填法，再乘上有 $10$ 种数字填充这个块，且这个块能被放到 $2$ 种位置上去，所以位于两端的长度为 $i$ 的块共有 $9\\times10^{n-i-1}\\times10\\times2$ 种填法；综上，长度为 $i$ 的块被$$9^2\\times10^{n-i-2}\\times10\\times(n-i-1)+9\\times10^{n-i-1}\\times10\\times2$$种序列所包含，答案即此。当然这是 $n-i-2\\geq0$ 的时候，其他情况讨论更少、不再赘述。 Code>folded123456789101112131415161718192021222324252627282930313233#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 200005;const LL MOD = 998244353;int n;LL power[N] = {1};int main(){ read(n); for(int i = 1; i &lt;= n; i++) power[i] = power[i-1] * 10 % MOD; for(int i = 1; i &lt;= n; i++){ if(n - i - 2 &gt;= 0) printf(&quot;%lld &quot;, 9 * power[n - i - 1] % MOD * (9 * n - 9 * i + 11) % MOD); else if(n - i - 1 &gt;= 0) printf(&quot;%lld &quot;, 18 * power[n - i] % MOD); else puts(&quot;10&quot;); } return 0;} F. AND SegmentsSolution参考博客 每一位可以单独考虑。题目给定的条件可以转化为：区间必须全为 $1$，或区间至少有 $1$ 个 $0$. 设 $dp[i]$ 表示最后一个 $0$ 填在第 $i$ 位时的方案数，则依次循环考虑每个数，若该位置可以填 $0$，则 $dp[i]$ 更新为 $\\sum\\limits_{j=f[i]}^{i-1}dp[j]$，其中 $f[i]$ 表示最大的整个区间都在第 $i$ 位之前且值为 $0$ 的区间左端点。因为如果 $j&lt;f[i]$，说明 $j+1\\sim i$ 这一段全填 $1$，与题目条件违背。 实现上，判断一个点是否必须填 $1$ 可采用差分数组+前缀和；而 $dp$ 转移方程中的求和可以用一个变量 $sum$ 存储——$sum$ 随时加上新的 $dp[i]$，减去不符合条件（ $j&lt;f[i]$ ）的 $dp[j]$ 。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 500005;const LL MOD = 998244353;int n, k, m;LL ans = 1;struct Node{ int l, r, x;}a[N];int main(){ read(n, k, m); for(int i = 1; i &lt;= m; i++) read(a[i].l, a[i].r, a[i].x); for(int b = 0; b &lt; k; b++){ vector&lt;LL&gt; ones(n+5, 0); vector&lt;int&gt; f(n+5, 0); vector&lt;LL&gt; dp(n+5, 0); for(int i = 1; i &lt;= m; i++){ if((a[i].x &gt;&gt; b) &amp; 1) ones[a[i].l]++, ones[a[i].r+1]--; else f[a[i].r] = max(f[a[i].r], a[i].l); } dp[0] = 1; LL sum = 1; int pre = 0; for(int i = 1; i &lt;= n; i++){ ones[i] += ones[i-1]; if(!ones[i]) dp[i] = sum % MOD; (sum += dp[i]) %= MOD; while(pre &lt; f[i]){ sum -= dp[pre]; ((sum %= MOD) += MOD) %= MOD; pre++; } } (ans *= sum) %= MOD; } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/03/24/Educational-Codeforces-Round-84/"},{"title":"Educational Codeforces Round 85","text":"比赛链接 / 官方题解链接 A. Level StatisticsSolution显然，$p$ 和 $c$ 必须非降， $c$ 不大于 $p$ 且 $c$ 增幅不大于 $p$. Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, p[105], c[105];int main(){ read(T); while(T--){ read(n); for(int i = 1; i &lt;= n; i++) read(p[i], c[i]); bool ok = true; for(int i = 1; i &lt;= n; i++){ if(p[i] &lt; p[i-1]){ ok = false; break; } if(c[i] &lt; c[i-1]){ ok = false; break; } if(c[i] &gt; p[i]){ ok = false; break; } if(p[i] - p[i-1] &lt; c[i] - c[i-1]){ ok = false; break; } } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0;} B. Middle ClassSolution从大到小排个序，不断把多的削成 $x$ 移给下一个即可。容易知道这样做其实和均分答案是相同的（可以削平成 $x$ 的数均分后一定也不小于 $x$，不能削平成 $x$ 的数均分后一定都小于 $x$）。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n;LL x, a[N];bool cmp(int A, int B){ return A &gt; B; }int main(){ read(T); while(T--){ read(n, x); for(int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1, cmp); LL rem = 0; for(int i = 1; i &lt;= n; i++){ if(a[i] &lt; x) break; rem = a[i] - x; a[i+1] += rem; } int cnt = 0; for(int i = 1; i &lt;= n; i++) cnt += a[i] &gt;= x; printf(&quot;%d\\n&quot;, cnt); } return 0;} C. Circle of MonstersSoution对于每个怪物来说，它的 $a$ 减去它前一个怪物的 $b$ 是一定需要我们开枪打死的血量，把它们加起来之后，枚举第一个打死的怪物，取代价最小者。 Code>folded12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 300005;int T, n;LL a[N], b[N], c[N];int main(){ read(T); while(T--){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i], b[i]); LL ans = 0; for(int i = 1; i &lt;= n; i++){ int j = i + 1; if(j == n + 1) j = 1; c[j] = max(0ll, a[j] - b[i]); ans += c[j]; } LL mn = 1e16; for(int i = 1; i &lt;= n; i++) mn = min(mn, a[i] - c[i]); printf(&quot;%lld\\n&quot;, ans + mn); } return 0;} D. Minimum Euler CycleSolution路线一定是这样的：$[1,2,1,3,1,4,\\cdots,1,n],[2,3,2,4,\\cdots,2,n],[3,4,\\cdots,3,n],\\cdots,[n-1,n],1$（为了体现出规律，用括号把序列分段了）。所以根据该规律，给出位置 $x$，就能找到对应的数。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int T, n;LL l, r, s[N];inline LL get(LL x){ LL k = lower_bound(s+1, s+n, x) - s; x -= s[k-1]; LL t = (x + 1) / 2; // k, k+t if(x &amp; 1) return k; else return k + t;}int main(){ read(T); while(T--){ bool ok = false; read(n, l, r); for(LL i = 1; i &lt;= n - 1; i++) s[i] = 2 * (n - i) + s[i-1]; for(LL i = l; i &lt;= r; i++) printf(&quot;%lld &quot;, i == 1ll * n * (n - 1) + 1 ? 1 : get(i)); puts(&quot;&quot;); } return 0;} E. Divisor PathsSolution【参考：dls的视频】 由于所有数都是 $D$ 的因数，设 $D$ 的质因数有 $k$ 个，那么把每个数质因数分解后可以看成一个 $k$ 维向量。$x$ 与 $y$ 之间有边表明这两个向量有且仅有一维差 $1$，于是原图其实是一个 $k$ 维空间的网格图。 设 $d(x)$ 表示 $x$ 的因数个数，那么对于路径 $a_1\\rightarrow a_2\\rightarrow\\cdots\\rightarrow a_l$，其长度就是 $d(a_l)-d(a_1)$. 考虑 $u,v$ 两点之间的最短路，发现应该是 $u\\rightarrow gcd(u,v)\\rightarrow v$ 这么一条路径。于是问题转化成如何求出 $u\\rightarrow gcd(u,v)$ 和 $v\\rightarrow gcd(u,v)$ 的路径数量，二者乘积就是答案。 这其实是一个多重集的排列数问题，对于 $n_1$ 个 $1$，$n_2$ 个 $2$，$\\cdots$，$n_t$ 个 $t$，$n_1+\\cdots+n_t=n$，排列总数是 $C(n;n_1,\\cdots,n_t)=\\frac{n!}{n_1!\\cdots n_t!}$. Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;LL, LL&gt; pll;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 998244353;LL gcd(LL a, LL b){ return b == 0 ? a : gcd(b, a % b); }LL fpow(LL bs, LL idx){ LL res = 1; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}vector&lt;pll&gt; getPrimeFactors(LL x){ vector&lt;pll&gt; res; for(LL i = 2; i * i &lt;= x; i++){ int cnt = 0; while(x % i == 0){ x /= i; cnt++; } if(cnt) res.pb(mp(i, cnt)); } if(x &gt; 1) res.pb(mp(x, 1)); return res;}LL D, fact[60] = {1}, invfact[60] = {1};int q;vector&lt;pll&gt; d;LL solve(LL x, LL y){ LL res = 1, sum = 0; for(auto k: d){ int cntx = 0, cnty = 0; while(x % k.first == 0) x /= k.first, cntx++; while(y % k.first == 0) y /= k.first, cnty++; (res *= invfact[cntx - cnty]) %= MOD; sum += cntx - cnty; } (res *= fact[sum]) %= MOD; return res;}int main(){ for(int i = 1; i &lt;= 50; i++){ fact[i] = fact[i-1] * i % MOD; invfact[i] = fpow(fact[i], MOD - 2); } read(D, q); d = getPrimeFactors(D); while(q--){ LL u, v; read(u, v); LL g = gcd(u, v); printf(&quot;%lld\\n&quot;, solve(u, g) * solve(v, g) % MOD); } return 0;} F. Strange FunctionSolution【参考：dls的视频】 设 $dp[i][j]$ 表示考虑 $a$ 中前 $i$ 个数，匹配了 $b$ 中前 $j$ 个数的最小代价，则转移如下： 若 $b[j]==a[i]$，$dp[i][j]$ 可以从 $dp[i-1][j]$ 转移而来，代价加上 $\\min(0,p[i])$（即可选可不选）；也可以从 $dp[i-1][j-1]$ 转移而来，此时必选。 若 $b[j]&gt;a[i]$，$dp[i][j]$ 从 $dp[i-1][j]$ 转移而来，代价加上 $\\min(0,p[i])$（即可选可不选）。 若 $b[j]&lt;a[i]$，$dp[i][j]$ 从 $dp[i-1][j]$ 转移而来且 $a[i]$ 一定不能选，所以代价加上 $p[i]$。 $dp$ 数组的第一维可以滚掉，空间问题解决；转移无非就是区间加和单点查询，所以线段树维护 $dp$ 数组。 时间复杂度：$O(n\\lg m)$ Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const LL INF = 1e18;const int N = 500005;struct segTree{ int l, r; LL lazy, mn;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l+tr[id].r)&gt;&gt;1)inline void pushup(int id){ tr[id].mn = min(tr[lid].mn, tr[rid].mn);}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazy){ tr[lid].lazy += tr[id].lazy; tr[lid].mn += tr[id].lazy; tr[rid].lazy += tr[id].lazy; tr[rid].mn += tr[id].lazy; tr[id].lazy = 0; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].lazy = 0, tr[id].mn = INF; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, LL val){ if(l &gt; r) return; pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazy += val; tr[id].mn += val; return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}LL query(int id, int pos){ pushdown(id); if(tr[id].l == tr[id].r) return tr[id].mn; if(pos &lt;= mid) return query(lid, pos); else return query(rid, pos);}int n, a[N], m, b[N];LL p[N];int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= n; i++) read(p[i]); read(m); for(int i = 1; i &lt;= m; i++) read(b[i]); build(1, 0, m); add(1, 0, 0, -INF); b[m+1] = 1e6; for(int i = 1; i &lt;= n; i++){ int pos = lower_bound(b+1, b+m+1, a[i]) - b; int posl = pos - 1; if(a[i] == b[pos]){ LL now = query(1, pos), x = query(1, pos-1); add(1, pos, pos, min(now + min(0ll, p[i]), x) - now); pos++; } if(pos &lt;= m) add(1, pos, m, min(0ll, p[i])); if(posl &gt;= 0) add(1, 0, posl, p[i]); } LL res = query(1, m); if(res &gt;= 1e16) puts(&quot;NO&quot;); else puts(&quot;YES&quot;), printf(&quot;%lld\\n&quot;, res); return 0;}","link":"/blog-xcpc/2020/04/11/Educational-Codeforces-Round-85/"},{"title":"Educational Codeforces Round 86","text":"比赛链接 / 官方题解链接 A. Road To ZeroSolution先把两个数减到相同，再一起减到 $0$. Code>folded12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL x, y, a, b;int main(){ for(read(T); T; T--){ read(x, y, a, b); if(b &gt; 2 * a) b = 2 * a; if(x &gt; y) swap(x, y); LL ans = (y - x) * a; ans += x * b; printf(&quot;%lld\\n&quot;, ans); } return 0;} B. Binary PeriodSolution如果 $t$ 中字符全部相同那么输出 $t$ 即可；否则以 $01$ 为循环节输出。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;char t[205], s[205];int main(){ for(read(T); T; T--){ scanf(&quot;%s&quot;, t+1); int len = strlen(t+1); int sid = 0; bool same = true; for(int i = 1; i &lt;= len; i++) if(t[i] != t[1]){ same = false; break; } if(same){ printf(&quot;%s\\n&quot;, t+1); continue; } int now = 0; for(int i = 1; i &lt;= len; i++){ if(t[i] != now + '0'){ s[++sid] = now + '0'; now ^= 1; i--; } else{ s[++sid] = now + '0'; now ^= 1; } } if(s[sid] == '0') s[++sid] = '1'; s[++sid] = '\\0'; printf(&quot;%s\\n&quot;, s+1); } return 0;} C. Yet Another Counting ProblemSolution$[1,ab]$ 是一个循环节，可以先预处理出 $f[1\\sim ab]$ 存储答案的前缀和，则 $1\\sim U$ 的答案就是 $f[ab]\\cdot\\left\\lfloor\\frac{U}{ab}\\right\\rfloor+f[U\\mod(ab)]$. $[L,R]$ 的答案即是 $[1,R]$ 的答案减去 $[1,L-1]$ 的答案。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)LL gcd(LL a, LL b){ return b == 0 ? a : gcd(b, a % b); }int T, q;LL a, b, L, R, f[40005];inline LL calc(LL U){ return f[a*b] * (U / (a*b)) + f[U%(a*b)];}int main(){ for(read(T); T; T--){ read(a, b, q); memset(f, 0, sizeof f); for(int i = 1; i &lt;= 40000; i++){ if((i % a) % b != (i % b) % a) f[i]++; f[i] += f[i-1]; } while(q--){ read(L, R); printf(&quot;%lld &quot;, calc(R) - calc(L-1)); } puts(&quot;&quot;); } return 0;} D. Multiple TestcasesSolution从大到小贪心放置 $m_i$，每次寻找第一个可放置 $m_i$ 的 testcase，可放置当且仅当这个 testcase 里现有元素个数严格小于 $m_i$ 允许个数。所以我们需要单点修改、查找小于某数的第一个位置，用值域线段树可解决。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, k, m[N], c[N], mx;vector&lt;int&gt; a[N];struct segTree{ int mn;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((l + r) &gt;&gt; 1)inline void pushup(int id){ tr[id].mn = min(tr[lid].mn, tr[rid].mn);}void build(int id, int l, int r){ tr[id].mn = 0; if(l == r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int x){ if(l == r){ tr[id].mn++; return; } if(x &lt;= mid) add(lid, l, mid, x); else add(rid, mid+1, r, x); pushup(id);}int query(int id, int l, int r, int val){ if(l == r) return l; if(tr[lid].mn &lt; val) return query(lid, l, mid, val); else return query(rid, mid+1, r, val);}int main(){ read(n, k); for(int i = 1; i &lt;= n; i++) read(m[i]); sort(m+1, m+n+1); reverse(m+1, m+n+1); for(int i = 1; i &lt;= k; i++) read(c[i]); build(1, 1, n); for(int i = 1; i &lt;= n; i++){ int limit = c[min(k, m[i])]; int pos = query(1, 1, n, limit); a[pos].pb(m[i]); add(1, 1, n, pos); mx = max(mx, pos); } printf(&quot;%d\\n&quot;, mx); for(int i = 1; i &lt;= mx; i++){ printf(&quot;%d &quot;, (int)a[i].size()); for(auto k: a[i]) printf(&quot;%d &quot;, k); puts(&quot;&quot;); } return 0;} E. Placing RooksSolution要使每一个格子都被攻击到，有两种情况——每一行都有且仅有一个车，或者每一列都有且仅有一个车。 只考虑每一行都有且仅有一个车的情形：如果我们想要有 $k$ 个车互相攻击，那么我们需要把 $n$ 个车放在 $n-k$ 列中——因为每把一个车放到非空的列上时，能互相攻击的车数加一。所以问题变成了把 $n$ 个车放到 $c$ 列中且每列不空的方案数。这可以容斥：总数是 $c^n$，即每个车都有 $c$ 中选择，减去有空列的方案数——至少有一个空列的方案数为 $C_c^1(c-1)^n$，至少有两个空列的方案数为 $C_c^2(c-2)^n$，……，因此答案是 $\\sum\\limits_{i=0}^c(-1)^iC_c^i(c-i)^n$. 乘上 $C_n^c$，即选择哪些列放车，就是每一行有且只有一个车的情形的答案。 如果 $k=0$，那么每一行有且仅有一个车和每一列有且仅有一个车情形重合；否则，答案再乘上 $2$. Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;const LL MOD = 998244353;LL n, k, C[N] = {1}, inv[N];LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int main(){ read(n, k); k = n - k; for(int i = 1; i &lt;= k; i++){ if(i == 1) inv[i] = 1; else{ inv[i] = -(MOD / i) * inv[MOD % i] % MOD; ((inv[i] %= MOD) += MOD) %= MOD; } C[i] = C[i-1] * (k - i + 1) % MOD * inv[i] % MOD; } LL res = 0; for(int i = 0; i &lt;= k; i++){ (res += ((i &amp; 1) ? -1 : 1) * C[i] % MOD * fpow(k - i, n) % MOD) %= MOD; (res += MOD) %= MOD; } LL CC = 1; for(int i = 1; i &lt;= k; i++) (CC *= (n - i + 1) * inv[i] % MOD) %= MOD; printf(&quot;%lld\\n&quot;, (1 + (k != n)) * CC * res % MOD); return 0;}","link":"/blog-xcpc/2020/04/27/Educational-Codeforces-Round-86/"},{"title":"Educational Codeforces Round 87","text":"比赛链接 / 官方题解链接 rating 大涨174！开心～～～ A. Alarm ClockSolution如果 $a\\leq b$，那么时间就是 $b$；否则，如果定的时间内睡不着，无解；否则，答案就是 $b+\\left\\lceil\\frac{a-b}{c-d}\\right\\rceil\\times c$. Code>folded123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)LL T, a, b, c, d;int main(){ for(read(T); T; T--){ read(a, b, c, d); if(a &lt;= b){ printf(&quot;%lld\\n&quot;, b); continue; } if(c &lt;= d){ puts(&quot;-1&quot;); continue; } LL res = b + (a - b) / (c - d) * c; if((a - b) % (c - d)) res += c; printf(&quot;%lld\\n&quot;, res); } return 0;} B. Ternary StringSolution设 $d[i][1/2/3]$ 表示第 $i$ 个数之前（包括本身）的第一个 $0/1/2$ 的位置。这个可以很容易 dp 得到。 于是对于以 $i$ 为右端点的区间，$\\min{d[i][1],d[i][2],d[i][3]}$ 就是最大的包含 $0,1,2$ 至少一次的左端点，用区间长度更新答案。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int T, d[N][10];char s[N];int main(){ for(read(T); T; T--){ scanf(&quot;%s&quot;, s+1); int n = strlen(s+1); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= 3; j++){ if(s[i] == j + '0') d[i][j] = i; else d[i][j] = d[i-1][j]; } } int ans = 1e9; for(int i = 3; i &lt;= n; i++){ int pos = min(d[i][1], min(d[i][2], d[i][3])); if(pos == 0) continue; ans = min(ans, i - pos + 1); } if(ans == 1e9) puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;, ans); } return 0;} C1. Simple Polygon EmbeddingSolution$n$ 为偶数，最小的能框住正 $2n$ 边形的正方形长这样（$n=4$ 画了完整的图，$n=6,8$ 只画了圆圈内的部分）： 按这个规律码就行了。 P.S. 我果然做复杂了……答案就是 $\\frac{1}{\\tan{\\frac{\\pi}{2\\cdot n}}}$. Code>folded123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const double pi = acos(-1);int T, n;int main(){ for(read(T); T; T--){ read(n); double theta = pi / n, ans = 0; int m = (n - 2) / 2; for(int i = 1; i &lt;= m / 2; i++) ans += sin(theta * i) + cos(theta * i); if(m &amp; 1) ans += 1 / sqrt(2); printf(&quot;%.10f\\n&quot;, ans * 2 + 1); } return 0;} C2. Not So Simple Polygon EmbeddingSolution$n$ 为奇数，最小的能框住正 $2n$ 边形的正方形长这样（$n=4$ 画了完整的图，$n=6,8$ 只画了圆圈内的部分）： 找到正方形的边与哪个顶点触碰（该顶点是第一个倾角大于等于 45 度的顶点），就可以计算了。 P.S. 是的我又做复杂了，答案就是 $\\frac{\\cos(\\frac{\\pi}{4n})}{\\sin(\\frac{\\pi}{2n})}$. Code>folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const double pi = acos(-1);int T, n;int main(){ for(read(T); T; T--){ read(n); double theta = pi / n, ans = 0; int m = (n - 1) / 2; double x = 0, y = 0; x = 0.5; int k = 0; for(k = 1; k &lt;= m; k++) if(k * theta * 4 &gt;= pi) break; for(int i = 1; i &lt; k; i++){ x += cos(theta * i); y += sin(theta * i); } double h = 0; for(int i = 1; i &lt;= m; i++) h += sin(theta * i); ans = (h - y + x) * sqrt(2); printf(&quot;%.10f\\n&quot;, ans); } return 0;} D. MultisetSolution用值域线段树模拟题目操作。 好吧，其实用树状数组就可以了。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1000005;int n, q;struct segTree{ int size;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((l + r) &gt;&gt; 1)void pushup(int id){ tr[id].size = tr[lid].size + tr[rid].size;}void insert(int id, int l, int r, int val){ if(l == r){ tr[id].size++; return; } if(val &lt;= mid) insert(lid, l, mid, val); else insert(rid, mid+1, r, val); pushup(id);}void delRank(int id, int l, int r, int rk){ if(l == r){ tr[id].size--; return; } if(tr[lid].size &gt;= rk) delRank(lid, l, mid, rk); else delRank(rid, mid+1, r, rk - tr[lid].size); pushup(id);}int findRank(int id, int l, int r, int rk){ if(l == r) return l; if(tr[lid].size &gt;= rk) return findRank(lid, l, mid, rk); else return findRank(rid, mid+1, r, rk - tr[lid].size);}int main(){ read(n, q); for(int i = 1; i &lt;= n; i++){ int a; read(a); insert(1, 1, n, a); } while(q--){ int a; read(a); if(a &lt; 0) delRank(1, 1, n, -a); else insert(1, 1, n, a); } if(tr[1].size &gt; 0) printf(&quot;%d\\n&quot;, findRank(1, 1, n, 1)); else puts(&quot;0&quot;); return 0;} E. Graph ColoringSolution首先发现性质：如果图中存在奇环，那么一定不可行。 于是现在图中没有奇环，也即该图是若干个连通的二分图。我们只需要在每一个二分图中选择一侧填 $2$，另一侧填 $1$ 或 $3$，问是否存在一个方案使得 $2$ 的数量等于 $n2$（$1$ 和 $3$ 的数量自然就是 $n1+n3$ 了）。 这是一个简单的 dp：记 $a[i],b[i]$ 表示第 $i$ 个二分图的两侧的点数，设 $dp[i][j]$ 表示前 $i$ 个二分图能否选出 $j$ 个点填 $2$，那么，$dp[i][j]=dp[i-1][j-a[i]]\\ \\mathrm{OR}\\ dp[i-1][j-b[i]]$. 这玩意儿其实可以用 bitset 优化，但是这道题犯不着。 至于输出方案，我们在 dp 的过程中记录一下转移的路径，就可以从末状态倒着推回去了。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 5005;const int M = 100005;int n, m, n1, n2, n3, n0;int a[N][2], id;vi v[N][2];bool dp[N][N], ans[N];int which[N][N];struct Edge{ int nxt, to;}edge[M&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int col[N];void dfs(int x, int c){ col[x] = c; for(int i = head[x]; i; i = edge[i].nxt){ if(col[edge[i].to] == -1) dfs(edge[i].to, c ^ 1); else if(col[edge[i].to] == c){ puts(&quot;NO&quot;); exit(0); } }}bool vis[N];void dfs(int x){ vis[x] = true; a[id][col[x]]++; v[id][col[x]].pb(x); for(int i = head[x]; i; i = edge[i].nxt){ if(vis[edge[i].to]) continue; dfs(edge[i].to); }}int main(){ memset(col, -1, sizeof col); memset(which, -1, sizeof which); read(n, m); read(n1, n2, n3); n0 = n1 + n3; for(int i = 1; i &lt;= m; i++){ int u, v; read(u, v); addEdge(u, v), addEdge(v, u); } for(int i = 1; i &lt;= n; i++) if(col[i] == -1) dfs(i, 0); for(int i = 1; i &lt;= n; i++) if(!vis[i]) ++id, dfs(i); dp[0][0] = true; for(int i = 1; i &lt;= id; i++){ for(int j = 0; j &lt;= n2; j++){ if(j &gt;= a[i][0]){ dp[i][j] |= dp[i-1][j-a[i][0]]; if(dp[i-1][j-a[i][0]]) which[i][j] = 0; } if(j &gt;= a[i][1]){ dp[i][j] |= dp[i-1][j-a[i][1]]; if(dp[i-1][j-a[i][1]]) which[i][j] = 1; } } } if(!dp[id][n2]) return puts(&quot;NO&quot;), 0; puts(&quot;YES&quot;); int now = n2; for(int i = id; i &gt;= 1; i--){ for(auto k: v[i][which[i][now]]) ans[k] = true; now -= a[i][which[i][now]]; } int cnt = 0; for(int i = 1; i &lt;= n; i++){ if(!ans[i]){ if(cnt &lt; n1) printf(&quot;1&quot;), cnt++; else printf(&quot;3&quot;); } else printf(&quot;2&quot;); } puts(&quot;&quot;); return 0;} F. Summoning MinionsSolution【参考官方题解】首先我们找到一些贪心的性质：所有兵都应该被召唤（如果某兵没有被召唤，召唤它之后再删掉它不会使答案更差）；最终应该召唤满 $k$ 个兵（如果不满 $k$ 个，我们没有必要删掉某些兵）；如果一个兵会被删去，我们可以再召唤它之后立刻删掉它，对答案无影响。 基于上述性质，我们的策略是：先召唤 $k-1$ 个兵；再召唤 $n-k$ 个兵，并且一召唤出来就立刻删掉它；最后召唤 $1$ 个兵。 先召唤的 $k-1$ 个兵中，第 $j$ 个召唤的兵对答案的贡献是 $a_i+(j-1)\\cdot b_i$；随后召唤的 $n-k$ 个兵对答案的贡献都是 $(k-1)\\cdot b_i$；最后一个兵对答案的贡献是 $a_i+(k-1)\\cdot b_i$. 于是我们可以把 $n$ 个兵到 $n$ 个位置（一共 $n^2$ 个数对）对答案的贡献算出来。我们现在需要找到一个配对方式，使得每一个位置被分配一个兵。于是可以网络流解决：以兵和位置为顶点建图，某兵到某位置的边的流量为 $1$，费用为该兵到该位置的对答案的贡献；然后源点向每个兵连流量为 $1$，费用为 $0$ 的边；每个位置向汇点连流量为 $1$，费用为 $0$ 的边。跑最小费用最大流（因为题目要求价值最大，所以上述连边中费用全部取负，跑出来的最小费用取负就是最大价值）。输出方案的话，哪条边满流了就说明那条边是一个匹配。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200;const int INF = 1e9;int T, n, k, a[N], b[N];struct Edge{ int nxt, to, flow, cost;}edge[N*N*2];int head[N], edgeNum = 1;void addEdge(int from, int to, int flow, int cost){ edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].flow = flow; edge[edgeNum].cost = cost; head[from] = edgeNum;}int src, dst;int minCost[N], minFlow[N], pre[N];bool inq[N];int spfa(){ for(int i = 1; i &lt;= n; i++){ minCost[i] = minFlow[i] = INF; pre[i] = 0; inq[i] = 0; } queue&lt;int&gt; q; q.push(src); inq[src] = 1; minCost[src] = 0; while(!q.empty()){ int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt){ if(edge[i].flow &amp;&amp; minCost[edge[i].to] &gt; minCost[cur] + edge[i].cost){ minCost[edge[i].to] = minCost[cur] + edge[i].cost; minFlow[edge[i].to] = min(minFlow[cur], edge[i].flow); pre[edge[i].to] = i; if(!inq[edge[i].to]){ q.push(edge[i].to); inq[edge[i].to] = 1; } } } } if(pre[dst] == 0) return -1; return minFlow[dst];}void EK(int &amp;maxflow, int &amp;mincost){ maxflow = mincost = 0; int flow = 0; while((flow = spfa()) != -1){ int t = dst; while(t != src){ edge[pre[t]].flow -= flow; edge[pre[t]^1].flow += flow; t = edge[pre[t]^1].to; } maxflow += flow; mincost += flow * minCost[dst]; }}int main(){ for(read(T); T; T--){ read(n, k); edgeNum = 1; memset(head, 0, sizeof head); for(int i = 1; i &lt;= n; i++){ read(a[i], b[i]); for(int j = 1; j &lt;= n; j++){ if(j &lt; k){ addEdge(i, j+n, 1, - a[i] - (j - 1) * b[i]); addEdge(j+n, i, 0, a[i] + (j-1) * b[i]); } else if(j &lt; n){ addEdge(i, j+n, 1, -(k-1) * b[i]); addEdge(j+n, i, 0, (k-1) * b[i]); } else{ addEdge(i, j+n, 1, - a[i] - (k-1) * b[i]); addEdge(j+n, i, 0, a[i] + (k-1) * b[i]); } } } int nn = n; n &lt;&lt;= 1; src = ++n, dst = ++n; for(int i = 1; i &lt;= nn; i++){ addEdge(src, i, 1, 0), addEdge(i, src, 0, 0); addEdge(i+nn, dst, 1, 0), addEdge(dst, i+nn, 0, 0); } int maxflow, mincost; EK(maxflow, mincost); printf(&quot;%d\\n&quot;, k + 2 * (nn - k)); for(int j = 1; j &lt;= nn; j++){ for(int i = head[j+nn]; i; i = edge[i].nxt){ if(edge[i].to == dst) continue; if(edge[i^1].flow == 0){ if(j &lt; k) printf(&quot;%d &quot;, edge[i].to); else if(j &lt; nn) printf(&quot;%d %d &quot;, edge[i].to, -edge[i].to); else printf(&quot;%d\\n&quot;, edge[i].to); break; } } } } return 0;}","link":"/blog-xcpc/2020/05/17/Educational-Codeforces-Round-87/"},{"title":"Educational Codeforces Round 89","text":"比赛链接 / 官方题解链接 A. Shovels and SwordsSolution答案是 $\\min\\left{\\left\\lfloor\\frac{a+b}{3}\\right\\rfloor,a,b\\right}$. Code>folded1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, a, b;int main(){ for(read(T); T; T--){ read(a, b); printf(&quot;%d\\n&quot;, min((a + b) / 3, min(a, b))); } return 0;} B. ShuffleSolution能换的下标一定构成一个区间，扫一遍所有操作，如果当前操作与目前的区间有交，就更新区间的左右端点。 Code>folded123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 105;int T, n, x, m, l[N], r[N];int main(){ for(read(T); T; T--){ read(n, x, m); int L = x, R = x; for(int i = 1; i &lt;= m; i++){ read(l[i], r[i]); if(l[i] &lt;= R &amp;&amp; L &lt;= r[i]){ L = min(L, l[i]); R = max(R, r[i]); } } printf(&quot;%d\\n&quot;, R - L + 1); } return 0;} C. Palindromic PathsSolution可以证明：所有路径均为回文的充要条件是：对于 $2\\leq k\\leq n+m$，所有满足 $i+j=k\\ 或\\ n+m+2-k$ 的 $a[i][j]$ 均相等。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 35;int T, n, m, g[N][N];int main(){ for(read(T); T; T--){ int ans = 0; read(n, m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) read(g[i][j]); for(int p = 2; p &lt;= n + m; p++){ int q = n + m + 2 - p; if(p &gt;= q) break; int cnt[2] = {0}; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(i + j == p || i + j == q) cnt[g[i][j]]++; ans += min(cnt[0], cnt[1]); } printf(&quot;%d\\n&quot;, ans); } return 0;} D. Two DivisorsSolution分解质因数 $x={p_1}^{r_1}\\cdot {p_2}^{r_2}\\cdots{p_k}^{r_k}$，则取 $d_1={p_1}^{r_1},\\ d_2={p_2}^{r_2}\\cdots{p_k}^{r_k}$ 即可。 因为这样，对于 $x$ 的任一质因数 $a$，要么 $a\\mid d_1$，要么 $a\\mid d_2$，因此 $a\\nmid (d_1+d_2)$，于是 $(d_1+d_2)\\nmid x$. 那无解的情况就是 $x$ 只有一个质因数。 完成上述操作可以用线性筛，筛出质数的同时得到每个合数的最小质因数。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int MAX = 10000005;bool notP[MAX];int pList[MAX], pID, minDiv[MAX];void Euler(int n){ notP[0] = notP[1] = 1; for(int i = 1; i &lt;= n; i++){ if(!notP[i]) pList[++pID] = i; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; minDiv[i * pList[j]] = pList[j]; if(i % pList[j] == 0) break; } }}const int N = 500005;int n;vector&lt;pii&gt; ans;int main(){ Euler(10000000); read(n); for(int i = 1; i &lt;= n; i++){ int a; read(a); if(!notP[a]) ans.pb(mp(-1, -1)); else{ int d = minDiv[a]; while(a % d == 0) a /= d; if(a == 1) ans.pb(mp(-1, -1)); else ans.pb(mp(d, a)); } } for(auto &amp;k: ans) printf(&quot;%d &quot;, k.first); puts(&quot;&quot;); for(auto &amp;k: ans) printf(&quot;%d &quot;, k.second); return 0;} E. Two ArraysSolution由于 $b[]$ 单调递增的特点，针对 $a[]$ 开一个单调栈，对这个单调栈进行划分即可。第一划必须在第一个元素之前，对于第二划，找到单调栈中等于 $b[2]$ 的那个区间，设为 $(l,r]$（注意左开右闭），则第二划必须落在这个区间上，总共有 $r$ 对应的位置减去 $l$ 对应的位置那么多划法；后面类似。答案即所有划法之积。 Code>folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;const LL MOD = 998244353;int n, m;LL a[N], b[N];int main(){ read(n, m); for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= m; i++) read(b[i]); vector&lt;pii&gt; sta(n+5); int sn = 0; for(int i = 1; i &lt;= n; i++){ while(sn &gt; 0 &amp;&amp; sta[sn].first &gt; a[i]) sn--; sta[++sn] = mp(a[i], i); } if(sta[1].first != b[1]) return puts(&quot;0&quot;), 0; LL ans = 1; int lst = 0; for(int i = 2; i &lt;= m; i++){ int l = lst, r = lst; while(l &lt; sn &amp;&amp; sta[l+1].first &lt; b[i]) l++; if(l == sn) return puts(&quot;0&quot;), 0; while(r &lt; sn &amp;&amp; sta[r+1].first &lt;= b[i]) r++; (ans *= sta[r].second - sta[l].second) %= MOD; lst = r; } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/06/12/Educational-Codeforces-Round-89/"},{"title":"Educational Codeforces Round 88","text":"比赛链接 / 官方题解链接 A. Berland PokerSolution如果 jokers 数量小于等于手牌数量，就把所有 jokers 揽入自己手中；否则，剩余的 jokers 平摊给其他人。 Code>folded1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, n, m, k;int main(){ for(read(T); T; T--){ read(n, m, k); if(m &lt;= n / k) printf(&quot;%d\\n&quot;, m); else{ m -= n / k; int d = m / (k - 1); if(m % (k - 1)) d++; printf(&quot;%d\\n&quot;, n / k - d); } } return 0;} B. New Theatre SquareSolution对每一行单独计算，令 $y=\\min{y, 2x}$，然后优先放 $1\\times2$ 的瓷砖。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T, x, y, n, m;char s[1005];int main(){ for(read(T); T; T--){ read(n, m, x, y); if(y &gt; 2 * x) y = 2 * x; LL ans = 0; for(int i = 1; i &lt;= n; i++){ scanf(&quot;%s&quot;, s+1); for(int j = 1; j &lt;= m; j++){ if(s[j] == '.'){ if(j &lt; m &amp;&amp; s[j+1] == '.'){ ans += y; j++; } else ans += x; } } } printf(&quot;%lld\\n&quot;, ans); } return 0;} C. Mixing WaterSolution温度变化为：$h,\\frac{h+c}{2},\\frac{2h+c}{3},\\frac{h+c}{2},\\frac{3h+2c}{5},\\frac{h+c}{2},\\cdots$ 偶数项均为 $\\frac{h+c}{2}$，奇数（第 $2k-1$）项为 $\\frac{kh+(k-1)c}{2k-1}$. 由于所有温度均大于等于 $\\frac{h+c}{2}$，所以如果 $t\\leq\\frac{h+c}{2}$，那么答案就是 $2$；否则，我们在奇数项中寻找最接近答案的一项。 设第 $k$ 项温度正好是 $t$，那么 $\\frac{kh+(k-1)c}{2k-1}=t$，化简得：$k=\\frac{t-c}{2t-h-c}$. 由于实际上不会正好等于，我们比较一下 $k-1,k,k+1$ 就好。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)int T;LL c, h, t;inline double tem(LL k){ return (double)(k * h + (k-1) * c) / (2*k-1);}int main(){ for(read(T); T; T--){ read(h, c, t); if(t &lt;= 0.5 * (h + c)){ puts(&quot;2&quot;); continue; } LL k = (t - c) / (2 * t - h - c); LL ans = 2; double mn = t - 0.5 * (h + c); if(fabs(tem(k) - t) &lt; mn){ mn = fabs(tem(k) - t); ans = 2 * k - 1; } k--; if(fabs(tem(k) - t) &lt; mn){ mn = fabs(tem(k) - t); ans = 2 * k - 1; } k += 2; if(fabs(tem(k) - t) &lt; mn){ mn = fabs(tem(k) - t); ans = 2 * k - 1; } printf(&quot;%lld\\n&quot;, ans); } return 0;} D. Yet Another Yet Another TaskSolution注意到 $-30\\leq a_i\\leq30$ 范围很小，所以枚举最大值 $mx$，然后 $dp$ 寻找最大子段和，且子段中最大值不大于 $mx$. 设 $dp[i]$ 表示以 $a[i]$ 结尾的最大子段和（$a[i]$ 必选），并且要满足这个子段中最大值不大于 $mx$；设 $st[i]$ 表示这个最大子段和的起始位置，那么容易有 $dp$ 方程：$dp[i]=\\begin{cases}-INF,&amp;a[i]&gt;mx\\dp[i-1]+a[i],&amp;a[i]\\leq mx\\and dp[i-1]\\geq0\\a[i],&amp;a[i]\\leq mx\\and dp[i-1]&lt;0\\end{cases}$，对应有 $st[i]=\\begin{cases}无,&amp;a[i]&gt;mx\\st[i-1],&amp;a[i]\\leq mx\\and dp[i-1]\\geq0\\i,&amp;a[i]\\leq mx\\and dp[i-1]&lt;0\\end{cases}$. 如果 $[i,st[i]]$ 中包含了 $mx$，就用 $dp[i]-mx$ 去更新答案。 Code>folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, a[N], cnt[N][100], ans = -1e9;int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(a[i]); for(int j = -30; j &lt;= 30; j++) cnt[i][j+30] = cnt[i-1][j+30]; cnt[i][a[i]+30]++; } for(int mx = -30; mx &lt;= 30; mx++){ vi dp(n+5, -1e9), st(n+5, 0); for(int i = 1; i &lt;= n; i++){ if(a[i] &gt; mx) continue; if(dp[i-1] &lt; 0){ dp[i] = a[i]; st[i] = i; } else{ dp[i] = a[i] + dp[i-1]; st[i] = st[i-1]; } } for(int i = 1; i &lt;= n; i++){ if(dp[i] == -1e9) continue; if(cnt[i][mx+30] - cnt[st[i]-1][mx+30] &gt; 0) ans = max(ans, dp[i] - mx); } } printf(&quot;%d\\n&quot;, ans); return 0;} E. Modular StabilitySolution假设我们选取 $x=a_k$，那么取第一个模数为 $a_k$，可以知道答案应为 $0$；此时，若取第一个模数为 $a_1$，那么有：$a_k\\bmod a_1=0$，也即 $a_k$ 是 $a_1$ 倍数；同理我们可以证明：$a_2,a_3,\\cdots,a_k$ 均是 $a_1$ 的倍数。 至于有没有其他条件约束，我在比赛时没有去证明了（因为可以从样例中得到验证）。 所以我们枚举 $a_1$ 的取值，得到 $[1,n]$ 中 $a_1$ 的倍数的个数，设为 $m$，那么从这 $m-1$ 个数（剔除 $a_1$ 本身）选取 $k-1$ 个数作为 $a_2,a_3,\\cdots,a_k$ 即可，所以共有 $C_{m-1}^{k-1}$ 中选法。 Code>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const LL MOD = 998244353;const int N = 500005;LL n, k, ans, fact[N], invfact[N];inline LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}inline LL C(LL m, LL r){ return fact[m] * invfact[r] % MOD * invfact[m-r] % MOD;}int main(){ fact[0] = 1, invfact[0] = 1; for(int i = 1; i &lt;= 500000; i++){ fact[i] = i * fact[i-1] % MOD; invfact[i] = fpow(fact[i], MOD - 2); } read(n, k); if(n &lt; k) return puts(&quot;0&quot;); for(LL i = 1; i &lt;= n; i++){ LL cnt = n / i; if(cnt &lt; k) break; (ans += C(cnt - 1, k - 1)) %= MOD; } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/05/29/Educational-Codeforces-Round-88/"},{"title":"GMCPC2020 网络赛","text":"比赛链接 / 官方题解链接 B / C / D / G / I / J / N / O / Q水题，不多说 A记一个坑：$a\\sim z$ 的 $\\mathrm{ASCII}$ 码是 $97\\sim122$，直接加上 $10$ 会爆掉 char 类型。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)string s, dat;int get(){ int sz = dat.size(); if(sz != 8) return -1; int y = 0, m = 0, d = 0; for(int i = 0; i &lt;= 3; i++) y = y * 10 + dat[i] - '0'; if(y &lt; 1900 || y &gt; 2020) return -1; for(int i = 4; i &lt;= 5; i++) m = m * 10 + dat[i] - '0'; if(m &lt; 1 || m &gt; 12) return -1; for(int i = 6; i &lt;= 7; i++) d = d * 10 + dat[i] - '0'; if(d &lt; 1) return -1; if(m == 2){ if(y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)){ // leap year if(d &gt; 29) return -1; } else{ if(d &gt; 28) return -1; } } else if((m &lt;= 7 &amp;&amp; m % 2 == 1) || (m &gt;= 8 &amp;&amp; m % 2 == 0)){ // big if(d &gt; 31) return -1; } else{ // small if(d &gt; 30) return -1; } int res = y * 10000 + m * 100 + d; while(res &gt;= 10){ int ans = 0; while(res){ ans += res % 10; res /= 10; } res = ans; } return res;}int main(){ while(getline(cin, dat)){ LL k = get(); getline(cin, s); int len = s.size(); if(k == -1){ puts(&quot;none&quot;); continue; } bool ok = true; string ans; for(int i = 0; i &lt; len; i++){ if(s[i] == ' ') ans += '#'; else if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z'){ int t = s[i] - 'A' + 1; t += k; if(t &gt; 26) t %= 26; ans += (char)(t - 1 + 'A'); } else if(s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z'){ int t = s[i] - 'a' + 1; t += k; if(t &gt; 26) t %= 26; ans += (char)(t - 1 + 'a'); } else{ ok = false; break; } } if(!ok){ puts(&quot;none&quot;); continue; } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} H【参考官方题解】把原序列建成一个双向链表，然后从小到大考虑每个值作为区间第 $x$ 大的贡献，算完这个值的贡献就把它从链表中删去，这样链表中的所有值总是不小于当前值。于是欲知它是哪些区间的第 $x$ 大，就往前扫 $x-1$ 步，往后扫 $x-1$ 步，然后尺取长度为 $x$ 的区间。在往前往后扫的过程中记录一下后缀、前缀最大值，就可以在尺取过程中求得最大值。 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 10005;const int X = 105;int T, n, x;LL ans;struct Node{ LL val, pos; bool operator &lt; (const Node &amp;A) const{ return val &lt; A.val; }}a[N];struct List{ LL val, pre, suc;}lis[N];void del(int x){ int p = lis[x].pre, s = lis[x].suc; if(p != 0) lis[p].suc = s; if(s != n + 1) lis[s].pre = p; lis[x].pre = lis[x].suc = 0;}LL lmx[N], rmx[N], lid, rid;inline void solve(int i){ lid = rid = 0; int l = i; lmx[0] = rmx[0] = lis[i].val; while(lis[l].pre &amp;&amp; lid &lt; x - 1){ l = lis[l].pre; lid++; lmx[lid] = max(lmx[lid-1], lis[l].val); } int r = i; while(lis[r].suc != n + 1 &amp;&amp; rid &lt; x - 1){ r = lis[r].suc; rid++; rmx[rid] = max(rmx[rid-1], lis[r].val); } if(lid + rid + 1 &lt; x) return; int now = i, cnt = 0; while(lid + 1 + cnt &lt; x){ cnt++; now = lis[now].suc; } for(int k = l, t = lid; k &lt;= i &amp;&amp; t &gt;= 0; k = lis[k].suc, t--){ ans += 1ll * (max(lmx[t], rmx[cnt]) ^ (lis[i].val)) * (k - lis[k].pre) * (lis[now].suc - now); cnt++; if(cnt &gt; rid) break; now = lis[now].suc; }}int main(){ int CASES = 0; for(read(T); T; T--){ read(n, x); memset(lis, 0, sizeof lis); memset(lmx, 0, sizeof lmx); memset(rmx, 0, sizeof rmx); ans = 0; lis[0].val = lis[n+1].val = -1; for(int i = 1; i &lt;= n; i++){ read(a[i].val); a[i].pos = i; lis[i].val = a[i].val; lis[i].pre = i - 1; lis[i].suc = i + 1; lis[i - 1].suc = i; lis[i + 1].pre = i; } sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i++){ solve(a[i].pos); del(a[i].pos); } printf(&quot;Case #%d: %lld\\n&quot;, ++CASES, ans); } return 0;} K按照贪心顺序排序：如果 $i$ 在 $j$ 前比 $j$ 在 $i$ 前优，则 $a_i+\\max(a_j+b_j,b_i)\\leq a_j+\\max(a_i+b_i,b_j)$. 另外：其实按照 $b$ 排序就够了，证明见蓝书第二题。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int n;struct Node{ int a, b; bool operator &lt; (const Node &amp;A) const{ int t1 = max(a + b, a + A.a + A.b); int t2 = max(A.a + A.b, A.a + a + b); if(t1 == t2){ if(a == A.a) return b &lt; A.b; return a &lt; A.a; } return t1 &lt; t2; }}a[N];int main(){ read(n); for(int i = 1; i &lt;= n; i++) read(a[i].a, a[i].b); sort(a+1, a+n+1); int tot = 0, sum = 0; for(int i = 1; i &lt;= n; i++){ sum += a[i].a; tot = max(tot, sum + a[i].b); } printf(&quot;Project %d: %d\\n&quot;, n, tot); return 0;} L首先把价值为负的鱼剔掉。设 $dp[j]$ 表示选出的颜值最大为 $j$ 的最大价值，那么 $dp[a[i]]=\\max(dp[a[i]],dp[k]+w[i]),k\\leq a[i]$. 然后考虑优化，发现转移方程是求前缀最大值，我们只需要对 $dp[]$ 数组进行单点修改、求前缀最大，所以树状数组维护。 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 10005;int T, n, mnface = 1e9, mxface = -1e9;struct Node{ int face, val;}a[N];int c[100005];inline int lowbit(int x){ return x &amp; -x; }inline void upd(int x, int val){ while(x &lt;= mxface){ c[x] = max(c[x], val); x += lowbit(x); }}inline int getMax(int x){ int res = -1e9; while(x){ res = max(res, c[x]); x -= lowbit(x); } return res;}int main(){ int CASES = 0; for(read(T); T; T--){ read(n); mnface = 1e9, mxface = -1e9; for(int i = 1; i &lt;= n; i++){ int x; read(x); a[i].val = x / 10000; a[i].face = x % 10000; } int id = 0; for(int i = 1; i &lt;= n; i++) if(a[i].val &gt; 0) a[++id] = a[i]; n = id; if(n == 0){ printf(&quot;Case #%d: %d\\n&quot;, ++CASES, 0); continue; } for(int i = 1; i &lt;= n; i++) mnface = min(mnface, a[i].face); for(int i = 1; i &lt;= n; i++){ a[i].face -= mnface - 1; mxface = max(mxface, a[i].face); } int ans = 0; // from 1 to n memset(c, 0, sizeof c); for(int i = 1; i &lt;= n; i++){ int mx = getMax(a[i].face); upd(a[i].face, mx + a[i].val); } ans = max(ans, getMax(mxface)); // from n to 1 memset(c, 0, sizeof c); for(int i = n; i &gt;= 1; i--){ int mx = getMax(a[i].face); upd(a[i].face, mx + a[i].val); } ans = max(ans, getMax(mxface)); printf(&quot;Case #%d: %d\\n&quot;, ++CASES, ans); } return 0;} M把不同的化学元素看做不同的点，那么每一个化学物品就是一条边，要求不能出现环，所以并查集维护。 >folded123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int fa[N];inline int findfa(int x){ return x == fa[x] ? x : fa[x] = findfa(fa[x]); }inline void unionn(int x, int y){ fa[findfa(y)] = findfa(x); }int main(){ for(int i = 1; i &lt;= 100000; i++) fa[i] = i; int x, y, cnt = 0; while(1){ read(x); if(x == -1) break; read(y); if(findfa(x) == findfa(y)) cnt++; else unionn(x, y); } printf(&quot;%d\\n&quot;, cnt); return 0;} P设 $dp[i][0\\sim4]$ 表示前 $i$ 天、最后一天在 $0\\sim4$ 地点的去图书馆最多天数，转移很好写。 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;int n, dp[N][10], a[N][10];int main(){ read(n); for(int i = 1; i &lt;= n; i++){ read(a[i][1], a[i][2], a[i][3], a[i][4]); for(int j = 0; j &lt;= 4; j++){ if(j == 0){ for(int k = 0; k &lt;= 4; k++) dp[i][j] = max(dp[i][j], dp[i-1][k]); } else{ if(a[i][j]){ for(int k = 0; k &lt;= 4; k++){ if(j == k) dp[i][j] = max(dp[i][j], dp[i-1][k]); else dp[i][j] = max(dp[i][j], dp[i-1][k] + 1); } } } } } int ans = 0; for(int k = 0; k &lt;= 4; k++) ans = max(ans, dp[n][k]); printf(&quot;%d\\n&quot;, ans); return 0;} R考虑反面，如何求出长度为 $n$ 的不孤独的串的个数。 设 $dp[j]$ 表示最后一个 $b$ 的位置在 $j$ 的不孤独串的个数。从 $1$ 到 $n$ 依次考虑，设当前位置为 $i$，那么 $dp[i]=\\sum\\limits_{0\\leq j&lt;i且j\\neq i-2}dp[j]$，也即如果要在 $i$ 处放置 $b$，那么最后一个 $b$ 可以在除了 $i-2$ 以外的其余位置。此时，长度为 $i$ 的不孤独串的个数就是 $\\sum\\limits_{0\\leq j\\leq i且j\\neq i-1}dp[j]$，于是孤独串的个数就是 $2^i-\\sum\\limits_{0\\leq j\\leq i且j\\neq i-1}dp[j]$. 然后发现答案会爆 long long，所以要上高精度（或者写 Python）。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)struct BigNum{ vector&lt;int&gt; a; // a[n-1]...a[1]a[0] int neg; BigNum(){ a.clear(); neg = 1; } BigNum operator = (LL num){ a.clear(); do{ a.pb(num % 10); num /= 10; }while(num); return *this; } BigNum operator = (const string &amp;s){ a.clear(); int len = s.length(); for(int i = 0; i &lt; len; i++) a.pb(s[len-i-1] - '0'); return *this; } bool operator &lt; (const BigNum &amp;b) const{ if(a.size() != b.a.size()) return a.size() &lt; b.a.size(); for(int i = a.size() - 1; i &gt;= 0; i--) if(a[i] != b.a[i]) return a[i] &lt; b.a[i]; return false; } bool operator &gt; (const BigNum &amp;b) const{ return b &lt; *this; } bool operator &lt;= (const BigNum &amp;b) const{ return !(*this &gt; b); } bool operator &gt;= (const BigNum &amp;b) const{ return !(*this &lt; b); } bool operator != (const BigNum &amp;b) const{ return (*this &gt; b) || (*this &lt; b); } bool operator == (const BigNum &amp;b) const{ return !(*this &lt; b) &amp;&amp; !(*this &gt; b); } BigNum operator + (const BigNum &amp;b) const{ BigNum C; int x = 0; for(int i = 0, g = 0; ; i++){ if(g == 0 &amp;&amp; i &gt;= a.size() &amp;&amp; i &gt;= b.a.size()) break; x = g; if(i &lt; a.size()) x += a[i]; if(i &lt; b.a.size()) x += b.a[i]; C.a.pb(x % 10); g = x / 10; } return C; } BigNum operator - (const BigNum &amp;b) const{ BigNum C; BigNum A = *this; BigNum B = b; if(A &lt; B) C.neg = -1, swap(A, B); C.a.resize(A.a.size()); for(int i = 0; ; i++){ if(i &gt;= A.a.size() &amp;&amp; i &gt;= B.a.size()) break; if(i &gt;= B.a.size()) C.a[i] = A.a[i]; else C.a[i] = A.a[i] - B.a[i]; } for(int i = 0; ; i++){ if(i &gt;= C.a.size()) break; if(C.a[i] &lt; 0){ C.a[i] += 10; C.a[i+1]--; } } while(C.a.size() &gt; 1 &amp;&amp; C.a.back() == 0) C.a.pop_back(); return C; } BigNum operator * (const BigNum &amp;b) const{ BigNum C; C.a.resize(a.size() + b.a.size()); for(int i = 0; i &lt; a.size(); i++){ int g = 0; for(int j = 0; j &lt; b.a.size(); j++){ C.a[i+j] += a[i] * b.a[j] + g; g = C.a[i+j] / 10; C.a[i+j] %= 10; } C.a[i+b.a.size()] = g; } while(C.a.size() &gt; 1 &amp;&amp; C.a.back() == 0) C.a.pop_back(); return C; } BigNum operator / (const LL &amp;b) const{ BigNum C; C = *this; for(int i = C.a.size() - 1; i &gt;= 0; i--){ if(i) C.a[i-1] += C.a[i] % b * 10; C.a[i] /= b; } while(C.a.size() &gt; 1 &amp;&amp; C.a.back() == 0) C.a.pop_back(); return C; } BigNum operator / (const BigNum &amp;b) const{ BigNum L, R, ans, t; L = 0ll; R = *this; ans = 0ll; t = 1ll; while(L &lt;= R){ BigNum mid = (L + R) / 2; if((mid * b) &gt; (*this)) R = mid - t; else L = mid + t, ans = mid; } return ans; } BigNum operator % (const LL &amp;b) const{ BigNum B; B = b; return (*this) - (*this) / b * B; } BigNum operator % (const BigNum &amp;b) const{ return (*this) - (*this) / b * b; } BigNum operator += (const BigNum &amp;b){ *this = *this + b; return *this; } BigNum operator -= (const BigNum &amp;b){ *this = *this - b; return *this; } BigNum operator *= (const BigNum &amp;b){ *this = *this * b; return *this; } BigNum operator /= (const LL &amp;b){ *this = *this / b; return *this; } BigNum operator /= (const BigNum &amp;b){ *this = *this / b; return *this; } void println(){ if(neg == -1) putchar('-'); for(int i = a.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, a[i]); putchar(10); }};const int N = 105;int T, n;BigNum dp[N], f[N];BigNum power[N], two;int main(){ two = &quot;2&quot;; power[0] = &quot;1&quot;; for(int i = 0; i &lt;= 100; i++){ dp[i] = &quot;0&quot;; f[i] = &quot;0&quot;; if(i) power[i] = power[i-1] * two; } dp[0] = &quot;1&quot;; for(int i = 1; i &lt;= 100; i++){ for(int j = 0; j &lt; i; j++) if(j != i - 2) dp[i] += dp[j]; BigNum sum; sum = &quot;0&quot;; for(int j = 0; j &lt;= i; j++) sum += dp[j]; sum -= dp[i-1]; f[i] = power[i] - sum; } for(read(T); T; T--){ read(n); f[n].println(); } return 0;} S把词库建成 $Trie$ 树，然后询问就在 $Trie$ 树上 $dfs$ 即可。 记一个坑：函数传参时不要传字符串！否则复制字符串会 $TLE$. >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 100005;struct Trie{ bool isEnd; Trie *ch[26]; Trie(){ isEnd = false; for(int i = 0; i &lt; 26; i++) ch[i] = nullptr; }};Trie *rt;void insertTrie(string s){ int len = s.size(); Trie *now = rt; for(int i = 0; i &lt; len; i++){ if(now -&gt; ch[s[i]-'a'] == nullptr) now -&gt; ch[s[i]-'a'] = new Trie; now = now -&gt; ch[s[i]-'a']; } now -&gt; isEnd = true;}Trie * insert(string s){ int len = s.size(); Trie *now = rt; for(int i = 0; i &lt; len; i++){ if(now -&gt; ch[s[i]-'a'] == nullptr){ now -&gt; ch[s[i]-'a'] = new Trie; now = now -&gt; ch[s[i]-'a']; if(i == len - 1) now -&gt; isEnd = true; } else now = now -&gt; ch[s[i]-'a']; } return now;}int n, q;string s;int cnt = 0;void dfs(Trie *now){ if(cnt == 50) return; if(now -&gt; isEnd == true) cout &lt;&lt; s &lt;&lt; endl, cnt++; if(cnt == 50) return; for(int i = 0; i &lt; 26; i++){ if(cnt == 50) return; if(now -&gt; ch[i] != nullptr){ s.push_back((char)(i + 'a')); dfs(now -&gt; ch[i]); s.pop_back(); } }}int main(){ ios::sync_with_stdio(false); rt = new Trie; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; s; insertTrie(s); } cin &gt;&gt; q; while(q--){ cin &gt;&gt; s; Trie *pt = insert(s); if(pt -&gt; isEnd == false){ cout &lt;&lt; s &lt;&lt; endl; cnt = 1; dfs(pt); } else{ cnt = 0; dfs(pt); } } return 0;} T【参考官方题解】把重链横着放，轻边竖着放。这样宽度不超过 $n$，高度不超过 $\\lg n$，面积小于 $n\\lg n$. >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1005;int n;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N], son[N], sz[N];void dfs(int x, int f){ fa[x] = f, sz[x] = 1, son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x]) continue; dfs(edge[i].to, x); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}int mx[N], ansx[N], ansy[N];void solve(int x, int yy){ ansx[x] = ++mx[yy], ansy[x] = yy; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; solve(edge[i].to, yy + 1); } if(son[x]) solve(son[x], yy);}int main(){ read(n); for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); addEdge(u, v), addEdge(v, u); } dfs(1, 0); memset(mx, -1, sizeof mx); solve(1, 0); for(int i = 1; i &lt;= n; i++) printf(&quot;%d %d\\n&quot;, ansx[i], ansy[i]); return 0;} F留坑待填…… E标程子弹转的方向反了吧……复杂度也不对……不说了","link":"/blog-xcpc/2020/04/26/GMCPC2020-%E7%BD%91%E7%BB%9C%E8%B5%9B/"},{"title":"HDU6219 Empty Convex Polygons","text":"求最大空凸包（即凸包内部没有其他点） Solution枚举凸包最下方的点，设为 $O$，将其他 $y$ 值大于它的点按极角序排序。设 $dp[i][j]$ 表示以 $P_i\\rightarrow O,P_j\\rightarrow P_i$ 为凸包最后两条边的最大空凸包面积，则 $dp[i][j]=\\max(S_{\\Delta OP_iP_j}+dp[j][k])$，其中 $i,j,k$ 要满足空凸包的条件。 由于可能有共线的情况，这个条件写起来还是要小心的。首先要保证 $OP_j$ 与 $OP_i$ 不共线，然后保证 $\\Delta OP_iP_j$ 内部没有其他点，然后保证没有和 $P_j$ 极角相同距离却更小的点（容易漏掉），最后 $\\overrightarrow{P_jP_i}$ 要在 $\\overrightarrow{P_kP_i}$ 转左。 复杂度：$O(n^4)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;const double PI = acos(-1);const double INF = 1e16;inline int sgn(double x){ if(fabs(x) &lt; eps) return 0; else if(x &gt; 0) return 1; else return -1;}inline int cmp(double x, double y){ if(fabs(x-y) &lt; eps) return 0; else if(x &gt; y) return 1; else return -1;}struct Vector{ double x, y, ang; Vector(double x = 0, double y = 0):x(x), y(y){} void read(){ scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector{A.x + B.x, A.y + B.y}; }Vector operator - (Vector A, Vector B){ return Vector{A.x - B.x, A.y - B.y}; }Vector operator * (double k, Vector A){ return Vector{k * A.x, k * A.y}; }bool operator &lt; (const Vector &amp;A, const Vector &amp;B){ return cmp(A.x, B.x) == 0 ? cmp(A.y, B.y) &lt; 0 : cmp(A.x, B.x) &lt; 0; }double operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; } // dot productdouble operator ^ (Vector A, Vector B){ return A.x * B.y - A.y * B.x; } // cross productdouble Length(Vector A){ return sqrt(A * A); }double Angle(Vector A){ return atan2(A.y, A.x); } // polar angle of vector Abool ToTheLeft(Point A, Point B, Point C){ return sgn((B - A) ^ (C - B)) &gt; 0; } // test if vector(bc) is to the left of (ab)bool ToTheLeft(Vector A, Vector B){ return sgn(A ^ B) &gt; 0; } // test if vector B is to the left of vector Adouble TriangleArea(Point A, Point B, Point C){ return ((B - A) ^ (C - A)) / 2; }bool cmp1(const Point &amp;A, const Point &amp;B){ return cmp(A.ang, B.ang) == 0 ? A * A &lt; B * B : A.ang &lt; B.ang;}const int N = 55;int T, n;Point p[N], t[N];double dp[N][N], ans;inline void solve(int O){ int tid = 0; for(int j = 1; j &lt;= n; j++){ if(j == O) continue; if(cmp(p[j].y, p[O].y) &lt; 0) continue; t[++tid] = p[j] - p[O]; t[tid].ang = Angle(p[j] - p[O]); } sort(t+1, t+tid+1, cmp1); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= tid; i++){ for(int j = 1; j &lt; i; j++){ if(cmp(t[j].ang, t[i].ang) == 0) continue; bool ok = true; for(int k = j + 1; k &lt; i; k++){ if(ToTheLeft(t[j], t[k]) &amp;&amp; ToTheLeft(t[k], t[i]) &amp;&amp; ToTheLeft(t[i] - t[j], t[k] - t[j])){ ok = false; break; } } if(!ok) continue; double ijO = fabs(TriangleArea(Point(0, 0), t[j], t[i])); dp[i][j] = max(dp[i][j], ijO); if(sgn(t[j] ^ t[j-1]) != 0) for(int k = 1; k &lt; j; k++) if(ToTheLeft(t[j] - t[k], t[i] - t[k])) dp[i][j] = max(dp[i][j], ijO + dp[j][k]); ans = max(ans, dp[i][j]); } }}int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d&quot;, &amp;n); ans = 0; for(int i = 1; i &lt;= n; i++) p[i].read(); for(int i = 1; i &lt;= n; i++) solve(i); printf(&quot;%.1f\\n&quot;, ans); } return 0;}","link":"/blog-xcpc/2020/03/28/HDU6219-Empty-Convex-Polygons/"},{"title":"ICPC-2020 银川站原地爆炸记","text":"赛前五一假期的每天下午都训练，感觉比不放假还累……身边的小伙伴都去陪 npy 了，与机房的我形成鲜明反差，欲哭无泪…… 把 2019 年的 ICPC 都打了一遍，大概在金尾银首的地方，寻思着这次 499 队还按比例发牌，整个 Au 可能性还是不小的吧，结果居然 Cu 了…… 热身赛飞银川的飞机真的少啊，第一次知道原来飞机还能经停的，不过为了好一点的飞行体验，我们还是买的直达航班。结果本来定的上午八点的飞机，因为武汉的雷暴延迟了整整三个小时，这热身赛只能赶上个尾巴。 到学校之后热身赛还剩 20 min 左右，进场的时候一群群人已经出场了。不过没关系，热身赛本来就是为了熟悉环境嘛……Clion 好评，就是每换一道题就要改一下 cmake list，不知道有没有什么方便一点的做法。哦对了，键盘的布局实在是无言以对，\\ 键居然在第三排挨着 7 字型的回车，每次 printf 的时候都要打错，而且手感也拉垮，鼠标灵敏度也不行。 20 min 赶了个 $A,B,C$ 交上去，结果 $A,B$ 一直 pending，听说为了压测 $A,B$ 有 2000 组评测数据，结果这压测就把评测机给压没了。 学校食堂不错，蜜雪冰城一个冰淇凌是麦当劳甜筒的两倍大，价格却只有一半。 晚上听说有的队写了死循环，然后机子就死了，据说是因为 linux 系统栈空间设置的是 unlimited，搞得我有点担心正式赛出问题，毕竟我也不敢保证不会写出死循环啊…… 正式赛一早起来查了一下怎么在 Clion 中限制栈空间，不过最后也没用上。 到学校之后在体育馆外面等了一会儿，阳光暖暖的，配合不到 20 度的气温非常宜人。不过这时的我不会知道，5个小时之后我的心将是冰冰的（逃 开场经典按模 3 余数看题，没人吭声说找到了签到题，直到榜上有人过了 $A$ 才赶紧看看，然后一发过了。 然后 ailanxier 发现 $J$ 签到，结果码完 WA 了两发，三个人轮流瞅打印出来的代码也没瞅出啥问题，最后无奈改了一下行末空格居然就过了，你说这行末空格既不在题面里写，也不返回 PE，也是无力吐槽了…… 我瞟了一眼化学题的题面，直觉告诉我这种题不是签到就是恶心的大模拟，后来反复读了三四遍脑子里全是什么碳碳双键、烯烃的同分异构体，还总是漏读关键信息，整个人都不好了。码的时候有个 R2 还敲成了 R3，WA 了两发，罚时直接起飞。听见隔壁队伍说他们也罚时爆炸。 期间 xzb 抓着 $I$ 题数学题埋头推式子，写满了三四张纸，还上机写了 3/4 的代码，可惜没写出来，这道题最后也没有人过。 我和 ailanxier 读 $K$ 题，不过题面描述的很奇怪，对着样例猜了个题意，然后想了个 Trie 树上没啥技术含量的做法，一算复杂度是对的，就上机过了。 接下来看 $G$ 题，先莽一个 set 上去，不出意外的 TLE 了。然后本场最大失误就来了……我没向优化数据结构的方向想，转而想怎么从上一个询问转移到下一个询问，期间为了方便做了一个代换，但是没发现这个代换是错的！然后接下来的 1h 我就在自闭推式子、调代码、怀疑人生…… 直到比赛只剩 10+ min，我手造了一个样例才发现我一直在错误的路上想，然后立即就想到了链表的正确做法。但是队友们也在调一个单调栈（最后证明也是假的），没时间把链表调出来了。 比赛结束心情低落，瘫了一会儿也没事儿干，就花了 10min 把链表调了出来。回酒店的路上 xzb 想通了数学题的最后一步，在酒店里一阵猛推，写了份过了样例的代码，但是没法测也不知道能不能 AC。 晚上吃了顿火锅，然后在市区里面随机游走，一路上居然接连看到四个蜜雪冰城店，平均相距 100m，不知道为啥这么密集……瞎逛了一会儿一看地图，居然朝着酒店方向走了一半的路，也是神奇。 然后回酒店 xzb 想通了 $B$ 题的 dp，码了码又过了样例……看网上都说这是一个经典套路、常用 trick，但是我们都不知道，算是有所收获。 第二天飞机又延迟了三个小时，白嫖了机场一顿午饭。 仔细想想，感觉队内交流还是不够充分，经常是一个人想题然后就独自自闭，但事实上讨论一下，即便队友没给出实质性意见，有一个渠道把自己的想法说出来也有助于思考。还有一场沈阳（但是因为疫情又延迟了），期待到时候能发挥出正常的实力。","link":"/blog-xcpc/2021/05/19/ICPC-2020-%E9%93%B6%E5%B7%9D%E7%AB%99%E5%8E%9F%E5%9C%B0%E7%88%86%E7%82%B8%E8%AE%B0/"},{"title":"LCT维护子树信息学习笔记","text":"参考博客：1 简述LCT 可以维护子树的信息。以维护子树大小为例： 设 sz[x] 表示 LCT 中以点 $x$ 为根的子树的总大小，注意，虽然 $x$ 的虚儿子并不一定是原树中 $x$ 的儿子，但是其大小是一样的；设 si[x] 表示 LCT 中点 $x$ 的所有虚子树的大小之和，那么：$$sz[x]=sz[tr[x].son[0]]+sz[tr[x].son[1]]+si[x]$$即子树总大小等于左右子树总大小之和加上所有虚子树的大小之和。 例如，下图的 LCT 中，$H$ 子树的大小等于 $G$ 子树的大小加上 $I$ 子树的大小加上 $J$ 子树的大小，即 $sz[H]=sz[G]+sz[I]+si[H]$. 那具体的，我们需要在哪些地方维护这个 sz 和 si 呢？sz 可以通过 pushup 简单地维护，而 si 和虚实关系有关，我们仅在 access 和 link 操作中修改了虚实关系；在 access 时，我们把原来的右儿子变成了虚儿子，把原来的一个虚儿子变成了右儿子，故加一下减一下即可；在 link 时，我们把 $x$ 置为了 $y$ 的一个新虚儿子，故 si[y] 加上 sz[x] 即可。 1234567891011121314151617181920212223242526272829struct Splay{ int son[2], fa; int sz, si; // sz is total size of subtree rooted at x // si is size of imaginary subtrees of node x bool rev;}tr[N];inline void pushup(int x){ if(x){ tr[x].sz = tr[x].si + 1; if(tr[x].son[0]) tr[x].sz += tr[tr[x].son[0]].sz; if(tr[x].son[1]) tr[x].sz += tr[tr[x].son[1]].sz; }}inline void access(int x){ // connect x with the root of LCT for(int y = 0; x; y = x, x = tr[x].fa){ splay(x); tr[x].si += tr[tr[x].son[1]].sz - tr[y].sz; tr[x].son[1] = y; pushup(x); }}inline void link(int x, int y){ makeRoot(x); access(y); splay(y); if(findRoot(y) != x){ tr[x].fa = y; tr[y].si += tr[x].sz; pushup(y); }} 当然，有些题目并不是维护子树大小，而是子树的其他信息，但其思想大致如此。 练习[BJOI2014]大融合题目链接 这道题维护子树大小即可。查询时将 $(x,y)$ 这条边拎出来，此时 $(x,y)$ 就是一条实链，故答案就是 $(si[x]+1)(si[y]+1)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100005;struct LinkCutTree{ int sta[N], staTop; struct Splay{ int son[2], fa; int sz, si; // sz is total size of subtree rooted at x // si is size of imaginary subtrees of node x bool rev; }tr[N];#define which(x, y) (tr[y].son[1] == x) inline void pushup(int x){ if(x){ tr[x].sz = tr[x].si + 1; if(tr[x].son[0]) tr[x].sz += tr[tr[x].son[0]].sz; if(tr[x].son[1]) tr[x].sz += tr[tr[x].son[1]].sz; } } inline void pushdown(int x){ if(tr[x].rev){ if(tr[x].son[0]){ tr[tr[x].son[0]].rev ^= 1; swap(tr[tr[x].son[0]].son[0], tr[tr[x].son[0]].son[1]); } if(tr[x].son[1]){ tr[tr[x].son[1]].rev ^= 1; swap(tr[tr[x].son[1]].son[0], tr[tr[x].son[1]].son[1]); } tr[x].rev ^= 1; } } inline bool isRoot(int x){ return tr[tr[x].fa].son[0] != x &amp;&amp; tr[tr[x].fa].son[1] != x; } inline void rotate(int x, int dir){ // dir == 0: left; dir == 1: right int y = tr[x].fa, z = tr[y].fa, B = tr[x].son[dir]; if(!isRoot(y)) tr[z].son[which(y,z)] = x; tr[x].son[dir] = y; tr[y].son[dir^1] = B; tr[x].fa = z; tr[y].fa = x; tr[B].fa = y; pushup(y); pushup(x); } inline void splay(int x){ // rotate x to the root of its splay tree sta[staTop = 1] = x; for(int i = x; !isRoot(i); i = tr[i].fa) sta[++staTop] = tr[i].fa; while(staTop) pushdown(sta[staTop--]); // pushdown the tag while(!isRoot(x)){ int y = tr[x].fa, z = tr[y].fa, dir1 = which(x,y)^1, dir2 = which(y,z)^1; if(isRoot(y)) rotate(x, dir1); else{ if(dir1 == dir2) rotate(y, dir2); else rotate(x, dir1); rotate(x, dir2); } } } inline void access(int x){ // connect x with the root of LCT for(int y = 0; x; y = x, x = tr[x].fa){ splay(x); tr[x].si += tr[tr[x].son[1]].sz - tr[y].sz; tr[x].son[1] = y; pushup(x); } } inline void makeRoot(int x){ // make x the root of original tree access(x); splay(x); tr[x].rev ^= 1; swap(tr[x].son[0], tr[x].son[1]); //splay::reverse an interval pushup(x); } inline int findRoot(int x){ // find the root of original tree access(x); splay(x); while(tr[x].son[0]) x = tr[x].son[0]; return x; } inline void link(int x, int y){ makeRoot(x); access(y); splay(y); if(findRoot(y) != x){ tr[x].fa = y; tr[y].si += tr[x].sz; pushup(y); } } inline void cut(int x, int y){ makeRoot(x); access(y); splay(y); if(tr[y].son[0] != x) return; // not connected tr[y].son[0] = tr[x].fa = 0; pushup(y); } inline LL query(int x, int y){ makeRoot(x); access(y); splay(y); return (tr[x].si + 1ll) * (tr[y].si + 1ll); }}LCT;int n, q;int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;q); while(q--){ char opt[2]; int x, y; scanf(&quot;%s%d%d&quot;, opt, &amp;x, &amp;y); if(opt[0] == 'A') LCT.link(x, y); else printf(&quot;%lld\\n&quot;, LCT.query(x, y)); } return 0;} 首都题目链接 由于重心和子树大小相关，这道题仍然维护子树大小。我们可以用并查集来记录每个点所在块的重心是谁，那问题变成如何维护重心。 我们知道重心的一个性质：两棵树连起来后的重心一定位于原来两个重心的连线上。于是，我们把原来两个重心的连线拎出来，在这上面二分——即在这棵 Splay 上向左向右走。我们可以记录一个 ls 和 rs，表示当前二分区间以左和以右的点的个数，那么，以 $x$ 为分界点时，左边一共有 sz[tr[x].son[0]]+ls 个点，右边一共有 sz[tr[x].son[1]]+rs 个点，如果它们都小于总大小的一半，那么 $x$ 就是一个重心。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int n, q, ans;int fa[N];int findfa(int x){ return x == fa[x] ? x : fa[x] = findfa(fa[x]); }struct LinkCutTree{ int sta[N], staTop; struct Splay{ int son[2], fa; int sz, si; // sz is total size of subtree rooted at x // si is size of imaginary subtrees of node x bool rev; }tr[N];#define which(x, y) (tr[y].son[1] == x) inline void pushup(int x){ if(x){ tr[x].sz = tr[x].si + 1; if(tr[x].son[0]) tr[x].sz += tr[tr[x].son[0]].sz; if(tr[x].son[1]) tr[x].sz += tr[tr[x].son[1]].sz; } } inline void pushdown(int x){ if(tr[x].rev){ if(tr[x].son[0]){ tr[tr[x].son[0]].rev ^= 1; swap(tr[tr[x].son[0]].son[0], tr[tr[x].son[0]].son[1]); } if(tr[x].son[1]){ tr[tr[x].son[1]].rev ^= 1; swap(tr[tr[x].son[1]].son[0], tr[tr[x].son[1]].son[1]); } tr[x].rev ^= 1; } } inline bool isRoot(int x){ return tr[tr[x].fa].son[0] != x &amp;&amp; tr[tr[x].fa].son[1] != x; } inline void rotate(int x, int dir){ // dir == 0: left; dir == 1: right int y = tr[x].fa, z = tr[y].fa, B = tr[x].son[dir]; if(!isRoot(y)) tr[z].son[which(y,z)] = x; tr[x].son[dir] = y; tr[y].son[dir^1] = B; tr[x].fa = z; tr[y].fa = x; tr[B].fa = y; pushup(y); pushup(x); } inline void splay(int x){ // rotate x to the root of its splay tree sta[staTop = 1] = x; for(int i = x; !isRoot(i); i = tr[i].fa) sta[++staTop] = tr[i].fa; while(staTop) pushdown(sta[staTop--]); // pushdown the tag while(!isRoot(x)){ int y = tr[x].fa, z = tr[y].fa, dir1 = which(x,y)^1, dir2 = which(y,z)^1; if(isRoot(y)) rotate(x, dir1); else{ if(dir1 == dir2) rotate(y, dir2); else rotate(x, dir1); rotate(x, dir2); } } } inline void access(int x){ // connect x with the root of LCT for(int y = 0; x; y = x, x = tr[x].fa){ splay(x); tr[x].si += tr[tr[x].son[1]].sz - tr[y].sz; tr[x].son[1] = y; pushup(x); } } inline void makeRoot(int x){ // make x the root of original tree access(x); splay(x); tr[x].rev ^= 1; swap(tr[x].son[0], tr[x].son[1]); //splay::reverse an interval pushup(x); } inline int findRoot(int x){ // find the root of original tree access(x); splay(x); while(tr[x].son[0]) x = tr[x].son[0]; return x; } inline void link(int x, int y){ makeRoot(x); access(y); splay(y); if(findRoot(y) != x){ tr[x].fa = y; tr[y].si += tr[x].sz; pushup(y); } } inline void cut(int x, int y){ makeRoot(x); access(y); splay(y); if(tr[y].son[0] != x) return; // not connected tr[y].son[0] = tr[x].fa = 0; pushup(y); } inline int maintain(int x, int y){ int g = 1e9, ls = 0, rs = 0; int _x = x, _y = y; makeRoot(x); int tot = tr[x].sz; access(y); splay(y); while(y){ pushdown(y); int lt = ls + tr[tr[y].son[0]].sz; int rt = rs + tr[tr[y].son[1]].sz; if(max(lt, rt) &lt;= tot / 2) g = min(g, y); if(lt &lt; rt) ls += tr[tr[y].son[0]].sz + tr[y].si + 1, y = tr[y].son[1]; else rs += tr[tr[y].son[1]].sz + tr[y].si + 1, y = tr[y].son[0]; } makeRoot(g); fa[g] = fa[_x] = fa[_y] = g; return g; }}LCT;int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i++) ans ^= i, fa[i] = i; while(q--){ char opt[2]; int x, y; scanf(&quot;%s&quot;, opt); if(opt[0] == 'A'){ scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int gx = findfa(x), gy = findfa(y); LCT.link(x, y); ans ^= gx ^ gy; ans ^= LCT.maintain(gx, gy); } else if(opt[0] == 'Q'){ scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\\n&quot;, LCT.findRoot(x)); } else printf(&quot;%d\\n&quot;, ans); } return 0;}","link":"/blog-xcpc/2020/12/17/LCT%E7%BB%B4%E6%8A%A4%E5%AD%90%E6%A0%91%E4%BF%A1%E6%81%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"My New Blog","text":"As I have graduated from senior high and attend university now, I set up this new blog to record my study and my college life. The old blog (my old blog) is no longer updated, though the content will not be deleted. This new blog still focuses on contests about algorithms — ICPC/CCPC in this case. That is to say, the content of this blog will mainly be study notes, solutions to problems and diaries regarding contests. Nevertheless, I will upload some casual essays when I feel like to do so. This is a brand new journey, during which I will do my best. #希君生羽翼，一化北溟鱼# The following part is for testingmath formula:$$\\int f(x)g(x)dx=f(\\xi)\\int g(x)dx$$ $\\color{red}\\alpha_{\\color{blue}\\beta+\\color{green}\\gamma},\\color{orange}\\delta_\\color{magenta}\\epsilon$ This is a quote. code: bitset code block: 12345678#include&lt;cstdio&gt;using namespace std;int a, b;int main(){ scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\\n&quot;, a + b); return 0;}","link":"/blog-xcpc/2020/01/17/My-New-Blog/"},{"title":"[Nowcoder17797E][2021广东省赛] Excellent Number","text":"题目链接 Solution据信这是一类经典的用矩阵快速幂优化 $dp$ 的题目，学到了。 首先有一个显然的 $dp$：设 $dp[i][r][j]$ 表示已填前 $i$ 位、末尾与字符串 $k$ 匹配了 $j$ 位，当前模 $11$ 等于 $r$ 的方案数。那么转移就是：$$dp[i][r][j]\\to dp[i+1][(10r+x)\\bmod 11][f(j, x)],\\quad x\\in[0,9]$$其中 $x$ 是填在第 $i+1$ 位的数，$f(j,x)$ 是计算在匹配了 $j$ 位的情况下填上 $x$ 之后最多能匹配到的地方，可以用 fail 数组搞定。 但是直接转移是 $O(10\\times 6\\times 11\\times n)\\approx O(6.6e8)$，会超时。 然后这玩意儿可以矩阵快速幂优化，为了看的更清楚，我们可以滚掉 $dp$ 数组的第一维，然后发现，$dp$ 数组的转移是固定的，所以可以用矩阵表示出来。具体地说，由于 $(r,j)$ 能转移到 $((10r+x)\\bmod 11,f(j,x))$，所以我们就在系数矩阵的第 $((10r+x)\\bmod 11,f(j,x))$ 行第 $(r,j)$ 列加上 $1$（当然这里要把 $(r,j)$ 两个维度压扁成一个，按住不表），如此，前一个 $dp$ 数组乘上该矩阵就得到了后一个 $dp$ 数组。现在我就可以矩阵快速幂了。 计算答案的时候，用所有可能性 $10^n$ 减去不合法的数量 $\\sum\\limits_{r=1}^{10}\\sum\\limits_{j=0}^{lenk-1}dp[(r,j)]$，记得特判 $10^n$ 这个数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MOD = 998244353;struct Matrix{ int n; LL a[105][105]; Matrix(){ memset(a, 0, sizeof a); } void eye(){ memset(a, 0, sizeof a); for(int i = 1; i &lt;= n; i++) a[i][i] = 1; } Matrix operator * (const Matrix &amp;A) const{ Matrix c; c.n = n; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) for(int k = 1; k &lt;= n; k++) (c.a[i][j] += a[i][k] * A.a[k][j] % MOD) %= MOD; return c; }};Matrix fpow(Matrix bs, LL idx){ Matrix res; res.n = bs.n; res.eye(); while(idx){ if(idx &amp; 1) res = res * bs; bs = bs * bs; idx &gt;&gt;= 1; } return res;}int n, lenk;char k[200005];int fail[105];void getFail(char t[], int lent){ int i = 1, j = 0; fail[1] = 0; while(i &lt;= lent){ if(!j || t[i] == t[j]){ i++, j++; if(t[i] != t[j]) fail[i] = j; else fail[i] = fail[j]; } else j = fail[j]; }}inline int f(int j, int x){ j++; while(j &amp;&amp; (k[j] != x+'0')) j = fail[j]; return j;}inline int get(int x, int y){ return x * (lenk + 1) + y + 1; }int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ memset(fail, 0, sizeof fail); scanf(&quot;%d%s&quot;, &amp;n, k+1); lenk = strlen(k+1); getFail(k, lenk); Matrix mat; mat.n = 100; for(int j = 0; j &lt; lenk; j++){ for(int x = 0; x &lt;= 9; x++){ int g = f(j, x); if(g == lenk) continue; for(int r = 0; r &lt; 11; r++) (mat.a[get((r*10+x)%11, g)][get(r, j)] += 1) %= MOD; } } mat = fpow(mat, n); LL ans = 1; for(int i = 1; i &lt;= n; i++) (ans *= 10) %= MOD; for(int r = 1; r &lt; 11; r++) for(int j = 0; j &lt; lenk; j++) (ans -= mat.a[get(r, j)][1]) %= MOD; bool extra = (k[1] == '1'); for(int i = 2; i &lt;= lenk; i++) extra &amp;= (k[i] == '0'); extra &amp;= (n &gt;= lenk - 1); ans += extra; ans = (ans % MOD + MOD) % MOD; printf(&quot;%lld\\n&quot;, ans); } return 0;}","link":"/blog-xcpc/2021/07/04/Nowcoder17797E-2021%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9B-Excellent-Number/"},{"title":"[Nowcoder5278L] 动物森友会","text":"题目链接 Solution二分答案天数，判断二分的天数内能否完成所有事件。 用网络流判断：以星期一到星期日这 $7$ 天和所有 $n$ 个事件为顶点，源点向每一天连边，边权为当天能完成的事件数 $\\left[\\lfloor\\frac{mid}{7}\\rfloor+(mid%7\\geq i)\\right]\\cdot e$；每天向事件连边，边权为无穷；事件向汇点连边，边权为该事件需要完成的次数。那么跑一遍最大流，若最大流等于需要完成事件的总数，那么当前二分出来的天数 $mid$ 可行。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 1500;const int INF = 1e9;struct MAX_FLOW{ struct Edge{ int nxt, to; LL flow; }edge[200005]; int head[N], edgeNum = 1; void addEdge(int from, int to, LL flow){ edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].flow = flow; head[from] = edgeNum; } int s, t, n; bool inq[N]; LL dep[N]; void init(){ edgeNum = 1; for(int i = 1; i &lt;= n + 5; i++) head[i] = 0; } bool bfs(){ for(int i = 1; i &lt;= n; i++) dep[i] = INF, inq[i] = 0; queue&lt;int&gt; q; q.push(s); inq[s] = 1; dep[s] = 0; while(!q.empty()){ int cur = q.front(); q.pop(); inq[cur] = 0; for(int i = head[cur]; i; i = edge[i].nxt){ if(dep[edge[i].to] &gt; dep[cur] + 1 &amp;&amp; edge[i].flow){ dep[edge[i].to] = dep[cur] + 1; if(!inq[edge[i].to]){ q.push(edge[i].to); inq[edge[i].to] = 1; } } } } if(dep[t] != INF) return 1; return 0; } LL dfs(int x, LL minFlow){ LL flow = 0; if(x == t) return minFlow; for(int i = head[x]; i; i = edge[i].nxt){ if(dep[edge[i].to] == dep[x] + 1 &amp;&amp; edge[i].flow){ flow = dfs(edge[i].to, min(minFlow, edge[i].flow)); if(flow){ edge[i].flow -= flow; edge[i^1].flow += flow; return flow; } } } return 0; } LL Dinic(){ LL maxFlow = 0, flow = 0; while(bfs()){ while(flow = dfs(s, INF)) maxFlow += flow; } return maxFlow; }}dinic;int n, e, c[N], m[N], a[N][10];LL tot;inline bool check(LL mid){ dinic.s = n + 8, dinic.t = n + 9, dinic.n = n + 9; dinic.init(); for(int i = 1; i &lt;= 7; i++){ dinic.addEdge(dinic.s, n + i, mid / 7 * e + (mid % 7 &gt;= i) * e); dinic.addEdge(n+i, dinic.s, 0); } for(int i = 1; i &lt;= n; i++){ dinic.addEdge(i, dinic.t, c[i]), dinic.addEdge(dinic.t, i, 0); for(int j = 1; j &lt;= m[i]; j++) dinic.addEdge(n + a[i][j], i, INF), dinic.addEdge(i, n + a[i][j], 0); } return dinic.Dinic() &gt;= tot;}int main(){ read(n, e); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%d%d&quot;, &amp;c[i], &amp;m[i]); tot += c[i]; for(int j = 1; j &lt;= m[i]; j++) scanf(&quot;%d&quot;, &amp;a[i][j]); } LL l = 0, r = 2000000000; while(l &lt; r){ LL mid = (r - l) / 2 + l; if(check(mid)) r = mid; else l = mid + 1; } printf(&quot;%lld\\n&quot;, l); return 0;}","link":"/blog-xcpc/2020/04/23/Nowcoder5278L-%E5%8A%A8%E7%89%A9%E6%A3%AE%E5%8F%8B%E4%BC%9A/"},{"title":"[POI2007] MEG-Megalopolis","text":"题目链接 Solution要求点到根的距离，而更改一条边后，受影响的点是这条边连着的子树的所有点。和子树挂钩的问题，一般都是 $dfs$ 序了。于是线段树维护区间加、单点求值即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 250005;struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int n, m, u, v, a[N] = {-1};char s[2];int st[N], ed[N], dfsClock;void dfs(int x, int f){ st[x] = ed[x] = ++dfsClock; a[st[x]] = a[st[f]] + 1; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x); } ed[x] = dfsClock;}struct segTree{ int l, r, sum, lazy;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ tr[id].sum = tr[lid].sum + tr[rid].sum;}inline void pushdown(int id){ if(tr[id].l == tr[id].r) return; if(tr[id].lazy){ tr[lid].lazy += tr[id].lazy; tr[lid].sum += len(lid) * tr[id].lazy; tr[rid].lazy += tr[id].lazy; tr[rid].sum += len(rid) * tr[id].lazy; tr[id].lazy = 0; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].lazy = 0; if(tr[id].l == tr[id].r){ tr[id].sum = a[l]; return; } build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ pushdown(id); if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].lazy += val; tr[id].sum += len(id) * val; return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}int query(int id, int pos){ pushdown(id); if(tr[id].l == tr[id].r) return tr[id].sum; if(pos &lt;= mid) return query(lid, pos); else return query(rid, pos);}int main(){ read(n); for(int i = 1; i &lt; n; i++){ read(u, v); addEdge(u, v); addEdge(v, u); } dfs(1, 0); build(1, 1, n); read(m); while(1){ scanf(&quot;%s&quot;, s); if(s[0] == 'A'){ read(u, v); if(u &lt; v) swap(u, v); add(1, st[u], ed[u], -1); } else{ read(u); printf(&quot;%d\\n&quot;, query(1, st[u])); m--; if(m == 0) break; } } return 0;}","link":"/blog-xcpc/2020/02/17/POI2007-MEG-Megalopolis/"},{"title":"QTREE系列","text":"Query on a tree. QTREE 1题意简述：给定一棵 $n$ 个点的树，要求支持两种操作：改动某条边的权值、询问点 $a$ 到点 $b$ 路径上的最大边权。 题解：树链剖分+线段树。注意一个坑：由于我们要将边权下放到点权，在查询 $a,b$ 时，不能将 $\\text{lca}(a,b)$ 计入答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n, a[N], which[N];struct Edge{ int nxt, to, dis, id;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis, int id){ edge[++edgeNum] = (Edge){head[from], to, dis, id}; head[from] = edgeNum;}int fa[N], dep[N], son[N], sz[N];void dfs(int x, int f, int depth){ fa[x] = f; dep[x] = depth; sz[x] = 1; son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth + 1); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; which[edge[i].id] = edge[i].to; a[edge[i].to] = edge[i].dis; }}int top[N], st[N], ed[N], dfsClock, func[N];void dfs(int x, int tp){ st[x] = ++dfsClock; func[dfsClock] = x; top[x] = tp; if(son[x]) dfs(son[x], tp); for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs(edge[i].to, edge[i].to); } ed[x] = dfsClock;}#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)struct segTree{ int l, r, mx;}tr[N&lt;&lt;2];inline void pushup(int id){ tr[id].mx = max(tr[lid].mx, tr[rid].mx);}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].mx = 0; if(tr[id].l == tr[id].r){ tr[id].mx = a[func[l]]; return; } build(lid, l, mid), build(rid, mid+1, r); pushup(id);}void modify(int id, int pos, int val){ if(tr[id].l == tr[id].r){ tr[id].mx = val; return; } if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); pushup(id);}int query(int id, int l, int r){ if(tr[id].l == l &amp;&amp; tr[id].r == r) return tr[id].mx; if(r &lt;= mid) return query(lid, l, r); else if(l &gt; mid) return query(rid, l, r); else return max(query(lid, l, mid), query(rid, mid+1, r));}inline void modifyVertex(int u, int val){ modify(1, st[u], val);}inline int queryPath(int u, int v){ int res = 0; while(top[u] != top[v]){ if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); res = max(res, query(1, st[top[u]], st[u])); u = fa[top[u]]; } if(dep[u] &lt; dep[v]) swap(u, v); if(st[v] + 1 &lt;= st[u]) res = max(res, query(1, st[v]+1, st[u])); return res;}inline void init(){ for(int i = 1; i &lt;= n; i++){ head[i] = a[i] = which[i] = 0; son[i] = fa[i] = dep[i] = sz[i] = 0; top[i] = st[i] = ed[i] = func[i] = 0; } edgeNum = dfsClock = 0;}int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d&quot;, &amp;n); init(); for(int i = 1; i &lt; n; i++){ int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); addEdge(u, v, w, i), addEdge(v, u, w, i); } dfs(1, 0, 1); dfs(1, 1); build(1, 1, n); char opt[10]; while(1){ scanf(&quot;%s&quot;, opt); if(opt[0] == 'D') break; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if(opt[0] == 'C') modifyVertex(which[x], y); else printf(&quot;%d\\n&quot;, queryPath(x, y)); } } return 0;} QTREE2题意简述：给定一棵 $n$ 个点的树，要求支持两种操作：询问 $a$ 到 $b$ 的距离、询问从 $a$ 到 $b$ 的路径上的第 $k$ 个点的编号。 题解：倍增。距离就是 $\\text{dis}_a+\\text{dis}b-2\\text{dis}{\\text{lca}(a,b)}$，而后一个询问可以转化成求某个点的第 $k$ 个父节点，倍增自然可以搞定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n;struct Edge{ int nxt, to, dis;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis){ edge[++edgeNum] = (Edge){head[from], to, dis}; head[from] = edgeNum;}int fa[N][25], dep[N], dis[N];void dfs(int x, int f, int depth){ dep[x] = depth, fa[x][0] = f; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dis[edge[i].to] = dis[x] + edge[i].dis; dfs(edge[i].to, x, depth+1); }}void init(){ for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for(int i = 1; i &lt;= n; i++) if(fa[i][j-1]) fa[i][j] = fa[fa[i][j-1]][j-1];}inline int lca(int x, int y){ if(dep[x] &lt; dep[y]) swap(x, y); for(int i = 20; i &gt;= 0; i--) if(dep[x] - (1 &lt;&lt; i) &gt;= dep[y]) x = fa[x][i]; if(x == y) return x; for(int i = 20; i &gt;= 0; i--) if(fa[x][i] &amp;&amp; fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0];}inline int getFa(int x, int k){ for(int i = 20; i &gt;= 0; i--) if(k &gt;= (1&lt;&lt;i)) x = fa[x][i], k -= (1&lt;&lt;i); return x;}int main(){ int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d&quot;, &amp;n); edgeNum = 0; for(int i = 1; i &lt;= n; i++){ head[i] = dep[i] = dis[i] = 0; for(int j = 0; j &lt;= 20; j++) fa[i][j] = 0; } for(int i = 1; i &lt; n; i++){ int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); } dfs(1, 0, 1); init(); char opt[10]; while(1){ scanf(&quot;%s&quot;, opt); if(opt[1] == 'O') break; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int l = lca(a, b); if(opt[1] == 'I') printf(&quot;%d\\n&quot;, dis[a] + dis[b] - 2 * dis[l]); else{ int k; scanf(&quot;%d&quot;, &amp;k); if(k &lt;= dep[a] - dep[l] + 1) printf(&quot;%d\\n&quot;, getFa(a, k-1)); else printf(&quot;%d\\n&quot;, getFa(b, dep[a] + dep[b] - 2 * dep[l] + 1 - k)); } } } return 0;} QTREE3题意简述：给定一棵 $n$ 个点的树，节点有黑白两色，初始全白。要求支持两种操作：改变某点的颜色、询问从点 $1$ 到某点的路径上的第一个黑点编号。 题解：树链剖分+set。一个 set 存储一个重链中的所有黑点（的 $\\text{dfs}$ 序）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int n, q;bool a[N];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}int fa[N], dep[N], son[N], sz[N];void dfs(int x, int f, int depth){ fa[x] = f; dep[x] = depth; sz[x] = 1; son[x] = 0; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth + 1); sz[x] += sz[edge[i].to]; if(!son[x] || sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to; }}int top[N], st[N], ed[N], dfsClock, func[N];void dfs(int x, int tp){ st[x] = ++dfsClock; func[dfsClock] = x; top[x] = tp; if(son[x]) dfs(son[x], tp); for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == fa[x] || edge[i].to == son[x]) continue; dfs(edge[i].to, edge[i].to); } ed[x] = dfsClock;}set&lt;int&gt; s[N];inline void reverseVertex(int x){ if(a[x]) s[top[x]].erase(st[x]); else s[top[x]].insert(st[x]);}inline int queryPath(int x){ int res = 1e9; while(top[x] != 1){ if(!s[top[x]].empty() &amp;&amp; *s[top[x]].begin() &lt;= st[x]) res = min(res, *s[top[x]].begin()); x = fa[top[x]]; } if(!s[1].empty() &amp;&amp; *s[1].begin() &lt;= st[x]) res = min(res, *s[1].begin()); return res;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt; n; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); } dfs(1, 0, 1); dfs(1, 1); while(q--){ int opt, x; scanf(&quot;%d%d&quot;, &amp;opt, &amp;x); if(opt == 0) reverseVertex(x), a[x] = !a[x]; else{ int dfn = queryPath(x); if(dfn == 1e9) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;, func[dfn]); } } return 0;}","link":"/blog-xcpc/2020/12/14/QTREE%E7%B3%BB%E5%88%97/"},{"title":"bitset学习笔记","text":"优美的暴力 参考博客：1 2 3 基本操作参考：link Functions Examples (constructor) bitset&lt;16&gt; foo;bitset&lt;20&gt; bar(233);bitset&lt;8&gt; baz(std::string(&quot;01001&quot;)); applicable operators ^ &amp; | &lt;&lt; &gt;&gt; ~ == != ^= &amp;= |= &lt;&lt;= &gt;&gt;= operator[] Access bit foo[1] count Count bits set foo.count() size Return size foo.size() test Return bit value foo.test(i) any Test if any bit is set foo.any() none Test if no bit is set foo.none() all Test if all bits are set foo.all() set Set bits foo.set() foo.set(2,0) foo.set(2) reset Reset bits foo.reset()foo.reset(1) flip Flip bits foo.flip()foo.flip(2) to_string Convert to string foo.to_string() to_ulong Convert to unsigned long interger foo.to_ulong() to_ullong Convert to unsigned long long foo.to_ullong() 练习poj2443 Set Operation题目链接 bitset 存储每个点属于哪些集合，询问时 &amp; 起来不为零输出 Yes，否则输出 No. 复杂度：$O\\left(\\frac{QN}{32}\\right)$ >folded12345678910111213141516171819202122232425262728293031323334#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int n, q;bitset&lt;1005&gt; bs[10005];int main(){ read(n); for(int i = 1; i &lt;= n; i++){ int c, a; read(c); while(c--){ read(a); bs[a].set(i); } } read(q); while(q--){ int x, y; read(x, y); if((bs[x] &amp; bs[y]) != 0) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0;} hdu5036 Explosion题目链接 整体的期望次数等于打开每扇门的期望被炸次数之和。考虑门 $i$，设所有能到达 $i$ 的点构成集合 $S_i$（包括 $i$ 本身），则在任一合法炸门序列中，若已经有一个不同于 $i$ 且可到达 $i$ 的点出现了，那么 $i$ 的被炸次数为 $0$；否则，没有任何钥匙可以打开它，$i$ 必须被炸一次。于是打开第 $i$ 扇门的期望被炸次数为 $0\\cdot\\frac{|S_i|-1}{|S_i|}+1\\cdot\\frac{1}{|S_i|}=\\frac{1}{|S_i|}$，答案为 $\\sum\\limits_{i=1}^n\\frac{1}{|S_i|}$. 为求出 $|S_i|$，我们可以利用 floyd 算法求出连通性，并利用 bitset 加速。 复杂度：$O\\left(\\frac{n^3}{32}\\right)$ >folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;const int N = 1005;int T, n;bitset&lt;N&gt; bs[N];inline void floyd(){ for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(bs[j].test(i)) bs[j] |= bs[i];}int main(){ scanf(&quot;%d&quot;, &amp;T); for(int CASES = 1; CASES &lt;= T; CASES++){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ bs[i].reset(); bs[i].set(i); } for(int i = 1; i &lt;= n; i++){ int c, x; scanf(&quot;%d&quot;, &amp;c); while(c--){ scanf(&quot;%d&quot;, &amp;x); bs[x].set(i); } } floyd(); double ans = 0; for(int i = 1; i &lt;= n; i++) ans += 1.0 / bs[i].count(); printf(&quot;Case #%d: %.5f\\n&quot;, CASES, ans); } return 0;} Gym100342 J - Triatrip题目链接 每个点用 bitset 记录出边连接哪些点以及入边连接哪些点，统计答案的时候与起来数 $1$ 的个数。 复杂度：$O(\\frac{n^3}{32})$ >folded123456789101112131415161718192021222324252627282930313233343536#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;const int N = 1505;int n;LL ans;char s[N];bitset&lt;N&gt; in[N], out[N];int main(){ freopen(&quot;triatrip.in&quot;, &quot;r&quot;, stdin); freopen(&quot;triatrip.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%s&quot;, s+1); for(int j = 1; j &lt;= n; j++) if(s[j] == '+'){ in[j].set(i); out[i].set(j); } } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(in[i].test(j)) ans += (out[i] &amp; in[j]).count(); printf(&quot;%lld\\n&quot;, ans / 3); return 0;} hdu5313 Bipartite Graph题目链接 先 $dfs$ 染色得到一系列二分图，然后重点在 $dp$. 设 $dp[i][k]$ 表示能否通过合并前 $i$ 个二分图构成一边是 $k$ 个点的二分图。则 $dp[i][k]=dp[i-1][k-a[i]]\\ \\mathrm{OR}\\ dp[i-1][k-b[i]]$. 这个 $dp$ 是 $O(n^2)$ 的，由于 $dp$ 数组是 $bool$ 值，所以可以用 bitset 优化——把第一维滚掉，第二维就是 bitset 的每一位。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 10005;int T, n, m;struct Edge{ int nxt, to;}edge[N*N];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum] = (Edge){head[from], to}; head[from] = edgeNum;}bool vis[N];int cnt[2];vector&lt;pii&gt; v;void dfs(int x, int c){ vis[x] = true; cnt[c]++; for(int i = head[x]; i; i = edge[i].nxt){ if(vis[edge[i].to]) continue; dfs(edge[i].to, c ^ 1); }}bitset&lt;N&gt; dp;inline void init(){ memset(head, 0, sizeof head); memset(vis, 0, sizeof vis); edgeNum = 0; v.clear(); dp.reset();}int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); for(int i = 1; i &lt;= m; i++){ int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); } for(int i = 1; i &lt;= n; i++){ if(!vis[i]){ cnt[0] = cnt[1] = 0; dfs(i, 0); v.pb(mp(cnt[0], cnt[1])); } } dp.set(0); for(int i = 0; i &lt; v.size(); i++) dp = (dp &lt;&lt; v[i].first) | (dp &lt;&lt; v[i].second); int ans = 0; for(int i = 0; i &lt; n; i++) if(dp.test(i)) ans = max(ans, i * (n - i) - m); printf(&quot;%d\\n&quot;, ans); } return 0;} hdu5890 Eighty seven题目链接 设 $dp[i][j][k]$ 表示前 $i$ 个数选取 $j$ 个数能否凑出 $k$，则不考虑去掉 $3$ 个数的话，$dp[i][j][k]=dp[i-1][j-1][k-a[i]]\\ \\mathrm{OR}\\ dp[i-1][j][k]$. 和上一题同理，滚动数组滚掉第一维，bitset 优化第三维。每次操作都重新求一遍 $dp$ 数组，时间有点吃紧，可以记忆化一下（虽然理论上最差复杂度没变）。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;int T, n, a[55], q;bitset&lt;88&gt; dp[15];int ok[55][55][55];int main(){ read(T); while(T--){ read(n); memset(ok, -1, sizeof ok); for(int i = 1; i &lt;= n; i++) read(a[i]); read(q); while(q--){ int x, y, z; read(x, y, z); if(ok[x][y][z] != -1){ puts(ok[x][y][z] ? &quot;Yes&quot; : &quot;No&quot;); continue; } dp[0].set(0); for(int j = 1; j &lt;= 10; j++) dp[j].reset(); for(int i = 1; i &lt;= n; i++) if(i != x &amp;&amp; i != y &amp;&amp; i != z) for(int j = 10; j &gt;= 1; j--) dp[j] |= (dp[j-1] &lt;&lt; a[i]); ok[x][y][z] = ok[x][z][y] = dp[10].test(87); ok[y][x][z] = ok[y][z][x] = dp[10].test(87); ok[z][x][y] = ok[z][y][x] = dp[10].test(87); puts(dp[10].test(87) ? &quot;Yes&quot; : &quot;No&quot;); } } return 0;} hdu5808 Price List Strike Back题目链接 正解是 CDQ 分治，不过可以用 bitset 加速 $dp$ 过这道题。 先将所有商店和询问按距离排序，这样我们可以用一个指针不断后移指出哪些店距离小于询问距离。开一棵树状数组记录每种价格的个数，然后做一个多重背包的可行性 $dp$，用 bitset 优化。 不过时间还是有点吃紧，还可以优化：1. 做背包的时候一旦发现可行就退出；2. 在总价格为 $s$ 时，价格为 $k$ 的点最多只用 $\\frac{s}{k}$ 个；3. 多重背包用二进制优化。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 20005;const int M = 100005;int T, n, m;bitset&lt;101&gt; dp;bool ans[M];struct Shop{ int v, d, id; // val and distance bool operator &lt; (const Shop &amp;A) const{ return d &lt; A.d; }}shop[N];struct Query{ int l, r, d, s, id; bool operator &lt; (const Query &amp;A) const{ return d &lt; A.d; }}q[M];bool cmp(const Query &amp;A, const Query &amp;B){ return A.id &lt; B.id;}struct Node{ int val[105];}c[N];inline int lowbit(int x){ return x &amp; -x; }inline void add(int x, int v){ while(x &lt;= n){ c[x].val[v]++; x += lowbit(x); }}inline void sum(int x, int a[]){ for(int i = 1; i &lt;= 100; i++) a[i] = 0; while(x){ for(int k = 1; k &lt;= 100; k++) a[k] += c[x].val[k]; x -= lowbit(x); }}int L[105], R[105];inline bool solve(int i){ sum(q[i].r, R), sum(q[i].l-1, L); if(R[q[i].s] - L[q[i].s]) return true; dp.reset(), dp.set(0); for(int k = 1; k &lt;= q[i].s; k++){ int cnt = min(R[k] - L[k], q[i].s / k); for(int j = 1; j &lt;= cnt; cnt -= j, j &lt;&lt;= 1){ dp |= (dp &lt;&lt; (k * j)); if(dp.test(q[i].s)) return true; } if(cnt &gt; 0) dp |= (dp &lt;&lt; (k * cnt)); if(dp.test(q[i].s)) return true; } return dp.test(q[i].s);}int main(){ read(T); while(T--){ read(n, m); memset(c, 0, sizeof c); for(int i = 1; i &lt;= n; i++) read(shop[i].v), shop[i].id = i; for(int i = 1; i &lt;= n; i++) read(shop[i].d); sort(shop+1, shop+n+1); for(int i = 1; i &lt;= m; i++) read(q[i].l, q[i].r, q[i].d, q[i].s), q[i].id = i; sort(q+1, q+m+1); int pts = 0; for(int i = 1; i &lt;= m; i++){ while(pts &lt; n &amp;&amp; shop[pts+1].d &lt;= q[i].d){ pts++; add(shop[pts].id, shop[pts].v); } ans[q[i].id] = !solve(i); } for(int i = 1; i &lt;= m; i++) printf(&quot;%d&quot;, ans[i]); puts(&quot;&quot;); } return 0;} CF981E Addition on Segments题目链接 把所有操作放到线段树上，$dfs$ 这颗线段树，当到达叶节点时，我们得到了包含这个叶节点的一系列操作。如果只进行这些操作而不进行不包含该节点的操作的话，这个节点的值就一定是最大值，所以此时做一个 $01$ 背包的可行性 $dp$，用 bitset 优化。为降低复杂度，一路搜索下来时边走边 $dp$，同时记录上一层的 $dp$ 值便于回溯时撤销。 复杂度：$O(\\frac{qn\\lg n}{32})$ >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 10005;int n, q;bitset&lt;N&gt; ans;struct segTree{ int l, r; vector&lt;int&gt; v;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].v.clear(); if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r);}void add(int id, int l, int r, int val){ if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].v.emplace_back(val); return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val);}bitset&lt;N&gt; dp;void dfs(int id){ bitset&lt;N&gt; rec = dp; for(auto k: tr[id].v) dp |= dp &lt;&lt; k; if(tr[id].l == tr[id].r){ for(int i = 1; i &lt;= n; i++) if(dp.test(i)) ans.set(i); dp = rec; return; } dfs(lid), dfs(rid); dp = rec;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;q); build(1, 1, n); while(q--){ int l, r, x; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;x); add(1, l, r, x); } dp.reset(), dp.set(0); dfs(1); printf(&quot;%d\\n&quot;, (int)ans.count()); for(int i = 1; i &lt;= n; i++) if(ans.test(i)) printf(&quot;%d &quot;, i); puts(&quot;&quot;); return 0;} poj1742 Coins题目链接 多重背包的可行性问题，bitset + 二进制优化。 >folded123456789101112131415161718192021222324252627282930313233343536373839#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 105;const int M = 100005;int n, m, a[N], c[N];bitset&lt;M&gt; dp;bitset&lt;M&gt; mask;int main(){ while(1){ read(n, m); if(!n &amp;&amp; !m) break; for(int i = 1; i &lt;= n; i++) read(a[i]); for(int i = 1; i &lt;= n; i++) read(c[i]); dp.reset(), dp.set(0); for(int i = 1; i &lt;= n; i++){ for(int p = 1; p &lt;= c[i]; c[i] -= p, p &lt;&lt;= 1) dp |= dp &lt;&lt; (p * a[i]); dp |= dp &lt;&lt; (c[i] * a[i]); } mask.reset(); for(int i = 0; i &lt;= m; i++) mask.set(i); dp &amp;= mask; printf(&quot;%d\\n&quot;, (int)dp.count() - 1); } return 0;} CSU2005 Nearest Maintenance Point题目链接 如果不要求输出最近点，那么以所有的特殊点为源跑一遍 $dijkstra$ 即可。现在为了记录哪些点是最近点，采用 bitset，在松弛操作时更新即可。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 10005;const int M = 50005;const int INF = 1e9;int n, m, s, q, func[N];vector&lt;int&gt; spec;struct Edge{ int nxt, to, dis;}edge[M&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, int dis){ edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; edge[edgeNum].dis = dis; head[from] = edgeNum;}struct Node{ int dis, num; bool operator &lt; (const Node &amp;a) const{ return a.dis &lt; dis; }};int dis[N];bool inS[N];bitset&lt;1005&gt; bs[N];void dijkstra(){ priority_queue&lt;Node&gt; q; for(int i = 1; i &lt;= n; i++) dis[i] = INF, inS[i] = 0; for(auto k: spec){ dis[k] = 0; q.push( (Node){0, k} ); bs[k].set(func[k]); } while(!q.empty()){ Node cur = q.top(); q.pop(); if(inS[cur.num]) continue; inS[cur.num] = 1; for(int i = head[cur.num]; i; i = edge[i].nxt){ if((LL)dis[edge[i].to] &gt; (LL)dis[cur.num] + edge[i].dis){ bs[edge[i].to] = bs[cur.num]; dis[edge[i].to] = dis[cur.num] + edge[i].dis; q.push( (Node){dis[edge[i].to], edge[i].to} ); } if((LL)dis[edge[i].to] == (LL)dis[cur.num] + edge[i].dis) bs[edge[i].to] |= bs[cur.num]; } }}inline void init(){ for(int i = 1; i &lt;= n; i++){ bs[i].reset(); head[i] = 0; func[i] = 0; } edgeNum = 0; spec.clear();}int main(){ while(scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;q) != EOF){ init(); for(int i = 1; i &lt;= m; i++){ int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); addEdge(u, v, w), addEdge(v, u, w); } for(int i = 1; i &lt;= s; i++){ int x; scanf(&quot;%d&quot;, &amp;x); spec.emplace_back(x); func[x] = i; } dijkstra(); while(q--){ int x; scanf(&quot;%d&quot;, &amp;x); for(int i = 1; i &lt;= s; i++) if(bs[x].test(i)) printf(&quot;%d &quot;, spec[i-1]); puts(&quot;&quot;); } } return 0;} hdu6085 Rikka with Candies题目链接 用 bitset 记录 $A,B$ 数组中出现的数字（的奇偶性），倒序枚举 $k$，则 $B$ 中所有比 $k$ 大的数可能对答案有贡献，对这些数，统计它们的倍数，加上 $k$ 后与 $A$ 重叠部分就是对答案的贡献。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}const int N = 50005;int T, n, m, q, a[N], b[N], mxb, ans[N];bitset&lt;N&gt; A, B, MB;int main(){ read(T); while(T--){ read(n, m, q); A.reset(), B.reset(), MB.reset(); mxb = 0; for(int i = 1; i &lt;= n; i++){ read(a[i]); A.flip(a[i]); } for(int i = 1; i &lt;= m; i++){ read(b[i]); B.flip(b[i]); mxb = max(mxb, b[i]); } for(int k = mxb; k &gt;= 0; k--){ ans[k] = ((MB &lt;&lt; k) &amp; A).count() &amp; 1; if(B.test(k)) for(int j = 0; j &lt;= mxb; j += k) MB.flip(j); } while(q--){ int k; read(k); printf(&quot;%d\\n&quot;, ans[k]); } } return 0;} CF687C The Values You Can Make题目链接 设 $dp[j][k]$ 表示凑出总数为 $j$ 的时候能否凑出 $k$，那么 $dp[j][k] = dp[j-a[i]][k]\\ \\mathrm{OR}\\ dp[j-a[i]][k-a[i]]$. 用 bitset 优化。 复杂度：$O\\left(\\frac{nk^2}{32}\\right)$ >folded1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 505;int n, k, a[N], id;bitset&lt;N&gt; dp[N&lt;&lt;1];int main(){ read(n, k); for(int i = 1; i &lt;= n; i++) read(a[i]); dp[0].set(0); for(int i = 1; i &lt;= n; i++) for(int j = k; j &gt;= a[i]; j--) dp[j] |= dp[j-a[i]] | (dp[j-a[i]] &lt;&lt; a[i]); printf(&quot;%d\\n&quot;, (int)dp[k].count()); for(int i = 0; i &lt;= k; i++) if(dp[k].test(i)) printf(&quot;%d &quot;, i); puts(&quot;&quot;); return 0;}","link":"/blog-xcpc/2020/03/25/bitset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"[hihoCoder#1034] 毁灭者问题","text":"题目链接 Solution很好的一道题！坑也很多（呜呜呜～ 如果没有 $m_i$ 的限制，就是一道线段树入门题了，但是有了 $m_i$ 我们就会发现线段树很难办到诶……必须要转换思路！ 方便起见，先考虑初值都是 $0$ 的情况。 我们依次考虑每一个魔法单位被吸收的时刻序列，那么两个时刻之间的差即是这个魔法单位恢复法力的时间，这个时间 $\\Delta t$ 分成两类： 大于 $\\left\\lfloor\\frac{m_i}{r_i}\\right\\rfloor$：魔法单位可恢复至最大值 $m_i$. 小于等于 $\\left\\lfloor\\frac{m_i}{r_i}\\right\\rfloor$：魔法单位可恢复 $\\Delta t\\cdot r_i$. 所以，假设现在我们已经把所有时间差存在了一个数据结构里，我们希望 $O(\\lg n)$ 地查询大于 $\\left\\lfloor\\frac{m_i}{r_i}\\right\\rfloor$ 的时间差有多少个，以及小于等于 $\\left\\lfloor\\frac{m_i}{r_i}\\right\\rfloor$ 的时间差的总和，那么答案加上前者乘以 $m_i$ 再加上后者乘以 $r_i$ 即可。 为了维护时间差，我们再引入一个存储时刻的数据结构，那么从第 $i$ 个单位到第 $i+1$ 个单位，减去以第 $i$ 个单位为右端的时间，加上以第 $i+1$ 个单位为左端的时间即可。同时，减掉一个时间 $t$ 时，设其后继为 $suc$，前驱为 $pre$，就需要在维护时间差的那个数据结构里面减掉 $suc-t$ 和 $t-pre$，加上 $suc-pre$；加上一个时间 $t$ 时，在维护时间差的数据结构里加上 $suc-t$ 和 $t-pre$，减掉 $suc-pre$. 综上，我们希望两个数据结构支持：添加、删除、求小于等于某数的所有元素的和、求小于等于某数的元素个数。值域线段树可以，但是离散化不是很方便，所以我用了两个平衡树（Splay）维护。 然后考虑初值 $s_i$ 的处理：其实只需要重新计算一下第一次的吸收值，修正一下答案即可。 坑点： 时间 $t$ 可能相同，如果删除一个 $t$ 后还有相同的 $t$ 存在，或者加入一个 $t$ 之前已经有相同的 $t$ 了，那么在此时不需要更新存储时间差的平衡树； $r_i$ 可能为 $0$，小心发生除 $0$ 错误。 Data给一些我调试过程中造的数据吧： input output 40 1 80 1 80 1 60 5 261 1 32 1 13 2 24 1 15 2 35 1 4 14 56 10 10 12 16 20 10 12 10 10 125 1 519 1 5 94 再贴上随机数据生成器： >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;int Rand(int l, int r){ return rand() % (r - l + 1) + l;}struct Node{ int s, m, r;}node[100005];struct Opt{ int t, l, r; bool operator &lt; (const Opt &amp;A) const{ return t &lt; A.t; }}opt[100005];int main(){ srand(time(NULL)); freopen(&quot;input.txt&quot;, &quot;w&quot;, stdout); int n = Rand(100000, 100000), m = Rand(100000, 100000); printf(&quot;%d\\n&quot;, n); for(int i = 1; i &lt;= n; i++){ node[i].m = Rand(0, 100000); node[i].s = Rand(0, m); node[i].r = Rand(0, 100000); printf(&quot;%d %d %d\\n&quot;, node[i].s, node[i].m, node[i].r); } printf(&quot;%d\\n&quot;, m); for(int i = 1; i &lt;= m; i++){ opt[i].t = Rand(0, 1000000000); opt[i].l = Rand(1, n); opt[i].r = Rand(1, n); if(opt[i].l &gt; opt[i].r) swap(opt[i].l, opt[i].r); } sort(opt+1, opt+m+1); for(int i = 1; i &lt;= m; i++){ printf(&quot;%d %d %d\\n&quot;, opt[i].t, opt[i].l, opt[i].r); } return 0;} Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int N = 100005;const LL INF = 1e16;int n, m;LL ans;struct Node{ LL s, m, r;}a[N];struct Operation{ LL t; int l, r;}opt[N];vector&lt; pair&lt;LL, int&gt; &gt; vec[N];struct SplayOperations{ struct Splay{ int fa, son[2], size, cnt; LL val, sum; }tr[N&lt;&lt;3];#define which(x, fa) (tr[fa].son[1] == x) int id = 0, root = 0; inline void pushup(int x){ if(x){ tr[x].size = tr[x].cnt; tr[x].sum = tr[x].val * tr[x].cnt; if(tr[x].son[0]) tr[x].size += tr[tr[x].son[0]].size, tr[x].sum += tr[tr[x].son[0]].sum; if(tr[x].son[1]) tr[x].size += tr[tr[x].son[1]].size, tr[x].sum += tr[tr[x].son[1]].sum; } } inline void rotate(int x, int dir){ int y = tr[x].fa, z = tr[y].fa, B = tr[x].son[dir]; tr[z].son[which(y, z)] = x; tr[x].fa = z; tr[x].son[dir] = y; tr[y].fa = x; tr[y].son[dir^1] = B; tr[B].fa = y; pushup(y), pushup(x); } inline void splay(int x, int goal){ if(x == goal) return; while(tr[x].fa != goal){ int y = tr[x].fa, z = tr[y].fa, dir1 = which(x, y)^1, dir2 = which(y, z)^1; if(z == goal) rotate(x, dir1); else{ if(dir1 == dir2) rotate(y, dir2); else rotate(x, dir1); rotate(x, dir2); } } if(goal == 0) root = x; } inline int select(LL val){ int now = root; while(now){ if(tr[now].val == val) return now; else if(tr[now].val &gt; val) now = tr[now].son[0]; else if(tr[now].val &lt; val) now = tr[now].son[1]; } if(!now) return -1; return now; } inline LL getPre(LL val){ int now = root; LL res = -INF; while(now){ if(tr[now].val &lt; val){ res = max(res, tr[now].val); now = tr[now].son[1]; } else now = tr[now].son[0]; } return res; } inline LL getSuc(LL val){ int now = root; LL res = INF; while(now){ if(tr[now].val &gt; val){ res = min(res, tr[now].val); now = tr[now].son[0]; } else now = tr[now].son[1]; } return res; } inline int newNode(LL val, int fa){ id++; tr[id].val = tr[id].sum = val; tr[id].fa = fa; tr[id].son[0] = tr[id].son[1] = 0; tr[id].size = tr[id].cnt = 1; return id; } inline void insert(LL val){ splay(select(getPre(val)), 0); splay(select(getSuc(val)), root); int &amp;x = tr[tr[root].son[1]].son[0]; if(x) tr[x].cnt++, tr[x].size++, tr[x].sum += val; else x = newNode(val, tr[root].son[1]); pushup(tr[root].son[1]); pushup(root); } inline void del(LL val){ splay(select(getPre(val)), 0); splay(select(getSuc(val)), root); int &amp;x = tr[tr[root].son[1]].son[0]; if(!x || !tr[x].cnt) return ; tr[x].cnt--, tr[x].size--, tr[x].sum -= val; if(tr[x].cnt == 0) x = 0; pushup(tr[root].son[1]); pushup(root); }}t1, t2;int main(){// freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld%lld%lld&quot;, &amp;a[i].s, &amp;a[i].m, &amp;a[i].r); scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%lld%d%d&quot;, &amp;opt[i].t, &amp;opt[i].l, &amp;opt[i].r); vec[opt[i].l].push_back(make_pair(opt[i].t, 1)); vec[opt[i].r+1].push_back(make_pair(opt[i].t, -1)); } t1.root = t1.newNode(-INF, 0); t1.tr[t1.root].son[1] = t1.newNode(INF, t1.root); t1.pushup(t1.root); t2.root = t2.newNode(-INF, 0); t2.tr[t2.root].son[1] = t2.newNode(INF, t2.root); t2.pushup(t2.root); for(int i = 1; i &lt;= n; i++){ for(int k = 0; k &lt; vec[i].size(); k++){ if(vec[i][k].second == 1){ t1.insert(vec[i][k].first); if(t1.tr[t1.select(vec[i][k].first)].cnt &gt; 1) continue; LL pre = t1.getPre(vec[i][k].first), suc = t1.getSuc(vec[i][k].first); if(suc != INF){ if(pre != -INF) t2.del(suc - pre); else t2.del(suc); } if(pre != -INF) t2.insert(vec[i][k].first - pre); else t2.insert(vec[i][k].first); if(suc != INF) t2.insert(suc - vec[i][k].first); } else{ LL pre = t1.getPre(vec[i][k].first), suc = t1.getSuc(vec[i][k].first); t1.del(vec[i][k].first); if(t1.select(vec[i][k].first) != -1) continue; if(suc != INF){ if(pre != -INF) t2.insert(suc - pre); else t2.insert(suc); } if(pre != -INF) t2.del(vec[i][k].first - pre); else t2.del(vec[i][k].first); if(suc != INF) t2.del(suc - vec[i][k].first); } } LL firstTime = t1.getSuc(-INF); LL d = a[i].r == 0 ? INF-1 : a[i].m / a[i].r; t2.splay(t2.select(-INF), 0); t2.splay(t2.select(t2.getSuc(d)), t2.root); ans += t2.tr[t2.tr[t2.tr[t2.root].son[1]].son[0]].sum * a[i].r; ans += (t2.tr[t2.root].size - t2.tr[t2.tr[t2.tr[t2.root].son[1]].son[0]].size - 2) * a[i].m; if(firstTime &lt;= d) ans += min(firstTime * a[i].r + a[i].s, a[i].m) - firstTime * a[i].r; } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/02/23/hihoCoder-1034-%E6%AF%81%E7%81%AD%E8%80%85%E9%97%AE%E9%A2%98/"},{"title":"关于扫描线算法中线段树标记的理解","text":"由于扫描线算法的询问只需询问线段树根节点信息，我们没有必要写 pushdown 函数，但同时也引入了一些其他问题。本文记录我做题过程中的理解，水平有限，如有错误，烦请指正。 算法简述扫描线算法用于解决矩形面积并的问题，当然其思想也可用于其他形状的图形和其他问题。 在矩形面积并问题中： 用一条平行于 $x$ 轴的直线自下而上地扫描平面，每扫描到一条矩形的边，就计算这条边和上一条边之间的面积。线段树在这个过程中维护当前扫描线被覆盖的长度。具体地，每扫描到一个矩形的下边，其对应区间就加 $1$；每扫描到一个矩形的上边，其对应区间减 $1$，询问时统计整个区间非零的长度。 为完成上述操作，每个线段树节点储存一个标记 cnt 和一个信息 length：cnt 标记表示该节点对应区间被覆盖了几次； length 表示该节点对应区间的被覆盖长度，也即非零长度。 pushdown 对 cnt 标记的影响由于没有 pushdown 的存在，这里的 cnt 标记比有 pushdown 的线段树的标记的情形复杂一些。 想一想有 pushdown 操作的线段树，我们如果要对某节点进行操作，会先将其祖先节点的标记一路下放下来，所以我们在操作这个节点时，其祖先节点时没有标记的；随后我们就可以顺理成章地把信息一路 pushup 回去——祖先节点都没有标记了，它的信息只依赖于子节点的信息。 而对于没有 pushdown 操作的线段树，某节点的信息不能只靠子节点的信息决定，还由其自身的标记决定。如下图所示，本题中，线段树某节点的 cnt 加 $1$ 后，由于没有 pushdown，其子节点完全不知道自己已经被覆盖了，子节点的信息——比如 length ——仍然是之前的状态。用这个子节点的 length 去更新父节点的 length，显然是错误的。但是结合父节点的 cnt 标记，我们可以知道父节点整个都被覆盖了，于是我们就可以正确地把父节点的 length 赋值为整个区间长度。当然此时此刻，子节点的存储信息是错误信息——但这又有什么关系呢？反正我们只询问根节点信息，只需要保证父节点信息的正确性即可。（自然，这个“父节点”也是某节点的“子节点”，它的信息也可能是错误的；不过，根节点不作为任何节点的子节点，信息一定正确。） 上一段阐述的是自身标记的重要性，但是事实上子节点的信息也是不可缺少的。考虑我们把某节点的两个子节点分两次覆盖住，那么这个节点被覆盖住了，但是 cnt 却为 0。更一般的，cnt == 0 的节点完全有可能整个都被覆盖了，甚至覆盖了好几次，甚至分段覆盖次数还不一样。所以，当父节点的 cnt 标记为 0 时，它的信息需要用其子节点的信息来更新（如下图所示）。当然，这时子节点的信息是局部（相对于父节点）正确的（尽管可能是整体错误的）。 综上所述，cnt == 0 时，length 为左右子节点的 length 之和；而 cnt &gt; 0 时，length 是该节点的对应区间长度。 于是，我们的 pushup 应运而生： 1234567inline void pushup(int id){ if(tr[id].cnt &gt; 0) tr[id].length = x[tr[id].r + 1] - x[tr[id].l]; else{ if(tr[id].l == tr[id].r) tr[id].length = 0; else tr[id].length = tr[lid].length + tr[rid].length; }} 同时，使用 pushup 的时机也要微调——在打了标记之后也需要立刻 pushup。 矩形面积并的模板如下： &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 200005;int n, xid;double tx1, ty1, tx2, ty2, x[N], ans;struct ScanLine{ double x1, x2, y; int k; // k == 1 or -1 int dx1, dx2; // after discretization bool operator &lt; (const ScanLine &amp;A) const{ return y == A.y ? k &gt; A.k : y &lt; A.y; }}a[N];inline void disc(){ sort(x+1, x+xid+1); xid = unique(x+1, x+xid+1) - (x+1); for(int i = 1; i &lt;= n; i++){ a[i].dx1 = lower_bound(x+1, x+xid+1, a[i].x1) - x; a[i].dx2 = lower_bound(x+1, x+xid+1, a[i].x2) - x; }}struct SegTree{ int l, r, cnt; double length;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ if(tr[id].cnt &gt; 0) tr[id].length = x[tr[id].r + 1] - x[tr[id].l]; else{ if(tr[id].l == tr[id].r) tr[id].length = 0; else tr[id].length = tr[lid].length + tr[rid].length; }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].cnt = 0, tr[id].length = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].cnt += val; pushup(id); return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%lf%lf%lf%lf&quot;, &amp;tx1, &amp;ty1, &amp;tx2, &amp;ty2); a[i] = (ScanLine){tx1, tx2, ty1, 1}; a[i+n] = (ScanLine){tx1, tx2, ty2, -1}; x[++xid] = tx1, x[++xid] = tx2; } n &lt;&lt;= 1; disc(); sort(a+1, a+n+1); build(1, 1, xid-1); for(int i = 1; i &lt; n; i++){ add(1, a[i].dx1, a[i].dx2 - 1, a[i].k); ans += tr[1].length * (a[i+1].y - a[i].y); } printf(&quot;%.2f\\n&quot;, ans); return 0;} 进一步与其说 cnt 标记表示“该节点对应区间被覆盖了几次”，不如说： cnt == 0 表示我们对该节点对应区间一无所知——它可能没被覆盖，可能部分覆盖，可能全被覆盖，甚至覆盖次数还不同……我们要知道这个节点的 length 信息，只能从其子节点 pushup 上来； cnt == 1 表示这个节点对应区间被覆盖至少 $1$ 次——当然也可能覆盖了多次，或者分成好几段覆盖了不同次——但总之被完全覆盖了，length 就是对应区间长度。同时它的子节点并不知道它的覆盖情况。 这样的理解是有好处的，比如说我们遇到了加强版的题目：hdu 1255 覆盖的面积 题目要求求出被矩形覆盖过至少两次的区域面积。我们在线段树节点中维护一个标记 cnt，两个信息 length1,length2，分别表示区间被覆盖至少 $1$ 次的长度和被覆盖至少 $2$ 次的长度。于是： cnt == 0 表示我们对该节点对应区间一无所知，它的 length1,length2 信息由子节点决定； cnt == 1 表示这个节点对应区间被覆盖至少 $1$ 次，它的 length1 就是区间长度，length2 是左右子节点的 length1 之和——该节点对应区间整个已经被覆盖至少一次了（子节点并不知道），只需要子节点再覆盖一次就好； cnt &gt;= 2 表示这个节点对应区间被覆盖至少 $2$ 次，它的 length1,length2 都是区间长度。 pushup 如下： 123456789101112131415161718inline void pushup(int id){ if(tr[id].cnt &gt;= 2){ // interval is covered at least twice tr[id].length2 = x[tr[id].r + 1] - x[tr[id].l]; tr[id].length1 = x[tr[id].r + 1] - x[tr[id].l]; } else if(tr[id].cnt == 1){ // interval is covered at least once if(tr[id].l == tr[id].r) tr[id].length2 = 0; else tr[id].length2 = tr[lid].length1 + tr[rid].length1; tr[id].length1 = x[tr[id].r + 1] - x[tr[id].l]; } else{ // do not know the infomation of this interval if(tr[id].l == tr[id].r) tr[id].length1 = tr[id].length2 = 0; else{ tr[id].length1 = tr[lid].length1 + tr[rid].length1; tr[id].length2 = tr[lid].length2 + tr[rid].length2; } }} AC 代码如下： >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2005;int T, n, xid;double tx1, ty1, tx2, ty2, x[N], ans;struct ScanLine{ double x1, x2, y; int k; // k == 1 or -1 int dx1, dx2; // after discretization bool operator &lt; (const ScanLine &amp;A) const{ return y == A.y ? k &gt; A.k : y &lt; A.y; }}a[N];inline void disc(){ sort(x+1, x+xid+1); xid = unique(x+1, x+xid+1) - (x+1); for(int i = 1; i &lt;= n; i++){ a[i].dx1 = lower_bound(x+1, x+xid+1, a[i].x1) - x; a[i].dx2 = lower_bound(x+1, x+xid+1, a[i].x2) - x; }}struct SegTree{ int l, r, cnt; double length1, length2;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ if(tr[id].cnt &gt;= 2){ // interval is covered at least twice tr[id].length2 = x[tr[id].r + 1] - x[tr[id].l]; tr[id].length1 = x[tr[id].r + 1] - x[tr[id].l]; } else if(tr[id].cnt == 1){ // interval is covered at least once if(tr[id].l == tr[id].r) tr[id].length2 = 0; else tr[id].length2 = tr[lid].length1 + tr[rid].length1; tr[id].length1 = x[tr[id].r + 1] - x[tr[id].l]; } else{ // do not know the infomation of this interval if(tr[id].l == tr[id].r) tr[id].length1 = tr[id].length2 = 0; else{ tr[id].length1 = tr[lid].length1 + tr[rid].length1; tr[id].length2 = tr[lid].length2 + tr[rid].length2; } }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].cnt = 0, tr[id].length1 = tr[id].length2 = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].cnt += val; pushup(id); return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d&quot;, &amp;n); xid = 0; ans = 0; memset(tr, 0, sizeof tr); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%lf%lf%lf%lf&quot;, &amp;tx1, &amp;ty1, &amp;tx2, &amp;ty2); a[i] = (ScanLine){tx1, tx2, ty1, 1}; a[i+n] = (ScanLine){tx1, tx2, ty2, -1}; x[++xid] = tx1, x[++xid] = tx2; } n &lt;&lt;= 1; disc(); sort(a+1, a+n+1); build(1, 1, xid-1); for(int i = 1; i &lt; n; i++){ add(1, a[i].dx1, a[i].dx2 - 1, a[i].k); ans += tr[1].length2 * (a[i+1].y - a[i].y); } printf(&quot;%.2f\\n&quot;, ans); } return 0;} 再加强hdu 3642 Get the Treasury 三维空间，首先我们循环 $z$ 坐标，就可以转化成平面上求被覆盖至少三次的矩形面积。有了上述理解，就可以容易地写出代码了： >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 2005;int T, n, xid, aid, zid;LL x[N], ans, z[N];struct Node{ LL x1, y1, z1, x2, y2, z2;}node[N];struct ScanLine{ LL x1, x2, y; int k; // k == 1 or -1 int dx1, dx2; // after discretization bool operator &lt; (const ScanLine &amp;A) const{ return y == A.y ? k &gt; A.k : y &lt; A.y; }}a[N];inline void disc(){ sort(x+1, x+xid+1); xid = unique(x+1, x+xid+1) - (x+1); for(int i = 1; i &lt;= aid; i++){ a[i].dx1 = lower_bound(x+1, x+xid+1, a[i].x1) - x; a[i].dx2 = lower_bound(x+1, x+xid+1, a[i].x2) - x; }}struct SegTree{ int l, r, cnt; LL length1, length2, length3;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)#define len(id) (tr[id].r - tr[id].l + 1)inline void pushup(int id){ if(tr[id].cnt &gt;= 3) tr[id].length3 = tr[id].length2 = tr[id].length1 = x[tr[id].r + 1] - x[tr[id].l]; else if(tr[id].cnt == 2){ if(tr[id].l == tr[id].r) tr[id].length3 = 0; tr[id].length3 = tr[lid].length1 + tr[rid].length1; tr[id].length2 = tr[id].length1 = x[tr[id].r + 1] - x[tr[id].l]; } else if(tr[id].cnt == 1){ if(tr[id].l == tr[id].r) tr[id].length3 = tr[id].length2 = 0; else{ tr[id].length3 = tr[lid].length2 + tr[rid].length2; tr[id].length2 = tr[lid].length1 + tr[rid].length1; } tr[id].length1 = x[tr[id].r + 1] - x[tr[id].l]; } else{ if(tr[id].l == tr[id].r) tr[id].length3 = tr[id].length2 = tr[id].length1 = 0; else{ tr[id].length3 = tr[lid].length3 + tr[rid].length3; tr[id].length2 = tr[lid].length2 + tr[rid].length2; tr[id].length1 = tr[lid].length1 + tr[rid].length1; } }}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].cnt = 0, tr[id].length1 = tr[id].length2 = 0; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void add(int id, int l, int r, int val){ if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].cnt += val; pushup(id); return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val); pushup(id);}inline void init(){ xid = aid = 0; memset(tr, 0, sizeof tr); memset(a, 0, sizeof a); memset(x, 0, sizeof x); memset(a, 0, sizeof a);}int main(){ scanf(&quot;%d&quot;, &amp;T); for(int CASES = 1; CASES &lt;= T; CASES++){ ans = 0; zid = 0; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;node[i].x1, &amp;node[i].y1, &amp;node[i].z1, &amp;node[i].x2, &amp;node[i].y2, &amp;node[i].z2); z[++zid] = node[i].z1, z[++zid] = node[i].z2; } sort(z+1, z+zid+1); zid = unique(z+1, z+zid+1) - (z+1); for(int j = 1; j &lt; zid; j++){ init(); for(int i = 1; i &lt;= n; i++){ if(node[i].z1 &lt;= z[j] &amp;&amp; node[i].z2 &gt; z[j]){ x[++xid] = node[i].x1, x[++xid] = node[i].x2; a[++aid] = (ScanLine){node[i].x1, node[i].x2, node[i].y1, 1}; a[++aid] = (ScanLine){node[i].x1, node[i].x2, node[i].y2, -1}; } } disc(); sort(a+1, a+aid+1); build(1, 1, xid-1); LL res = 0; for(int i = 1; i &lt; aid; i++){ add(1, a[i].dx1, a[i].dx2 - 1, a[i].k); res += tr[1].length3 * (a[i+1].y - a[i].y); } ans += res * (z[j+1] - z[j]); } printf(&quot;Case %d: %lld\\n&quot;, CASES, ans); } return 0;}","link":"/blog-xcpc/2020/02/12/%E5%85%B3%E4%BA%8E%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E4%B8%AD%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%87%E8%AE%B0%E7%9A%84%E7%90%86%E8%A7%A3/"},{"title":"快速傅立叶变换学习笔记","text":"参考：《算法导论》P527-541. Brief Introduction多项式在系数表示下的乘法需要 $O(n^2)$ 的时间，但在点值表示下的乘法仅需 $O(n)$ 的时间，离散傅立叶变换（DFT）提供了将多项式从系数表示转换到点值表示的方法，而其逆运算（IDFT）将多项式从点值表示转换到系数表示。为了方便，我们常选用单位复数根作为这些点。利用单位复数根的性质，快速傅立叶变换（FFT）采用分治的思路将复杂度降低至 $O(n\\lg n)$ ——分别计算奇数项和偶数项，然后合并；而运用可逆矩阵与范德蒙德矩阵等知识，可以推出逆FFT的公式，并发现其与FFT有惊人的相似性。递归实现的FFT效率不是很高，常数大，可将其改为迭代形式，不过自底而上的迭代实现需要知道递归树中叶子节点的顺序——我们发现该顺序正好是位逆序置换，可以预处理出来。 系数表达与点值表达系数表达：用向量 $a=(a_0,a_1,\\cdots,a_{n-1})$ 表示一个 $n-1$ 次多项式：$A(x)=\\sum\\limits_{i=0}^{n-1}a_ix^i$. 点值表达：用 $n$ 个点值对所组成的集合 ${(x_0,y_0),(x_1,y_1),\\cdots,(x_{n-1},y_{n-1})}$ 表示多项式，其中所有 $x_k$ 各不相同且 $y_k=A(x_k)$. 可以证明，$n$ 个点能唯一确定一个 $n-1$ 次多项式。显然，一个多项式有多种不同的点值表示方法。 系数表达转点值表达：取 $n$ 个不同横坐标，算一下它们的纵坐标，得到 $n$ 个点。这样做是 $\\Theta(n^2)$ 的，使用 $\\textbf{FFT}$ 可做到 $\\Theta(n\\lg n)$. 点值表达转系数表达：运用拉格朗日插值可以 $\\Theta(n^2)$ 求出系数表达，使用 $\\textbf{IFFT}$ 可做到 $\\Theta(n\\lg n)$. 单位复数根$n$ 次单位复数根是满足 $\\omega^n=1$ 的那些复数 $\\omega$，正好有 $n$ 个：$e^{2\\pi ik/n},,k=0,1,\\cdots,n-1$. 证明：$$\\omega^n={(e^{2\\pi ik/n})}^n=e^{2\\pi ik}={(-1)}^{2k}=1\\quad\\quad\\blacksquare$$称 $\\omega_n=e^{2\\pi i/n}=\\cos\\left(\\frac{2\\pi}{n}\\right)+i\\sin\\left(\\frac{2\\pi}{n}\\right)$ 为主 $n$ 次单位根，其他单位复数根都是 $\\omega_n$ 的幂次。 如果画出复平面，则 $n$ 个 $n$ 次单位复数根：$\\omega_n^0,\\omega_n^1,\\cdots,\\omega_n^n$ 把平面分均分成了 $n$ 块（注意复数相乘=模长相乘，幅角相加）： 单位复数根的基本性质 消去引理：对任意整数 $n\\geqslant 0,,k\\geqslant 0,,d\\geqslant 0$，有：$$\\omega_{dn}^{dk}=\\omega_{n}^k$$证：$$\\omega_{dn}^{dk}=e^{2\\pi i dk/dn}=e^{2\\pi i k/n}=\\omega_{n}^k\\quad\\quad\\blacksquare$$ 直观理解：分成 $dn$ 份的第 $dk$ 个点和分成 $n$ 份的第 $k$ 个点显然是同一个点。 推论：对任意偶数 $n&gt;0$，有：$$\\omega_n^{n/2}=\\omega_2=-1$$ 直观理解：分成偶数份时，中间那个点显然是 $(-1,0)$. 折半引理：如果 $n&gt;0$ 为偶数，那么 $n$ 个 $n$ 次单位复数根的平方的集合就是 $n/2$ 个 $n/2$ 次单位复数根的集合。 证：对于 $\\forall k\\in[0,n/2)$，根据单位复数根的运算和消去引理有：$$\\left(\\omega_n^k\\right)^2=\\left(\\omega_n^{k+n/2}\\right)^2=\\omega_n^{2k}=\\omega_{n/2}^k\\quad\\quad\\blacksquare$$ 直观理解：注意这里单位复数根相乘其实就是幅角相加（长度始终为 $1$），所以 $\\left(\\omega_n^k\\right)^2$ 就是分成 $n$ 份的第 $2k$ 份。 求和引理：对任意整数 $n\\geqslant1$ 和不能被 $n$ 整除的非负整数 $k$，有：$$\\sum_{j=0}^{n-1}\\left(\\omega_n^k\\right)^j=0$$证：等比数列求和公式也适用于复数：$$\\sum_{j=0}^{n-1}\\left(\\omega_n^k\\right)^j=\\frac{1-\\left(\\omega_n^k\\right)^n}{1-\\omega_n^k}=\\frac{\\omega_n^{nk}-1}{\\omega_n^k-1}=\\frac{\\omega_1^k-1}{\\omega_n^k-1}=0\\quad\\quad\\blacksquare$$ $\\textbf{DFT}$：系数表达 $\\to$ 点值表达特殊地选取 $n$ 个点：对于多项式 $A(x)=\\sum\\limits_{i=0}^{n-1}a_ix^i$，我们取它在 $n$ 个 $n$ 次单位复数根 $\\omega_n^0,\\omega_n^1,\\cdots,\\omega_n^{n-1}$ 处的点为其点值表达。即设$$y_k=A(\\omega_n^k)=\\sum_{i=0}^{n-1}a_i\\omega_n^{ki}$$称向量 $y=(y_0,y_1,\\cdots,y_{n-1})$ 为系数向量 $a=(a_0,a_1,\\cdots a_{n-1})$ 的离散傅立叶变换。 上述过程只说明了我们选点的特殊，直接算仍是 $\\Theta(n^2)$，$\\textbf{FFT}$ 利用复数单位根的性质将其优化到 $\\Theta(n\\lg n)$. $\\textbf{FFT}$：采用分治策略假设 $n$ 是 $2$ 的幂次！ 按照下标的奇偶分组，设 $\\begin{cases}A^{[0]}(x)=a_0+a_2x+a_4x^2+\\cdots+a_{n-2}x^{n/2-1}\\A^{[1]}(x)=a_1+a_3x+a_5x^2+\\cdots+a_{n-1}x^{n/2-1}\\end{cases}$，于是：$$A(x)=\\left(a_0+a_2x^2+a_4x^4+\\cdots+a_{n-2}x^{n-2}\\right)+\\left(a_1x+a_3x^3+a_5x^5+\\cdots+a_{n-1}x^{n-1}\\right)=A^{[0]}(x^2)+xA^{[1]}(x^2)$$所以，欲求 $A(x)$ 在 $\\omega_n^0,\\omega_n^1,\\cdots,\\omega_n^{n-1}$ 处的取值，只需要求 $A^{[0]}(x)$ 和 $A^{[1]}(x)$ 在 $\\left(\\omega_n^0\\right)^2,\\left(\\omega_n^1\\right)^2,\\cdots,\\left(\\omega_n^{n-1}\\right)^2$ 处的取值。 注意，根据折半引理，上述 $n$ 个值其实是 $n/2$ 个 $n/2$ 次单位复数根 $\\omega_{n/2}^0,\\omega_{n/2}^1,\\cdots,\\omega_{n/2}^{n/2-1}$，每个数恰好出现 $2$ 次。所以，我们把原问题划分成了两个规模为一半的子问题，于是 $\\textbf{FFT}$ 的复杂度为：$T(n)=2T(n/2)+\\Theta(n)=\\Theta(n\\lg n)$. $\\textbf{IDFT}$：点值表达 $\\to$ 系数表达现在我们已经能在 $\\Theta(n\\lg n)$ 的时间内将系数表达转换到点值表达，那我们需要转换回去，即完成逆运算。 我们将 $y_k=A(\\omega_n^k)=\\sum\\limits_{i=0}^{n-1}a_i\\omega_n^{ki}$ 写作矩阵形式 $y=V_na$：$$\\begin{bmatrix}y_0\\y_1\\y_2\\y_3\\\\vdots\\y_{n-1}\\end{bmatrix}=\\begin{bmatrix}1&amp;1&amp;1&amp;1&amp;\\cdots&amp;1\\1&amp;\\omega_n&amp;\\omega_n^2&amp;\\omega_n^3&amp;\\cdots&amp;\\omega_n^{n-1}\\1&amp;\\omega_n^2&amp;\\omega_n^4&amp;\\omega_n^6&amp;\\cdots&amp;\\omega_n^{2(n-1)}\\1&amp;\\omega_n^3&amp;\\omega_n^6&amp;\\omega_n^9&amp;\\cdots&amp;\\omega_n^{3(n-1)}\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\1&amp;\\omega_n^{n-1}&amp;\\omega_n^{2(n-1)}&amp;\\omega_n^{3(n-1)}&amp;\\cdots&amp;\\omega_n^{(n-1)(n-1)}\\end{bmatrix}\\begin{bmatrix}a_0\\a_1\\a_2\\a_3\\\\vdots\\a_{n-1}\\end{bmatrix}$$这里 $V_n$ 是一个由 $\\omega_n$ 的幂次填充而成的范德蒙德矩阵。 注意，系数表达就是指向量 $a$，点值表达就是指向量 $y$，所以我们只需要解出 $a=V_n^{-1}y$，就完成了点值表达到系数表达的转换。 对于范德蒙德矩阵，可以验证，$V_n^{-1}$ 的 $(j,k)$ 处元素为 $\\omega_n^{-kj}/n$（ $j,k=0,1,\\cdots,n-1$ ），所以我们有：$$a_k=\\frac{1}{n}\\sum_{i=0}^{n-1}y_k^i\\omega_n^{-ki}$$于是乎，我们用 $\\omega_n^{-1}$ 替换 $\\omega_n$，互换 $a$ 和 $y$，将计算结果的每个元素都除以 $n$，就可以套用之前的 $\\textbf{FFT}$ 过程在 $\\Theta(n\\lg n)$ 的时间内完成 $\\textbf{IDFT}$ 的运算。 $\\textbf{FFT}$ 的高效实现递归实现 $\\textbf{FFT}$ 的效率不高，我们考虑自底向上迭代实现。自底向上要解决的一个问题就是递归树中叶节点的顺序，我们作递归树如下： 发现，递归树的叶子顺序正好是它在原序列中下标的位逆序置换。预处理出位逆序置换的结果，我们可以完成迭代版 $\\textbf{FFT}$ 的实现。 CodeATT：$n$ 要选取 $2$ 的整数幂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct Complex{ double real, imag; Complex(){ real = imag = 0; } Complex(double r, double i){ real = r, imag = i; } Complex operator + (Complex &amp;A){ return Complex(real+A.real, imag+A.imag); } Complex operator - (Complex &amp;A){ return Complex(real-A.real, imag-A.imag); } Complex operator * (Complex &amp;A){ return Complex(real*A.real-imag*A.imag, real*A.imag+imag*A.real); }};namespace FFT{ int n; vector&lt;int&gt; rev; inline void preprocess(int _n, int _m){ int cntBit = 0; for(n = 1; n &lt;= _n + _m; n &lt;&lt;= 1, cntBit++); // n == 2^cntBit is a upper bound of _n+_m rev.resize(n); for(int i = 0; i &lt; n; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1) &lt;&lt; (cntBit-1)); // rev[k] is bit-reversal permutation of k } inline void fft(vector&lt;Complex&gt; &amp;A, int flag){ // flag == 1: DFT; flag == -1: IDFT A.resize(n); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(A[i], A[rev[i]]); for(int m = 2; m &lt;= n; m &lt;&lt;= 1){ Complex wm(cos(2*PI/m), flag * sin(2*PI/m)); for(int k = 0; k &lt; n; k += m){ Complex w(1, 0); for(int j = 0; j &lt; m / 2; j++){ Complex t = w * A[k+j+m/2], u = A[k+j]; A[k+j] = u + t, A[k+j+m/2] = u - t; w = w * wm; } } } if(flag == -1) for(int i = 0; i &lt; n; i++) A[i].real /= n; }}int main(){ // ... input FFT::preprocess(n, m); FFT::fft(f, 1); // f used to be coefficients, now they're point-values FFT::fft(g, 1); // g used to be coefficients, now they're point-values for(int i = 0; i &lt; FFT::n; i++) f[i] = f[i] * g[i]; FFT::fft(f, -1); // f used to be point-values, now they're coefficients // ... output return 0;}","link":"/blog-xcpc/2020/10/05/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"快速数论变换学习笔记","text":"参考：知乎专栏·桃酱的算法笔记 Idea只需将 $\\textbf{FFT}$ 与 $\\textbf{NTT}$ 之间建立起映射关系即可。 $\\textbf{FFT}$ 的关键在于单位复数根 $\\omega$，它定义为 $\\omega^n=1$，其中主 $n$ 次复数根定义为 $\\omega_n=e^{2\\pi i/n}$，满足消去、折半、求和引理。 那么在模 $p$ 意义下，考虑 $p$ 的原根 $g$，与 $\\omega_n$ 对应的便是 $g^{\\frac{p-1}{n}}$，满足 $\\left(g^{\\frac{p-1}{n}}\\right)^n\\equiv g^{p-1}\\equiv1\\pmod p$，当然这里要求 $n$ 是 $p-1$ 的因子。下面证明 $g^{\\frac{p-1}{n}}$ 也满足消去、折半、求和引理： 消去引理：$\\left(g^{\\frac{p-1}{dn}}\\right)^{dk}=\\left(g^{\\frac{p-1}{n}}\\right)^k$，证明显然； 折半引理：$\\left(g^{\\frac{p-1}{n}}\\right)^2=g^{\\frac{p-1}{n/2}}$，证明显然； 求和引理：$\\sum\\limits_{j=0}^{n-1}\\left(g^{\\frac{p-1}{n}}\\right)^{kj}\\equiv\\frac{\\left(g^{\\frac{p-1}{n}}\\right)^{kn}-1}{\\left(g^{\\frac{p-1}{n}}\\right)^k-1}\\equiv\\frac{g^{(p-1)k}-1}{g^{(p-1)k/n}-1}\\equiv0\\pmod p$，证明显然。 于是乎，关于 $\\textbf{FFT}$ 的一切也成立于 $\\textbf{NTT}$，只需将 $\\omega_n$ 换成 $g^{\\frac{p-1}{n}}$ 即可。 由于 $n$ 是 $2$ 的幂次，又是 $p-1$ 的因子，所以 $p$ 是形如 $c\\cdot2^k+1$ 形式的素数，常用： $p$ $g$ $\\text{inv}(g)$ $n$ 的上界 $998244353$ $3$ $332748118$ $n\\leqslant2^{23}=8388608$ $1004535809$ $3$ $334845270$ $n\\leqslant 2^{21}=2097152$ $469762049$ $3$ $156587350$ $n\\leqslant 2^{26}=67108864$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const LL MOD = 998244353;const LL G = 3;const LL invG = 332748118;namespace NTT{ int n; vector&lt;int&gt; rev; inline void preprocess(int _n, int _m){ int cntBit = 0; for(n = 1; n &lt;= _n + _m; n &lt;&lt;= 1, cntBit++); // n == 2^cntBit is a upper bound of _n+_m rev.resize(n); for(int i = 0; i &lt; n; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1) &lt;&lt; (cntBit-1)); // rev[k] is bit-reversal permutation of k } inline void ntt(vector&lt;LL&gt; &amp;A, int flag){ // flag == 1: NTT; flag == -1: INTT A.resize(n); for(int i = 0; i &lt; n; i++) if(i &lt; rev[i]) swap(A[i], A[rev[i]]); for(int m = 2; m &lt;= n; m &lt;&lt;= 1){ LL wm = flag == 1 ? fpow(G, (MOD-1)/m) : fpow(invG, (MOD-1)/m); for(int k = 0; k &lt; n; k += m){ LL w = 1; for(int j = 0; j &lt; m / 2; j++){ LL t = w * A[k+j+m/2] % MOD, u = A[k+j]; A[k+j] = (u + t) % MOD; A[k+j+m/2] = (u - t + MOD) % MOD; w = w * wm % MOD; } } } if(flag == -1){ LL inv = fpow(n, MOD-2); for(int i = 0; i &lt; n; i++) (A[i] *= inv) %= MOD; } }}int main(){ // ... input NTT::preprocess(n, m); NTT::ntt(f, 1); // f used to be coefficients, now they're point-values NTT::ntt(g, 1); // g used to be coefficients, now they're point-values for(int i = 0; i &lt; NTT::n; i++) f[i] = f[i] * g[i]; NTT::ntt(f, -1); // f used to be point-values, now they're coefficients // ... output return 0;}","link":"/blog-xcpc/2020/10/06/%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"数论函数学习笔记","text":"参考资料：oi-wiki 莫比乌斯反演｜oi-wiki 筛法｜oi-wiki 欧拉函数｜blog｜blog 积性函数 Multiplicable functionDefinition： $\\forall x,y\\in\\mathbb{N}_+$，$\\gcd(x,y)=1$，都有 $f(xy)=f(x)f(y)$，则称 $f(x)$ 是积性函数。 $\\forall x,y\\in\\mathbb{N}_+$，都有 $f(xy)=f(x)f(y)$，则称 $f(x)$ 是 完全积性函数。 Properties：若 $f(x),g(x)$ 均为积性函数，则下列函数也是积性函数：$$\\begin{align}&amp;h(x)=f(x^p)\\&amp;h(x)=f^p(x)\\&amp;h(x)=f(x)g(x)\\&amp;h(x)=\\sum_{d\\mid x}f(d)g\\left(\\frac{x}{d}\\right)\\end{align}$$ Examples： 单位函数：$\\epsilon(n)=[n=1]$ 恒等函数：$\\text{id}_k(n)=n^k$ $k=1$ 时，$\\text{id}(n)=n$ 即标号函数 常数函数：$1(n)=1$ 除数函数：$\\sigma_k(n)=\\sum\\limits_{d\\mid n}d^k$ $k=0$ 时，$\\sigma_0(n)=d(n)=\\sum\\limits_{d\\mid n}1$ 即约数个数函数 $k=1$ 时，$\\sigma(n)=\\sum\\limits_{d\\mid n}d$ 即约数和函数 欧拉函数：$\\varphi(n)=\\sum\\limits_{i=1}^n[\\gcd(i,n)=1]$ 莫比乌斯函数：$\\mu(n)=\\begin{cases}1&amp;n=1\\0&amp;\\exists d&gt;1:d^2\\mid n\\(-1)^{\\omega(n)}&amp;\\text{otherwise}\\end{cases}$，其中，$\\omega(n)$ 表示 $n$ 的不同质因数个数 ##欧拉函数 Euler’s totient function Definition：$\\varphi(n)$ 表示小于等于 $n$ 的与 $n$ 互质的数的个数。 Theorem：设 $n=\\prod\\limits_{i=1}^k{p_i}^{r_i}$（由唯一分解定理给出），则：$$\\varphi(n)=n\\cdot\\prod\\limits_{i=1}^k\\left(1-\\frac{1}{p_i}\\right)$$Intuitive proof：对于 $p_i$ 来说，$p_i$ 及其倍数是 $n$ 的因数，占比 $\\frac{1}{p_i}$，则非 $p_i$ 或其倍数者占比 $\\left(1-\\frac{1}{p_i}\\right)$；故既非 $p_1$ 倍数、又非 $p_2$ 倍数……又非 $p_k$倍数的数占比 $\\prod\\limits_{i=1}^k\\left(1-\\frac{1}{p_i}\\right)$，故 $\\varphi(n)=n\\cdot\\prod\\limits_{i=1}^k\\left(1-\\frac{1}{p_i}\\right)$. Properties： 设 $p$ 是素数，$\\varphi(p)=p-1$. （由定义显然） 设 $p$ 是素数，$n=p^k$，则 $\\varphi(n)=p^k-p^{k-1}$（代入公式易得） 积性：若 $(a,b)=1$，则 $\\varphi(a\\times b)=\\varphi(a)\\times\\varphi(b)$（代入公式易得） 对于素数 $p$ ：$\\varphi(n\\times p)=\\begin{cases}\\varphi(n)\\times p&amp;p\\mid n\\\\varphi(n)\\times(p-1)&amp;p\\nmid n\\end{cases}$（代入公式易得） 小于等于 $n$ 与 $n$ 互质的数的总和为 $\\varphi(n)\\cdot\\frac{n}{2}$ 证明：若 $m$ 与 $n$ 互质，则 $n-m$ 也与 $n$ 互质，故所有小于等于 $n$ 与 $n$ 互质的数的平均数为 $\\frac{n}{2}$，故总和为 $\\varphi(n)\\cdot\\frac{n}{2}$. $n=\\sum\\limits_{d|n}\\varphi(d)$. 证明：设 $f(x)$ 表示 $\\gcd(k,n)=x;(k\\leqslant n)$ 的数的个数，则 $n=\\sum\\limits_{i=1}^nf(i)$。又 $\\gcd(k,n)=x\\iff\\gcd\\left(\\frac{k}{x},\\frac{n}{x}\\right)=1$，所以 $f(x)=\\varphi\\left(\\frac{n}{x}\\right)$，故 $n=\\sum\\limits_{i=1}^n\\varphi\\left(\\frac{n}{i}\\right)=\\sum\\limits_{d\\mid n}\\varphi(d)$. Code（应用公式求出单个 $\\varphi(n)$）： Complexity：$O(\\sqrt n)$ 123456789101112int getPhi(int n){ int res = n; for(int i = 2; i * i &lt;= n; i++){ if(n % i == 0){ res = res / i * (i - 1); while(n % i == 0) n /= i; } } if(n &gt; 1) res = res / n * (n - 1); return res;} Code（线性筛）： Complexity：$O(n)$ 123456789101112131415161718192021int phi[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; phi[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ phi[i * pList[j]] = phi[i] * pList[j]; break; } else phi[i * pList[j]] = phi[i] * (pList[j] - 1); } }} 莫比乌斯函数 Möbius functionDefinition：$\\mu(n)=\\begin{cases}1&amp;n=1\\0&amp;\\exists d&gt;1:d^2\\mid n\\(-1)^{k}&amp;n=p_1p_2\\cdots p_k\\end{cases}$ Properties： $\\sum\\limits_{d\\mid n}\\mu(d)=\\begin{cases}1,&amp;n=1\\0,&amp;n&gt;1\\end{cases}=\\epsilon(n)$. 证明：设 $n=\\prod\\limits_{i=1}^k{p_i}^{r_i}$，则 $\\sum\\limits_{d\\mid n}\\mu(d)=\\sum\\limits_{i=0}^k\\binom{k}{i}(-1)^i=(1+(-1))^k=\\begin{cases}1,&amp;n=1\\0,&amp;n&gt;1\\end{cases}$. 推论：$[\\gcd(i,j)=1]\\iff\\sum\\limits_{d\\mid\\gcd(i,j)}\\mu(d)$ $\\sum\\limits_{d\\mid n}\\frac{\\mu(d)}{d}=\\frac{\\varphi(n)}{n}$. 积性：若 $(a,b)=1$，则 $\\mu(a\\times b)=\\mu(a)\\times\\mu(b)$.（由定义易证） Code（线性筛）： Complexity：$O(n)$ 123456789101112131415161718192021int mu[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; mu[i] = -1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } }} 狄利克雷卷积 Dirichlet ConvolutionDefinition：两个数论函数 $f,g$ 的 $\\textbf{Dirichlet}$ 卷积为：$$(fg)(n)=\\sum_{d\\mid n}f(d)g\\left(\\frac{n}{d}\\right)$$或$$(fg)(n)=\\sum_{ab=n}f(a)g(b)$$ Properties： 满足交换律：$$fg=gf$$易证。 满足结合律：$$(fg)h=f(gh)$$从外往内计算就容易知道，多个函数的 $\\textbf{Dirichlet}$ 卷积就是遍历自变量乘积为 $n$ 的所有可能的函数值相乘的和。 满足分配律：$$(f+g)h=fh+g*h$$易证。 $\\epsilon(n)$ 是 $\\textbf{Dirichlet}$ 卷积的单位元，即任何函数卷 $\\epsilon(n)$ 均为它本身。 积性函数的 $\\textbf{Dirichlet}$ 卷积仍为积性函数。 证明：令 $h=f*g$。设 $(n,m)=1$，则 $h(n)\\times h(m)=\\sum\\limits_{d\\mid n}f(d)g\\left(\\frac{n}{d}\\right)\\times\\sum\\limits_{k\\mid m}f(k)g\\left(\\frac{m}{k}\\right)$，考虑前者的第 $i$ 项和后者的第 $j$ 项相乘得出的项：$f(d_i)g\\left(\\frac{n}{d_i}\\right)\\times f(k_j)g\\left(\\frac{m}{k_j}\\right)=f(d_ik_j)g\\left(\\frac{nm}{d_ik_j}\\right)$，当 $d_i$ 遍历所有 $n$ 的因子、$k_j$ 遍历所有 $m$ 的因子时，由于 $n,m$ 互质，$d_ik_j$ 遍历了所有 $nm$ 的因子。故 $h(n)\\times h(m)=\\sum\\limits_{d\\mid nm}f(d)g\\left(\\frac{nm}{d}\\right)=h(n\\times m)$. 逆元：对于 $f(1)\\neq0$ 的函数 $f(n)$，$\\exists,g(n)$ 使得 $f(n)*g(n)=\\epsilon(n)$. 事实上，有：$$g(n)=\\frac{1}{f(n)}\\left([n=1]-\\sum_{d\\mid n,d&gt;1}f(d)g\\left(\\frac{n}{d}\\right)\\right)$$或：$$g(n)=\\begin{cases}\\frac{1}{f(n)}&amp;n=1\\-\\frac{1}{f(n)}\\sum\\limits_{d\\mid n,d&gt;1}f(d)g\\left(\\frac{n}{d}\\right)&amp;n&gt;1\\end{cases}$$注意这是一个递归定义。 注意：积性函数必有逆（因为积性函数一定有 $f(1)=1\\neq0$），且逆元也是积性函数。 Examples：$$\\begin{align}\\epsilon=\\mu1&amp;\\iff\\epsilon(n)=\\sum_{d\\mid n}\\mu(d)\\d=11&amp;\\iff d(n)=\\sum_{d\\mid n}1\\\\sigma=\\text{id}1&amp;\\iff\\sigma(n)=\\sum_{d\\mid n}d\\\\varphi=\\mu\\text{id}&amp;\\iff\\varphi(n)=\\sum_{d\\mid n}\\mu(d)\\frac{n}{d}=\\sum_{d\\mid n}d\\cdot\\mu\\left(\\frac{n}{d}\\right)\\\\text{id}=\\varphi*1&amp;\\iff \\text{id}(n)=n=\\sum_{d\\mid n}\\varphi(d)\\end{align}$$ 其他常用性质 Properties除上述卷积的例子以外，其他有关积性函数的常用性质。$$\\begin{align}d(i\\cdot j)=\\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x,y)=1]\\end{align}$$ 莫比乌斯反演 Möbius Inversion$$f(n)=\\sum_{d\\mid n}g(d)\\iff g(n)=\\sum_{d\\mid n}\\mu(d)f\\left(\\frac{n}{d}\\right)$$ 或写成 $\\textbf{Dirichlet}$ 卷积形式：$$f=g1\\iff g=f\\mu$$ Proof：运用卷积，因为 $\\mu(n)$ 是 $1(n)$ 的逆元，即 $\\mu1=\\epsilon$，所以有：$$f=g1\\iff f\\mu=g1\\mu\\iff f\\mu=g$$ 常用技巧#1：数论分块假设我们要求含有 $\\left\\lfloor\\frac{n}{d}\\right\\rfloor$ 的和式（例如 $\\sum\\limits_{d=1}^n\\left\\lfloor\\frac{n}{d}\\right\\rfloor$），发现其中有很多项值其实是相同的。例如：$\\left\\lfloor\\frac{60}{21}\\right\\rfloor=\\left\\lfloor\\frac{60}{22}\\right\\rfloor=\\cdots=\\left\\lfloor\\frac{60}{30}\\right\\rfloor$，所以我们考虑能否把它们放在一起算。换句话说，我们要找到最大的 $r$，使 $\\left\\lfloor\\frac{n}{r}\\right\\rfloor=\\left\\lfloor\\frac{n}{l}\\right\\rfloor$. 可以证明：$r=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{l}\\right\\rfloor}\\right\\rfloor$. 首先，$\\left\\lfloor\\frac{n}{l}\\right\\rfloor=\\left\\lfloor\\frac{n}{r}\\right\\rfloor\\leqslant\\frac{n}{r}$，于是 $r\\leqslant\\frac{n}{\\left\\lfloor\\frac{n}{l}\\right\\rfloor}$，故 $r=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{l}\\right\\rfloor}\\right\\rfloor$. 其次，$r\\leqslant n$ 显然，需要证明 $r\\geqslant l$：$r=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{l}\\right\\rfloor}\\right\\rfloor\\geqslant\\left\\lfloor\\frac{n}{\\frac{n}{l}}\\right\\rfloor=\\left\\lfloor l\\right\\rfloor=l$ . 证毕。 于是乎，我们把 $[l,r]$ 视为一块，分块求和。 可以证明：块数不会超过 $2\\sqrt n$. 当 $i&lt;\\sqrt n$ 时，$\\left\\lfloor\\frac{n}{i}\\right\\rfloor$ 最多一个数一块，最多 $\\sqrt n$ 块；当 $i\\geqslant\\sqrt n$ 时，$\\left(\\frac{n}{2},n\\right]$ 是一块，$\\left(\\frac{n}{3}\\frac{n}{2}\\right]$ 是一块，……，$\\left(\\frac{n}{\\sqrt n+1},\\frac{n}{\\sqrt n}\\right]$ 是一块，最多 $\\sqrt n$ 块。证毕。 Complexity：$O(\\sqrt n)$ Code： 以 $\\sum\\limits_{i=1}^n\\left\\lfloor\\frac{k}{i}\\right\\rfloor\\cdots$ 为例： 12345for(long long l = 1, r; l &lt;= n; l = r + 1){ if(k / l == 0) r = n; else r = min(n, k / (k / l)); ... // calculate the ans} 常用技巧#2：提取公因数两个和式情形：$$\\sum_{i=1}^n\\sum_{d\\mid i}f(d,i)\\overset{i\\to di}{===}\\sum_{d=1}^n\\sum_{i=1}^\\left\\lfloor\\frac{n}{d}\\right\\rfloor f(d,di)$$即考虑 $d$ 对答案的贡献：凡是 $d$ 的倍数都会对答案有贡献。 三个和式情形：$$\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{d\\mid \\gcd(i,j)}f(d,i,j)\\overset{i\\to di,j\\to dj}{=====}\\sum_{d=1}^{\\min(n,m)}\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}f(d,di,dj)$$即考虑 $d$ 对答案的贡献：凡 $d$ 是 $i,j$ 的公因子就会对答案有贡献。 更多和式可类似拓展。 常用技巧#3：技巧2的逆过程$$\\sum\\limits_{p=1}^{n}\\sum\\limits_{d=1}^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}f(p,d)=\\sum\\limits_{1\\leqslant p\\cdot d\\leqslant n}f(p,d)\\overset{T=p\\cdot d}{===}\\sum\\limits_{T=1}^{n}\\sum\\limits_{p\\mid T}f\\left(p,\\frac{T}{p}\\right)$$ 常用技巧#4：一种预处理$$g(n)=\\sum_{d\\mid n}f(d,n)$$ 上式的预处理方式：枚举 $d$，将 $d\\mid n$ 的 $g(n)$ 加上贡献 $f(d,n)$. 复杂度是 $O(nH(n))=O(n\\lg n)$ 的。","link":"/blog-xcpc/2020/07/26/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"数论函数练习记录（一）","text":"参考资料：oi-wiki 莫比乌斯反演｜oi-wiki 筛法｜oi-wiki 欧拉函数｜blog｜blog [CQOI2007]余数求和题目链接 这道题主要是练习数论分块。$$G(n,k)=\\sum_{i=1}^nk\\bmod i=\\sum_{i=1}^nk-i\\cdot\\left\\lfloor\\frac{k}{i}\\right\\rfloor=nk-\\sum_{i=1}^ni\\cdot\\left\\lfloor\\frac{k}{i}\\right\\rfloor$$减号后面的值进行数论分块，每一块是常数 $\\left\\lfloor\\frac{k}{l}\\right\\rfloor$ 乘以一个等差数列求和 $l+\\cdots+r=\\frac{(l+r)(r-l+1)}{2}$。 123456789101112131415161718#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;long long n, k, ans;int main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); ans = 1ll * n * k; for(long long l = 1, r; l &lt;= n; l = r + 1){ if(k / l == 0) r = n; else r = min(n, k / (k / l)); ans -= (k / l) * (l + r) * (r - l + 1) / 2; } printf(&quot;%lld\\n&quot;, ans); return 0;} [POI2007]ZAP-Queries题目链接$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j)=k]&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\left[\\gcd\\left(\\frac{i}{k},\\frac{j}{k}\\right)=1\\right]&amp;&amp;\\gcd(i,j)=k\\iff\\gcd\\left(\\frac{i}{k},\\frac{j}{k}\\right)=1\\&amp;=\\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{k}\\right\\rfloor}[\\gcd(i,j)=1]&amp;&amp;i\\to ki,;j\\to kj\\&amp;=\\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{k}\\right\\rfloor}\\epsilon\\left(\\gcd(i,j)\\right)&amp;&amp;写作单位元函数\\&amp;=\\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{k}\\right\\rfloor}\\sum_{d\\mid\\gcd(i,j)}\\mu(d)&amp;&amp;\\epsilon=\\mu*1;并展开\\&amp;=\\sum_{d=1}^{\\min\\left(\\left\\lfloor\\frac{n}{k}\\right\\rfloor,\\left\\lfloor\\frac{m}{k}\\right\\rfloor\\right)}\\sum_{i=1}^{\\left\\lfloor\\frac{n}{kd}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{kd}\\right\\rfloor}\\mu(d)&amp;&amp;求和号换序并置;i\\to di,,j\\to dj\\&amp;=\\sum_{d=1}^{\\min\\left(\\left\\lfloor\\frac{n}{k}\\right\\rfloor,\\left\\lfloor\\frac{m}{k}\\right\\rfloor\\right)}\\mu(d)\\left\\lfloor\\frac{n}{kd}\\right\\rfloor\\left\\lfloor\\frac{m}{kd}\\right\\rfloor\\end{align}$$接下来进行数论分块，每一块是常数 $\\left\\lfloor\\frac{n}{kl}\\right\\rfloor\\left\\lfloor\\frac{m}{kl}\\right\\rfloor$ 乘上 $\\mu(l)+\\cdots+\\mu(r)$，前缀和预处理即可。 这里 $r$ 的计算：$\\left\\lfloor\\frac{n}{kl}\\right\\rfloor=\\left\\lfloor\\frac{n}{kr}\\right\\rfloor\\leqslant\\frac{n}{kr}\\implies r\\leqslant\\frac{\\frac{n}{k}}{\\left\\lfloor\\frac{n}{kl}\\right\\rfloor}\\implies r=\\left\\lfloor\\frac{\\frac{n}{k}}{\\left\\lfloor\\frac{n}{kl}\\right\\rfloor}\\right\\rfloor$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 50005;int k;int mu[N], pList[N], pID, muS[N];bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0) pList[++pID] = i, mu[i] = -1; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } } for(int i = 1; i &lt;= n; i++) muS[i] = muS[i-1] + mu[i];}LL calc(int n, int m){ LL res = 0; for(int l = 1, r; l &lt;= min(n / k, m / k); l = r + 1){ r = min((n / k) / ((n / k) / l), (m / k) / ((m / k) / l)); res += 1ll * (muS[r] - muS[l-1]) * (n / k / l) * (m / k / l); } return res;}int main(){ Euler(50000); int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ int a, b; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;k); printf(&quot;%lld\\n&quot;, calc(a, b)); } return 0;} [HAOI2011]Problem b题目链接 通过二维前缀和就可以把问题转换成上一道题。 不能乱开 long long，否则常数太大会 TLE。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 50005;int k;int mu[N], pList[N], pID, muS[N];bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0) pList[++pID] = i, mu[i] = -1; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } } for(int i = 1; i &lt;= n; i++) muS[i] = muS[i-1] + mu[i];}LL calc(int n, int m){ LL res = 0; for(int l = 1, r; l &lt;= min(n / k, m / k); l = r + 1){ r = min((n / k) / ((n / k) / l), (m / k) / ((m / k) / l)); res += 1ll * (muS[r] - muS[l-1]) * (n / k / l) * (m / k / l); } return res;}int main(){ Euler(50000); int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ int a, b, c, d; scanf(&quot;%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); printf(&quot;%lld\\n&quot;, calc(b, d) - calc(a-1, d) - calc(b, c-1) + calc(a-1, c-1)); } return 0;} [SPOJ5971]LCMSUM题目链接$$\\begin{align}\\sum_{i=1}^n\\text{lcm(i,n)}&amp;=\\sum_{i=1}^n\\frac{i\\cdot n}{\\gcd(i,n)}=n+\\sum_{i=1}^{n-1}\\frac{i\\cdot n}{\\gcd(i,n)}=n+\\sum_{i=1}^{n-1}\\frac{(n-i)\\cdot n}{\\gcd(n-i,n)}&amp;&amp;根据对称性做变换;i\\to n-i\\&amp;=n+\\frac{1}{2}\\sum_{i=1}^{n-1}\\frac{n^2}{\\gcd(i,n)}=\\frac{n}{2}+\\frac{1}{2}\\sum_{i=1}^n\\frac{n^2}{\\gcd(i,n)}&amp;&amp;根据;\\gcd(i,n)=\\gcd(n-i,n);进行合并\\&amp;=\\frac{n}{2}+\\frac{n^2}{2}\\sum_{d\\mid n}\\frac{\\varphi\\left(\\frac{n}{d}\\right)}{d}&amp;&amp;枚举;\\gcd(i,n);的值，乘上;\\gcd(i,n)=d;的个数，\\&amp;&amp;&amp;即;\\gcd(i/d,n/d)=1;的个数，即;\\varphi(n/d)\\&amp;=\\frac{n}{2}+\\frac{n^2}{2}\\sum_{d\\mid n}\\frac{d\\cdot\\varphi(d)}{n}=\\frac{n}{2}\\left(\\sum_{d\\mid n}d\\cdot\\varphi(d)+1\\right)&amp;&amp;根据对称性做变换;d\\to\\frac{n}{d}\\end{align}$$令 $g(n)=\\sum\\limits_{d\\mid n}d\\cdot\\varphi(d)$，如果我们可以预处理出 $g(n)$，那么我们就可以 $O(1)$ 回答了。我们这样预处理：枚举 $i$，将所有 $i\\mid n$ 的 $g(n)$ 加上贡献 $i\\cdot\\varphi(i)$，这样预处理的复杂度是调和级数，其阶为 $O(n\\lg n)$. 【这种预处理方式很重要！】 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 1000005;int T, n;int phi[N], pList[N], pID;bool notP[N];LL g[N];void Euler(int n){ notP[0] = notP[1] = 1; phi[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0) pList[++pID] = i, phi[i] = i - 1; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ phi[i * pList[j]] = phi[i] * pList[j]; break; } else phi[i * pList[j]] = phi[i] * (pList[j] - 1); } }}int main(){ Euler(1000000); for(int i = 1; i &lt;= 1000000; i++) for(int j = 1; i * j &lt;= 1000000; j++) g[i*j] += 1ll * i * phi[i]; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d&quot;, &amp;n); printf(&quot;%lld\\n&quot;, (g[n] + 1) * n / 2); } return 0;} [国家集训队]Crash的数字表格题目链接$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^m\\text{lcm}(i,j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\frac{i\\cdot j}{\\gcd(i,j)}\\&amp;=\\sum_{d=1}^{\\min(n,m)}\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}[\\gcd(i,j)=1]d\\cdot i\\cdot j&amp;&amp;考虑;d=\\gcd(i,j);的贡献，并置;i\\to di,,j\\to dj\\&amp;=\\sum_{d=1}^{\\min(n,m)}d\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}\\epsilon(\\gcd(i,j))\\cdot i\\cdot j&amp;&amp;写作单位元函数\\&amp;=\\sum_{d=1}^{\\min(n,m)}d\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}\\sum_{r\\mid\\gcd(i,j)}\\mu(r)\\cdot i\\cdot j&amp;&amp;\\epsilon=1*\\mu;并展开\\&amp;=\\sum_{d=1}^{\\min(n,m)}d\\sum_{r=1}^{\\min\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor,\\left\\lfloor\\frac{m}{d}\\right\\rfloor\\right)}\\sum_{i=1}^{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{dr}\\right\\rfloor}r^2\\mu(r)\\cdot i\\cdot j&amp;&amp;经典的求和号换序并置;i\\to ri,,j\\to rj\\&amp;=\\sum_{d=1}^{\\min(n,m)}d\\sum_{r=1}^{\\min\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor,\\left\\lfloor\\frac{m}{d}\\right\\rfloor\\right)}r^2\\mu(r)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}i\\sum_{j=1}^{\\left\\lfloor\\frac{m}{dr}\\right\\rfloor}j\\&amp;=\\sum_{d=1}^{\\min(n,m)}d\\sum_{r=1}^{\\min\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor,\\left\\lfloor\\frac{m}{d}\\right\\rfloor\\right)}r^2\\mu(r)\\cdot\\frac{\\left(\\left\\lfloor\\frac{n}{dr}\\right\\rfloor+1\\right)\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}{2}\\cdot\\frac{\\left(\\left\\lfloor\\frac{m}{dr}\\right\\rfloor+1\\right)\\left\\lfloor\\frac{m}{dr}\\right\\rfloor}{2}&amp;&amp;后两项是独立的，可求和\\end{align}$$我们设$$S(n,m)=\\sum_{r=1}^{\\min(n,m)}r^2\\mu(r)\\cdot\\frac{\\left(\\left\\lfloor\\frac{n}{r}\\right\\rfloor+1\\right)\\left\\lfloor\\frac{n}{r}\\right\\rfloor}{2}\\cdot\\frac{\\left(\\left\\lfloor\\frac{m}{r}\\right\\rfloor+1\\right)\\left\\lfloor\\frac{m}{r}\\right\\rfloor}{2}$$它是可以通过数论分块计算的，每一块是常数 $\\frac{\\left(\\left\\lfloor\\frac{n}{l}\\right\\rfloor+1\\right)\\left\\lfloor\\frac{n}{l}\\right\\rfloor}{2}\\cdot\\frac{\\left(\\left\\lfloor\\frac{m}{l}\\right\\rfloor+1\\right)\\left\\lfloor\\frac{m}{l}\\right\\rfloor}{2}$ 乘上 $l^2\\mu(l)+\\cdots+r^2\\mu(r)$，前缀和预处理即可。 那么原式可写作：$$\\sum_{d=1}^{\\min(n,m)}d\\cdot S\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor,\\left\\lfloor\\frac{m}{d}\\right\\rfloor\\right)$$而它又是一个可以数论分块计算的，每一块是常数 $S\\left(\\left\\lfloor\\frac{n}{l}\\right\\rfloor,\\left\\lfloor\\frac{m}{l}\\right\\rfloor\\right)$ 乘上 $l+\\cdots+r=\\frac{(l+r)(r-l+1)}{2}$. 所以这道题是数论分块的嵌套，复杂度为 $O(\\sqrt n\\cdot\\sqrt n)=O(n)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 10000005;const LL MOD = 20101009;int mu[N], pList[N], pID;bool notP[N];LL sum[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0) pList[++pID] = i, mu[i] = -1; for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } } for(int i = 1; i &lt;= n; i++) sum[i] = (sum[i-1] + 1ll * i * i % MOD * mu[i] % MOD) % MOD;}LL S(int n, int m){ LL res = 0; if(n &gt; m) swap(n, m); for(int l = 1, r; l &lt;= n; l = r + 1){ r = min(n / (n / l), m / (m / l)); res += 1ll * (1 + n / l) * (n / l) % MOD * (1 + m / l) % MOD * (m / l) % MOD * ((sum[r] - sum[l-1]) % MOD + MOD) % MOD * 15075757 % MOD; res %= MOD; } return res;}int n, m;LL ans;int main(){ Euler(10000000); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n &gt; m) swap(n, m); for(int dl = 1, dr; dl &lt;= n; dl = dr + 1){ dr = min(n / (n / dl), m / (m / dl)); ans += (1ll * (dl + dr) * (dr - dl + 1) % MOD * 10050505 % MOD) * S(n / dl, m / dl) % MOD; ans %= MOD; } printf(&quot;%lld\\n&quot;, ans); return 0;} 其实这道题还能继续优化：先鸽一下（雾 [luoguP2398]GCD SUM题目链接 解法一：和上一道题差不多。$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^n\\gcd(i,j)&amp;=\\sum_{d=1}^n\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}d[\\gcd(i,j)=1]&amp;&amp;考虑;d=\\gcd(i,j);的贡献，并置;i\\to di,,j\\to dj\\&amp;=\\sum_{d=1}^nd\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{r\\mid \\gcd(i,j)}\\mu(r)&amp;&amp;写作单位元函数并展开\\&amp;=\\sum_{d=1}^nd\\sum_{r=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{i=1}^{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}\\mu(r)&amp;&amp;求和号换序并置;i\\to ri,,j\\to rj\\&amp;=\\sum_{d=1}^nd\\sum_{r=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}^2\\mu(r)\\end{align}$$数论分块嵌套。 复杂度：$O(n)$ 解法二：$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^n\\gcd(i,j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^n\\varphi(\\gcd(i,j))1(\\gcd(i,j))&amp;&amp;由;\\text{id}=\\varphi1\\&amp;=\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{d\\mid\\gcd(i,j)}\\varphi(d)&amp;&amp;把卷积打开\\&amp;=\\sum_{d=1}^n\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\varphi(d)&amp;&amp;求和号换序并置;i\\to di,,j\\to dj\\&amp;=\\sum_{d=1}^n{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}^2\\varphi(d)\\end{align}$$数论分块。 复杂度：$O(\\sqrt n)$ （不算线性筛） 注：其实解法一继续推导可得解法二的表达式，不过推导的下一步不是很显然（要卷回去）：$$\\begin{align}\\sum_{d=1}^nd\\sum_{r=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}{\\left\\lfloor\\frac{n}{dr}\\right\\rfloor}^2\\mu(r)&amp;=\\sum_{d=1}^nd\\sum_{r=1}^{n}[d\\mid r]{\\left\\lfloor\\frac{n}{r}\\right\\rfloor}^2\\mu\\left(\\frac{r}{d}\\right)&amp;&amp;置;r\\to\\frac{r}{d}\\&amp;=\\sum_{r=1}^n{\\left\\lfloor\\frac{n}{r}\\right\\rfloor}^2\\sum_{d\\mid r}\\text{id}(d)\\cdot\\mu\\left(\\frac{r}{d}\\right)&amp;&amp;求和号换序\\&amp;=\\sum_{r=1}^n{\\left\\lfloor\\frac{n}{r}\\right\\rfloor}^2\\varphi(r)&amp;&amp;由;\\text{id}*\\mu=\\varphi\\end{align}$$这个博客讲的也是这个，并给这种方法起了个名字叫做欧拉反演，哈哈。 解法一： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int mu[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; mu[i] = -1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } }}int n, muS[N];int main(){ Euler(100000); for(int i = 1; i &lt;= 100000; i++) muS[i] = muS[i-1] + mu[i]; scanf(&quot;%d&quot;, &amp;n); long long ans = 0; for(int dl = 1, dr; dl &lt;= n; dl = dr + 1){ dr = n / (n / dl); long long res = 0; for(int l = 1, r; l &lt;= n / dl; l = r + 1){ r = (n / dl) / (n / dl / l); res += 1ll * (muS[r] - muS[l-1]) * (n / dl / l) * (n / dl / l); } ans += 1ll * (dl + dr) * (dr - dl + 1) / 2 * res; } printf(&quot;%lld\\n&quot;, ans); return 0;} 解法二： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int phi[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; phi[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ phi[i * pList[j]] = phi[i] * pList[j]; break; } else phi[i * pList[j]] = phi[i] * (pList[j] - 1); } }}int n;long long phiS[N];int main(){ Euler(100000); for(int i = 1; i &lt;= 100000; i++) phiS[i] = phiS[i-1] + phi[i]; scanf(&quot;%d&quot;, &amp;n); long long ans = 0; for(int l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); ans += 1ll * (phiS[r] - phiS[l-1]) * (n / l) * (n / l); } printf(&quot;%lld\\n&quot;, ans); return 0;} [NOI2010]能量采集题目链接 题目要求的就是$$\\sum_{i=1}^n\\sum_{j=1}^m\\left(2\\gcd(i,j)-1\\right)=2\\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)-nm$$和上一题一样了。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int phi[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; phi[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ phi[i * pList[j]] = phi[i] * pList[j]; break; } else phi[i * pList[j]] = phi[i] * (pList[j] - 1); } }}int n, m;long long phiS[N];int main(){ Euler(100000); for(int i = 1; i &lt;= 100000; i++) phiS[i] = phiS[i-1] + phi[i]; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int l = 1, r; l &lt;= n; l = r + 1){ r = min(n / (n / l), m / (m / l)); ans += 1ll * (phiS[r] - phiS[l-1]) * (n / l) * (m / l); } printf(&quot;%lld\\n&quot;, 2 * ans - 1ll * n * m); return 0;} [SDOI2015]约数个数和题目链接 引理：$$d(i\\cdot j)=\\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x,y)=1]$$证明：约数个数公式：$d(n)=d\\left(\\prod\\limits_{i=1}^k{p_i}^{r_i}\\right)=\\prod\\limits_{i=1}^k(r_i+1)$。考虑 $ij$ 的一个质因子 $p$，设 $i=i’\\cdot{p}^{r_i}$ ，$j=j’\\cdot{p}^{r_j}$，则 $p$ 对答案有 $r_i+r_j+1$ 的贡献。又考虑右边的式子，由于 $\\gcd(x,y)=1$ 的约束，$p$ 只能从 $i$ 或 $j$ 其中一边取出，或者不取出，贡献仍是 $r_i+r_j+1$。证毕。 于是：$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^md(i\\cdot j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x,y)=1]&amp;&amp;由引理\\&amp;=\\sum_{x=1}^n\\sum_{y=1}^m\\sum_{i=1}^{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{y}\\right\\rfloor}\\epsilon(\\gcd(x,y))&amp;&amp;求和号换序并置;i\\to xi,,j\\to yj\\&amp;=\\sum_{x=1}^n\\sum_{y=1}^m{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}{\\left\\lfloor\\frac{m}{y}\\right\\rfloor}\\sum_{d\\mid\\gcd(x,y)}\\mu(d)&amp;&amp;\\epsilon=\\mu1;并展开，i,和,j,的和式计算出来\\&amp;=\\sum_{d=1}^{\\min(n,m)}\\sum_{x=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}{\\left\\lfloor\\frac{n}{dx}\\right\\rfloor}{\\left\\lfloor\\frac{m}{dy}\\right\\rfloor}\\mu(d)&amp;&amp;求和号换序并置;x\\to dx,,y\\to dy\\&amp;=\\sum_{d=1}^{\\min(n,m)}\\mu(d)\\sum_{x=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}{\\left\\lfloor\\frac{n}{dx}\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}{\\left\\lfloor\\frac{m}{dy}\\right\\rfloor}\\&amp;=\\sum_{d=1}^{\\min(n,m)}\\mu(d)\\cdot S\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\right)\\cdot S\\left(\\left\\lfloor\\frac{m}{d}\\right\\rfloor\\right)&amp;&amp;设,S(i)=\\sum_{r=1}^i\\left\\lfloor\\frac{i}{r}\\right\\rfloor\\end{align}$$$S(1…n)$ 可以通过*数论分块 $O(n\\sqrt n)$ 地预处理出来，随后上式可通过数论分块 $O(\\sqrt n)$ 地回答。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 50005;int mu[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; mu[i] = -1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } }}int T, n, m, muS[N];long long S[N];int main(){ Euler(50000); for(int i = 1; i &lt;= 50000; i++) muS[i] = muS[i-1] + mu[i]; for(int i = 1; i &lt;= 50000; i++){ for(int l = 1, r; l &lt;= i; l = r + 1){ r = i / (i / l); S[i] += (r - l + 1) * (i / l); } } for(scanf(&quot;%d&quot;, &amp;T); T; T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int dl = 1, dr; dl &lt;= n; dl = dr + 1){ dr = min(n / (n / dl), m / (m / dl)); ans += 1ll * (muS[dr] - muS[dl-1]) * S[n / dl] * S[m / dl]; } printf(&quot;%lld\\n&quot;, ans); } return 0;} [luoguP2257]YY的GCD题目链接$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j)=\\text{prime}]&amp;=\\sum_{p=1}^{\\min(n,m)}\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j)=p]\\quad(p\\in\\text{prime})&amp;&amp;枚举质数;p\\&amp;=\\sum_{p=1}^{\\min(n,m)}\\sum_{d=1}^{\\min\\left(\\left\\lfloor\\frac{n}{p}\\right\\rfloor,\\left\\lfloor\\frac{m}{p}\\right\\rfloor\\right)}\\mu(d)\\left\\lfloor\\frac{n}{pd}\\right\\rfloor\\left\\lfloor\\frac{m}{pd}\\right\\rfloor\\quad(p\\in\\text{prime})&amp;&amp;和之前做过的题目一样的推导\\&amp;=\\sum_{T=1}^{\\min(n,m)}\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\sum_{p\\mid T}\\mu\\left(\\frac{T}{p}\\right)\\quad(p\\in\\text{prime})&amp;&amp;置;T=pd\\\\end{align}$$ 最后一步的代换非常重要！详细逻辑如下：$$\\sum\\limits_{p=1}^{\\min(n,m)}\\sum\\limits_{d=1}^{\\min\\left(\\left\\lfloor\\frac{n}{p}\\right\\rfloor,\\left\\lfloor\\frac{m}{p}\\right\\rfloor\\right)}f(p,d)=\\sum\\limits_{1\\leqslant p\\cdot d\\leqslant\\min(n,m)}f(p,d)\\overset{T=p\\cdot d}{===}\\sum\\limits_{T=1}^{\\min(n,m)}\\sum\\limits_{p\\mid T}f\\left(p,\\frac{T}{p}\\right)$$然后令 $g(T)=\\sum\\limits_{p\\mid T}{\\mu\\left(\\frac{T}{p}\\right)}\\quad(p\\in\\text{prime})$，这是可以预处理的，即枚举质数 $p$，将 $p\\mid n$ 的 $g(n)$ 加上贡献 $\\mu\\left(\\frac{n}{p}\\right)$，复杂度是 $O(n\\cdot H(n))\\sim O(n\\lg n)$ 随后数论分块，每一块是常数 $\\left\\lfloor\\frac{n}{l}\\right\\rfloor\\left\\lfloor\\frac{m}{l}\\right\\rfloor$ 乘上 $g(l)+\\cdots+g(r)$，前缀和预处理即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 10000005;int mu[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; mu[i] = -1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; break; } else mu[i * pList[j]] = -mu[i]; } }}long long g[N];int main(){ Euler(10000000); for(int i = 1; i &lt;= pID; i++) for(int j = pList[i]; j &lt;= 10000000; j += pList[i]) g[j] += mu[j / pList[i]]; for(int i = 1; i &lt;= 10000000; i++) g[i] += g[i-1]; int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int l = 1, r; l &lt;= n; l = r + 1){ r = min(n / (n / l), m / (m / l)); ans += 1ll * (g[r] - g[l-1]) * (n / l) * (m / l); } printf(&quot;%lld\\n&quot;, ans); } return 0;} [luoguP2586]GCD题目链接 求的东西和上一道题基本一样，但是没有多组数据，时限加紧。 注意上一道题为了 $O(\\sqrt n)$ 地回答而进行了 $O(n\\lg n)$ 的预处理，这个预处理在这道题里会超时。但是这道题只需要 $O(n)$ 回答就行了。 重新推一波式子：$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j)=\\text{prime}]&amp;=\\sum_{p=1}^{n}\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j)=p]\\quad(p\\in\\text{prime})&amp;&amp;枚举质数;p\\&amp;=\\sum_{p=1}^n\\sum_{i=1}^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}[\\gcd(i,j)=1]\\quad(p\\in\\text{prime})&amp;&amp;置;i\\to pi,,j\\to pj\\&amp;=\\sum_{p=1}^n\\left(2\\sum_{i=1}^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}\\sum_{j=1}^{i}[\\gcd(i,j)=1]-1\\right)\\quad(p\\in\\text{prime})&amp;&amp;由 \\gcd 的对称性\\&amp;=\\sum_{p=1}^n\\left(2\\sum_{i=1}^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}\\varphi(i)-1\\right)\\quad(p\\in\\text{prime})&amp;&amp;由;\\varphi(n);的定义式\\end{align}$$预处理 $\\varphi(n)$ 的前缀和，就可以 $O(n)$ 解决了。 上面的推导中最妙的一点是用上了 $\\varphi(n)=\\sum\\limits_{i=1}^n[\\gcd(i,n)=1]$ 这个定义式。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 10000005;int phi[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; phi[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ phi[i * pList[j]] = phi[i] * pList[j]; break; } else phi[i * pList[j]] = phi[i] * (pList[j] - 1); } }}long long phiS[N];int main(){ Euler(10000000); for(int i = 1; i &lt;= 10000000; i++) phiS[i] = phiS[i-1] + phi[i]; int n; scanf(&quot;%d&quot;, &amp;n); long long ans = 0; for(int i = 1; pList[i] &lt;= n; i++) ans += 2 * phiS[n / pList[i]] - 1; printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/07/26/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"数论函数练习记录（二）","text":"参考资料：oi-wiki 杜教筛｜blog｜blog [luoguP3768]简单的数学题题目链接$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^nij\\gcd(i,j)&amp;=\\sum_{d=1}^n\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}ijd^3[\\gcd(i,j)=1]&amp;&amp;枚举;d=\\gcd(i,j)\\&amp;=\\sum_{d=1}^n\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}ijd^3\\sum_{r\\mid \\gcd(i,j)}\\mu(r)&amp;&amp;\\epsilon=\\mu1\\&amp;=\\sum_{d=1}^nd^3\\sum_{r=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{i=1}^{\\left\\lfloor\\frac{n}{rd}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{rd}\\right\\rfloor}ijr^2\\mu(r)&amp;&amp;求和号换序\\&amp;=\\sum_{d=1}^nd^3\\sum_{r=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}r^2\\mu(r)\\left(\\frac{\\left\\lfloor\\frac{n}{rd}\\right\\rfloor\\left(\\left\\lfloor\\frac{n}{rd}\\right\\rfloor+1\\right)}{2}\\right)^2\\&amp;=\\sum_{T=1}^n\\sum_{d\\mid T}d^3\\frac{T^2}{d^2}\\mu\\left(\\frac{T}{d}\\right)\\left(\\frac{\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor+1\\right)}{2}\\right)^2&amp;&amp;令;T=rd\\&amp;=\\sum_{T=1}^n\\left(\\frac{\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor+1\\right)}{2}\\right)^2T^2\\sum_{d\\mid T}d\\mu\\left(\\frac{T}{d}\\right)\\&amp;=\\sum_{T=1}^n\\left(\\frac{\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor+1\\right)}{2}\\right)^2T^2\\varphi(T)&amp;&amp;\\mu\\text{id}=\\varphi\\end{align}$$ 于是问题转化为求出 $f(n)=n^2\\varphi(n)$ 的前缀和，如此便可以数论分块了。 设 $g(n)=n^2$，那么 $(f*g)(n)=\\sum\\limits_{d\\mid n}d^2\\varphi(d)\\frac{n^2}{d^2}=n^2\\sum\\limits_{d\\mid n}\\varphi(d)=n^3$，根据杜教筛理论，有：$$S_f(n)=\\sum_{i=1}^ni^3-\\sum_{i=2}^ni^2S_f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)$$即可计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 5000005;LL p, inv2, inv6;int phi[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; phi[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; phi[i] = (i - 1) % p; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ phi[i * pList[j]] = 1ll * phi[i] * pList[j] % p; break; } else phi[i * pList[j]] = 1ll * phi[i] * (pList[j] - 1) % p; } }}inline LL fpow(LL bs, LL idx, LL mod){ LL res = 1; bs %= mod; while(idx){ if(idx &amp; 1) (res *= bs) %= mod; (bs *= bs) %= mod; idx &gt;&gt;= 1; } return res;}unordered_map&lt;LL, LL&gt; s;LL pres[N];LL apiadu(LL n){ if(n &lt;= 5000000) return pres[n]; if(s.find(n) != s.end()) return s[n]; LL res = fpow(n%p*(n+1)%p*inv2%p, 2, p); for(LL l = 2, r; l &lt;= n; l = r + 1){ r = n / (n / l); LL rs = r%p*(r+1)%p*(2*r%p+1)%p*inv6%p; LL ls = (l-1)%p*l%p*(2*l%p-1)%p*inv6%p; res -= (rs - ls) * apiadu(n / l) % p; ((res %= p) += p) %= p; } return s[n] = res;}LL n;inline LL solve(){ LL res = 0; for(LL l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); res += fpow((n/l)%p*(n/l+1)%p, 2, p) * (apiadu(r) - apiadu(l-1)) % p; ((res %= p) += p) %= p; } return res * fpow(4, p-2, p) % p;}int main(){ read(p, n); inv2 = fpow(2, p-2, p), inv6 = fpow(6, p-2, p); Euler(5000000); for(int i = 1; i &lt;= 5000000; i++) pres[i] = (pres[i-1] + 1ll * i * i % p * phi[i] % p) % p; printf(&quot;%lld\\n&quot;, solve()); return 0;} [51nod 1220]约数之和题目链接$$\\begin{align}\\sum_{i=1}^n\\sum_{j=1}^n\\sigma(ij)&amp;=\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{a\\mid i}\\sum_{b\\mid j}[\\gcd(a,b)=1]\\frac{aj}{b}\\&amp;=\\sum_{a=1}^n\\sum_{b=1}^n\\sum_{i=1}^{\\left\\lfloor\\frac{n}{a}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{b}\\right\\rfloor}[\\gcd(a,b)=1]aj\\&amp;=\\sum_{a=1}^n\\sum_{b=1}^n\\sum_{i=1}^{\\left\\lfloor\\frac{n}{a}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{b}\\right\\rfloor}aj\\sum_{d\\mid\\gcd(a,b)}\\mu(d)\\&amp;=\\sum_{a=1}^n\\sum_{b=1}^n\\sum_{d\\mid\\gcd(a,b)}a\\mu(d)\\left\\lfloor\\frac{n}{a}\\right\\rfloor\\frac{\\left\\lfloor\\frac{n}{b}\\right\\rfloor\\left(\\left\\lfloor\\frac{n}{b}\\right\\rfloor+1\\right)}{2}\\&amp;=\\sum_{d=1}^nd\\mu(d)\\left(\\sum_{a=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}a\\left\\lfloor\\frac{n}{ad}\\right\\rfloor\\right)\\left(\\sum_{b=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\frac{\\left\\lfloor\\frac{n}{bd}\\right\\rfloor\\left(\\left\\lfloor\\frac{n}{bd}\\right\\rfloor+1\\right)}{2}\\right)\\end{align}$$注意到：$$\\sum\\limits_{i=1}^ni\\left\\lfloor\\frac{n}{i}\\right\\rfloor=\\sum\\limits_{i=1}^n\\sigma(i)$$ $$\\sum\\limits_{i=1}^n\\frac{\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor+1\\right)}{2}=\\sum_{i=1}^n\\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}j=\\sum_{j=1}^{n}\\sum_{i=1}^{\\left\\lfloor\\frac{n}{j}\\right\\rfloor}j=\\sum_{j=1}^nj\\left\\lfloor\\frac{n}{j}\\right\\rfloor=\\sum_{j=1}^n\\sigma(j)$$ 所以，$$原式=\\sum_{d=1}^nd\\mu(d)\\left(\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sigma(i)\\right)^2$$杜教筛筛出 $d\\mu(d)$ 的前缀和以及 $\\sigma(i)$ 的前缀和之后，就可以数论分块了。 $d\\mu(d)$ 前缀和：设 $f(n)=n\\mu(n),;g(n)=\\text{id}(n)$，则 $(fg)(n)=\\sum\\limits_{d=1}^nd\\mu(d)\\frac{n}{d}=n\\cdot(\\mu1)(n)=n\\cdot\\epsilon(n)=\\epsilon(n)$，根据杜教筛理论，有：$$S_f(n)=\\sum_{i=1}^n\\epsilon(i)-\\sum_{i=2}^n\\text{id}(i)S_f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)=1-\\sum_{i=2}^niS_f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)$$$\\sigma(i)$ 前缀和：设 $f(n)=\\sigma(n);,g(n)=\\mu(n)$，则 $(f*g)(n)=\\text{id}(n)$，根据杜教筛理论，有：$$S_\\sigma(n)=\\sum_{i=1}^n\\text{id}(i)-\\sum_{i=2}^n\\mu(i)S_\\sigma\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)$$所以筛出莫比乌斯函数的前缀和就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 1000005;const LL MOD = 1e9+7;inline LL fpow(LL bs, LL idx){ LL res = 1; bs %= MOD; while(idx){ if(idx &amp; 1) (res *= bs) %= MOD; (bs *= bs) %= MOD; idx &gt;&gt;= 1; } return res;}int mu[N], sigma[N], g[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; mu[1] = 1, sigma[1] = 1, g[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; mu[i] = -1, sigma[i] = 1 + i, g[i] = 1 + i; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ mu[i * pList[j]] = 0; sigma[i * pList[j]] = sigma[i] / g[i] * (g[i] * pList[j] + 1); g[i * pList[j]] = (g[i] * pList[j] + 1); break; } else{ mu[i * pList[j]] = -mu[i]; sigma[i * pList[j]] = sigma[i] * (1 + pList[j]); g[i * pList[j]] = 1 + pList[j]; } } }}unordered_map&lt;LL, LL&gt; muS, sigmaS, fS;LL pre_muS[N], pre_sigmaS[N], pre_fS[N];LL apiadu_mu(LL n){ if(n &lt;= 1000000) return pre_muS[n]; if(muS.find(n) != muS.end()) return muS[n]; LL res = 1; for(LL l = 2, r; l &lt;= n; l = r + 1){ r = n / (n / l); res -= apiadu_mu(n / l) * (r - l + 1) % MOD; ((res %= MOD) += MOD) %= MOD; } return muS[n] = res;}LL apiadu_sigma(LL n){ if(n &lt;= 1000000) return pre_sigmaS[n]; if(sigmaS.find(n) != sigmaS.end()) return sigmaS[n]; LL res = n * (n + 1) / 2 % MOD; for(LL l = 2, r; l &lt;= n; l = r + 1){ r = n / (n / l); res -= (apiadu_mu(r) - apiadu_mu(l-1)) * apiadu_sigma(n / l) % MOD; ((res %= MOD) += MOD) %= MOD; } return sigmaS[n] = res;}LL apiadu_f(LL n){ if(n &lt;= 1000000) return pre_fS[n]; if(fS.find(n) != fS.end()) return fS[n]; LL res = 1; for(LL l = 2, r; l &lt;= n; l = r + 1){ r = n / (n / l); res -= (l + r) * (r - l + 1) / 2 % MOD * apiadu_f(n / l) % MOD; ((res %= MOD) += MOD) %= MOD; } return fS[n] = res;}int main(){ Euler(1000000); for(int i = 1; i &lt;= 1000000; i++){ pre_muS[i] = pre_muS[i-1] + mu[i]; pre_sigmaS[i] = (pre_sigmaS[i-1] + sigma[i]) % MOD; pre_fS[i] = ((pre_fS[i-1] + i * mu[i]) % MOD + MOD) % MOD; } int n; scanf(&quot;%d&quot;, &amp;n); LL res = 0; for(LL l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); res += (apiadu_f(r) - apiadu_f(l-1) + MOD) % MOD * apiadu_sigma(n / l) % MOD * apiadu_sigma(n / l) % MOD; ((res %= MOD) += MOD) %= MOD; } printf(&quot;%lld\\n&quot;, res); return 0;} [hdu6706] huntian oy题目链接$$\\begin{align}f(n,a,b)&amp;=\\sum_{i=1}^n\\sum_{j=1}^i\\gcd(i^a-j^a,i^b-j^b)[\\gcd(i,j)=1]\\&amp;=\\sum_{i=1}^n\\sum_{j=1}^i(i-j)[\\gcd(i,j)=1]&amp;&amp;\\gcd(i,j)=1\\implies \\gcd(i^a-j^a,i^b-j^b)=i-j\\&amp;=\\sum_{i=1}^ni\\sum_{j=1}^i[\\gcd(i,j)=1]-\\sum_{i=1}^n\\sum_{j=1}^ij[\\gcd(i,j)=1]\\&amp;=\\sum_{i=1}^ni\\varphi(i)-\\sum_{i=1}^n\\frac{i\\varphi(i)+[i=1]}{2}&amp;&amp;使用定义;\\varphi(n)=\\sum_{i=1}^n[\\gcd(i,n)=1]\\&amp;&amp;&amp;和定理：小于等于,n,和,n,互质的数之和为,\\frac{n\\varphi(n)+[n=1]}{2}\\&amp;=\\frac{\\sum\\limits_{i=1}^ni\\varphi(i)-1}{2}\\end{align}$$设 $f(n)=n\\varphi(n)$，$g(n)=n$，则 $(f*g)(n)=\\sum\\limits_{d\\mid n}d\\varphi(d)\\frac{n}{d}=n\\sum\\limits_{d\\mid n}\\varphi(d)=n^2$，根据杜教筛理论：$$S_f(n)=\\sum_{i=1}^ni^2-\\sum_{i=2}^niS\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 1000005;const LL MOD = 1e9+7;const LL inv2 = 500000004;const LL inv3 = 333333336;const LL inv6 = 166666668;int phi[N], pList[N], pID;bool notP[N];void Euler(int n){ notP[0] = notP[1] = 1; phi[1] = 1; for(int i = 1; i &lt;= n; i++){ if(notP[i] == 0){ pList[++pID] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= pID; j++){ if(1ll * i * pList[j] &gt; n) break; notP[i * pList[j]] = 1; if(i % pList[j] == 0){ phi[i * pList[j]] = phi[i] * pList[j]; break; } else phi[i * pList[j]] = phi[i] * (pList[j] - 1); } }}unordered_map&lt;LL, LL&gt; fS;LL preS[N];LL apiadu_f(LL n){ if(n &lt;= 1000000) return preS[n]; if(fS.find(n) != fS.end()) return fS[n]; LL res = n % MOD * (n + 1) % MOD * (2 * n % MOD + 1) % MOD * inv6 % MOD; for(LL l = 2, r; l &lt;= n; l = r + 1){ r = n / (n / l); res -= (l + r) % MOD * (r - l + 1) % MOD * inv2 % MOD * apiadu_f(n / l) % MOD; ((res %= MOD) += MOD) %= MOD; } return fS[n] = res;}int main(){ Euler(1000000); for(int i = 1; i &lt;= 1000000; i++) preS[i] = (preS[i-1] + 1ll * phi[i] * i % MOD) % MOD; int T; for(scanf(&quot;%d&quot;, &amp;T); T; T--){ LL n, res; scanf(&quot;%lld%*d%*d&quot;, &amp;n); res = (apiadu_f(n) - 1) % MOD * inv2 % MOD; ((res %= MOD) += MOD) %= MOD; printf(&quot;%lld\\n&quot;, res); } return 0;}","link":"/blog-xcpc/2020/09/21/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"树状数组倍增学习笔记","text":"Codeforces 上的教程：link 基本思想问题描述我们考虑一个问题： 给定某个序列，要求维护的操作有：单点修改，求前缀和，搜索某个前缀和（类似于在前缀和数组上求 lower_bound）。 这个事实上容易用线段树完成，但是由于树状数组具有空间更小、常数小、代码简单等优点，我们想用树状数组完成这个操作。 $O(\\lg^2n)$ 的实现单点修改和求前缀和都可以用树状数组完成，问题主要在于如何搜索某个前缀和。 由于前缀和这玩意儿具有单调性，一个简单的想法就是二分查找。代码如下： >folded123456789int search(int val){ int l = 1, r = n; while(l &lt; r){ int mid = (l + r) &gt;&gt; 1; if(sum(mid) &lt; val) l = mid + 1; else r = mid; } return l;} 二分是 $O(\\lg n)$ 的，在树状数组上求前缀和是 $O(\\lg n)$ 的，所以总复杂度是 $O(\\lg^2n)$ 的。 $O(\\lg n)$ 的实现——倍增思想倍增思想有很多重要的应用，例如 $ST$ 表、倍增求 lca 等，这里可以帮助我们在树状数组上完成 lower_bound 操作。 假设我们想要搜索前缀和为 $val$ 的地方，设定一个 pos 指针，它初始为 $0$，最终将指向最大的前缀和小于 $val$ 的位置；再设置一个变量 sum​，存储 pos​ 处的前缀和；设置倍增的长度 i，最初为 $\\lg n$（为了代码方便，一般取 $20$ 即可），在倍增的过程中不断减小至 $0$。每一个状态（pos，sum，i）表示我们现在考虑的是位置 pos+(1&lt;&lt;i) 的前缀和，这个前缀和的值是 sum+c[pos+(1&lt;&lt;i)]，如果它大于等于了 $val$，那么我们减小倍增的长度 i；否则，我们把 pos 提到 pos+(1&lt;&lt;i) 处。 我们用例子来更直观地说明【以下例子和图片均来源于 Codeforces 的教程】： 给定数组 a[]： 它的树状数组 c[] 长这样： 我们想搜索 $val=27$ 的位置，那么算法过程如下： 最后 pos 值为 $13$，是最大的前缀和小于 $27$ 的位置。所以我们的目标位置就是 pos+1. 代码如下： >folded1234567int search(int val){ int pos = 0, sum = 0; for(int i = 20; i &gt;= 0; i--) if(pos + (1&lt;&lt;i) &lt;= n &amp;&amp; sum + c[pos+(1&lt;&lt;i)] &lt; val) pos += (1&lt;&lt;i), sum += c[pos]; return pos + 1;} 进一步容易发现，只要我们维护的信息具有单调性，就可以用这个方法。 练习CF1354D Multiset题目链接 其实这道题是我学树状数组倍增的原因。 开一个值域树状数组，维护前缀个数，这玩意儿是单调增加的，所以查询第 $k$ 个数可以用上树状数组倍增。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x) const int N = 1000005;int n, q;int c[N];inline int lowbit(int x){ return x &amp; -x; }inline void add(int x, int val){ while(x &lt;= n){ c[x] += val; x += lowbit(x); }}inline int search(int val){ int pos = 0, sum = 0; for(int i = 20; i &gt;= 0; i--) if(pos + (1&lt;&lt;i) &lt;= n &amp;&amp; sum + c[pos+(1&lt;&lt;i)] &lt; val) pos += (1&lt;&lt;i), sum += c[pos]; return pos + 1;}int main(){ read(n, q); for(int i = 1; i &lt;= n; i++){ int x; read(x); add(x, 1); } while(q--){ int x; read(x); if(x &gt; 0) add(x, 1); else add(search(-x), -1); } int ans = search(1); if(ans == n + 1) puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;, ans); return 0;} CF992E Nastya and King-Shamans题目链接 由 $a_i=s_{i-1}$ 可以推出 $s_i=2s_{i-1}$，那么我们用树状数组维护前缀和，每次询问时从 $sum=0$ 开始查找第一个前缀和大于等于 $2sum$ 的位置，由于每次乘 $2$，所以最多查找 $\\lg 10^{14}$ 次。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);} typedef long long LL;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x) const int N = 200005;int n, q, a[N];LL c[N];inline int lowbit(int x){ return x &amp; -x; }inline void add(int x, LL val){ while(x &lt;= n){ c[x] += val; x += lowbit(x); }}inline LL sum(int x){ LL res = 0; while(x){ res += c[x]; x -= lowbit(x); } return res;}inline int search(LL val){ int pos = 0; LL sum = 0; for(int i = 20; i &gt;= 0; i--) if(pos + (1&lt;&lt;i) &lt;= n &amp;&amp; sum + c[pos + (1&lt;&lt;i)] &lt; val) pos += (1&lt;&lt;i), sum += c[pos]; return pos + 1;}int main(){ read(n, q); for(int i = 1; i &lt;= n; i++){ read(a[i]); add(i, a[i]); } while(q--){ int p, x; read(p, x); add(p, x - a[p]); a[p] = x; LL s = 0; while(1){ int pos = search(s &lt;&lt; 1); if(pos == n + 1){ puts(&quot;-1&quot;); break; } if(sum(pos) == sum(pos-1) &lt;&lt; 1){ printf(&quot;%d\\n&quot;, pos); break; } s = sum(pos); } } return 0;}","link":"/blog-xcpc/2020/05/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%80%8D%E5%A2%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"线性基学习笔记","text":"参考博客：1 2 3 4 基本思想可以类比线性代数中的向量空间学习。 从二进制的角度看待每个数，每一位可以类比为向量空间的一维，每一维只有 $0$ 和 $1$ 两种取值。$n$ 个数就是 $n$ 个 $64$ 维的向量（long long 为例），它们构成了 $64$ 维向量空间的一个子空间。这个子空间中允许异或运算，两个向量相异或即每一维相异或。 线性基是一组数，构成这个子空间的一个基底，也即满足以下性质： 原集合的任一元素可由线性基中的一些元素相异或得到； 线性基是满足上述条件的最小集合； 线性基没有异或为 $0$ 的子集：否则违背第二条； 线性基的选取元素方案不同，异或值不同：否则存在子集异或为 $0$. 线性基的构造方式： 设 $p[]$ 是存储线性基中的数组，$p[i]$ 存储最高位为 $i$ 的数字。向线性基中插入一个数 $x$ 时，从高位向低位扫描，当扫到第 $k$ 位时，若 $p[k]$ 为 $0$，则 $p[k]$ 置为 $x$；否则 $x$ 异或上 $p[k]$. 代码如下： 1234567inline void insert(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; break; } else x ^= p[i]; }} 原因是：若 $p[k]=0$，则线性基中目前无法将 $x$ 异或出来，必须将 $p[k]$ 置为 $x$；否则，可以选出 $p[k]$ 将第 $k$ 位搞定，然后 $x$ 异或上 $p[k]$ 继续去匹配。 本质上其实和线性代数中初等行变换化上三角矩阵是一个道理，把 $p[]$ 数组一行一行写下来，大的在上，小的在下，就形成了一个上三角矩阵（不管不存在的维）。 有些题目可能还要化标准型矩阵，需要进行高斯消元： 1234567inline void norm(){ for(int i = 62; i &gt;= 0; i--) if(p[i]) for(int j = 62; j &gt; i; j--) if((p[j] &gt;&gt; i) &amp; 1) p[j] ^= p[i];} 模板>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;int n;LL a;LL p[70];inline bool insert(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; return true; } else x ^= p[i]; } return false;}inline void norm(){ for(int i = 62; i &gt;= 0; i--) if(p[i]) for(int j = 62; j &gt; i; j--) if((p[j] &gt;&gt; i) &amp; 1) p[j] ^= p[i];}inline bool exist(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]) return false; else x ^= p[i]; } return true;}inline LL xorMax(){ LL res = 0; for(int i = 62; i &gt;= 0; i--) res = max(res, res ^ p[i]); return res;}inline LL xorMin(){ for(int i = 0; i &lt;= 62; i++) if(p[i]) return p[i]; return 0;}inline LL kthMin(LL k){ // kth minimum number (excluding 0) LL res = 0; vector&lt;LL&gt; tmp; for(int i = 0; i &lt;= 62; i++) if(p[i]) tmp.push_back(p[i]); if(k &gt;= (1ll &lt;&lt; tmp.size())) return -1; for(int i = tmp.size() - 1; i &gt;= 0; i--) if((k &gt;&gt; i) &amp; 1) res ^= tmp[i]; return res;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%lld&quot;, &amp;a); insert(a); } printf(&quot;%lld\\n&quot;, xorMax()); return 0;} 练习luoguP3812 【模板】线性基题目链接 任取数使得异或值最大。 从大到小考虑线性基中的数，若异或上它之后答案变大则异或，否则不异或。 >folded12345678910111213141516171819202122232425262728293031323334#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;int n;LL a;LL p[70];inline void insert(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; break; } else x ^= p[i]; }}inline LL xorMax(){ LL res = 0; for(int i = 62; i &gt;= 0; i--) res = max(res, res ^ p[i]); return res;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++){ scanf(&quot;%lld&quot;, &amp;a); insert(a); } printf(&quot;%lld\\n&quot;, xorMax()); return 0;} hdu3949 XOR题目链接 求第 $k$ 小异或值。 设线性基中基向量从大到小依次为 $\\mathbf{v_0,v_1,\\cdots,v_{m-1}}$（已经标准化了之后），则这个线性空间中第 $k=(b_x\\cdots b_0)2$ 小的数为$$\\bigoplus{i=0}^{x}b_i\\mathbf{v_i}$$根据二进制不难证明。 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 10005;int n, q;LL p[70];bool zero;inline bool insert(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; return true; } else x ^= p[i]; } return false;}inline void norm(){ for(int i = 62; i &gt;= 0; i--) if(p[i]) for(int j = 62; j &gt; i; j--) if((p[j] &gt;&gt; i) &amp; 1) p[j] ^= p[i];}inline LL kthMin(LL k){ // kth minimum number (excluding 0) LL res = 0; vector&lt;LL&gt; tmp; for(int i = 0; i &lt;= 62; i++) if(p[i]) tmp.push_back(p[i]); if(k &gt;= (1ll &lt;&lt; tmp.size())) return -1; for(int i = tmp.size() - 1; i &gt;= 0; i--) if((k &gt;&gt; i) &amp; 1) res ^= tmp[i]; return res;}int main(){ int T; scanf(&quot;%d&quot;, &amp;T); for(int CASES = 1; CASES &lt;= T; CASES++){ printf(&quot;Case #%d:\\n&quot;, CASES); scanf(&quot;%d&quot;, &amp;n); memset(p, 0, sizeof p); zero = false; for(LL i = 1; i &lt;= n; i++){ LL a; scanf(&quot;%lld&quot;, &amp;a); if(!insert(a)) zero = true; } norm(); scanf(&quot;%d&quot;, &amp;q); while(q--){ LL k; scanf(&quot;%lld&quot;, &amp;k); printf(&quot;%lld\\n&quot;, kthMin(k - zero)); } } return 0;} [BJWC2011]元素题目链接 按法力从大到小排序，依次往线性基中插入元素时，若能插入则加上它的法力；否则扔掉。 贪心正确性：如果某个子集异或为 $0$，必然需要扔掉一个矿石，当然是扔掉法力最小的矿石啦。无法插入线性基的意义即它与之前的某些矿石形成的集合异或为 $0$，排序后它就是最小法力的矿石，不管它即可。 >folded12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 1005;int n;LL ans;struct Node{ LL num, magic; bool operator &lt; (const Node &amp;A) const{ return magic &gt; A.magic; }}a[N];LL p[70];inline bool insert(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; break; } else x ^= p[i]; } return x != 0;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld%lld&quot;, &amp;a[i].num, &amp;a[i].magic); sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i++) if(insert(a[i].num)) ans += a[i].magic; printf(&quot;%lld\\n&quot;, ans); return 0;} [TJOI2008]彩灯题目链接 输出子空间的大小，即 $2$ 的线性基大小次幂即可。 >folded12345678910111213141516171819202122232425262728293031323334#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 55;int n, m, cnt;char s[N];LL p[70];inline void insert(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; cnt++; break; } else x ^= p[i]; }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%s&quot;, s); LL a = 0; for(int j = 0; j &lt; n; j++) if(s[j] == 'O') a |= (1ll &lt;&lt; j); insert(a); } printf(&quot;%lld\\n&quot;, (1ll &lt;&lt; cnt) % 2008); return 0;} [SCOI2016]幸运数字题目链接 倍增lca + 线性基 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;template&lt;typename T&gt;void read(T&amp;x){x=0;int fl=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')fl=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';ch=getchar();}x*=fl;}template&lt;typename T,typename...Args&gt;inline void read(T&amp;t,Args&amp;...args){read(t);read(args...);}typedef long long LL;const int N = 20001;inline void insert(LL p[], LL x){ for(int i = 60; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; break; } else x ^= p[i]; }}inline void merge(LL p[], LL q[]){ for(int i = 0; i &lt;= 60; i++) if(q[i]) insert(p, q[i]);}inline LL xorMax(LL p[]){ LL res = 0; for(int i = 60; i &gt;= 0; i--) res = max(res, res ^ p[i]); return res;}int n, q;LL g[N], p[N][21][61];struct Edge{ int nxt, to;}edge[N&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to){ edge[++edgeNum].nxt = head[from]; edge[edgeNum].to = to; head[from] = edgeNum;}int fa[N][21], dep[N];void dfs(int x, int f, int depth){ dep[x] = depth; fa[x][0] = f; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; dfs(edge[i].to, x, depth+1); }}void init(){ for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for(int i = 1; i &lt;= n; i++) if(fa[i][j-1]){ fa[i][j] = fa[fa[i][j-1]][j-1]; merge(p[i][j], p[i][j-1]); merge(p[i][j], p[fa[i][j-1]][j-1]); }}inline LL lca(int x, int y){ LL ans[61] = {0}; if(dep[x] &lt; dep[y]) swap(x, y); for(int i = 20; i &gt;= 0; i--) if(dep[x] - (1 &lt;&lt; i) &gt;= dep[y]) merge(ans, p[x][i]), x = fa[x][i]; if(x == y) return merge(ans, p[x][0]), xorMax(ans); for(int i = 20; i &gt;= 0; i--){ if(fa[x][i] &amp;&amp; fa[x][i] != fa[y][i]){ merge(ans, p[x][i]), merge(ans, p[y][i]); x = fa[x][i], y = fa[y][i]; } } merge(ans, p[x][0]), merge(ans, p[y][0]); merge(ans, p[fa[x][0]][0]); return xorMax(ans);}int main(){ read(n, q); for(int i = 1; i &lt;= n; i++){ read(g[i]); insert(p[i][0], g[i]); } for(int i = 1; i &lt; n; i++){ int u, v; read(u, v); addEdge(u, v), addEdge(v, u); } dfs(1, 0, 1); init(); while(q--){ int u, v; read(u, v); printf(&quot;%lld\\n&quot;, lca(u, v)); } return 0;} [WC2011]最大XOR和路径题目链接 从一个点出发，到某个圈绕一圈之后再原路返回，就白嫖到了这个圈的异或和。所以把所有圈的异或和丢进线性基，再任意找一条从 $1$ 到 $n$ 的路径在线性基中询问即可。（任意找的原理是：即使当前路径不是最优的，最优路径一定会与它形成了若干圈，异或这些圈就能自动修正成最优路径） >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;const int N = 50005;const int M = 100005;int n, m;LL p[70];inline void insert(LL x){ for(int i = 62; i &gt;= 0; i--){ if((x &gt;&gt; i) == 0) continue; if(!p[i]){ p[i] = x; break; } else x ^= p[i]; }}struct Edge{ int nxt, to; LL dis;}edge[M&lt;&lt;1];int head[N], edgeNum;void addEdge(int from, int to, LL dis){ edge[++edgeNum] = (Edge){head[from], to, dis}; head[from] = edgeNum;}LL dis[N];bool vis[N];void dfs(int x, int f){ vis[x] = 1; for(int i = head[x]; i; i = edge[i].nxt){ if(edge[i].to == f) continue; if(vis[edge[i].to]) insert(dis[edge[i].to] ^ dis[x] ^ edge[i].dis); else dis[edge[i].to] = dis[x] ^ edge[i].dis, dfs(edge[i].to, x); }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++){ int u, v; LL d; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;d); addEdge(u, v, d), addEdge(v, u, d); } dfs(1, 0); LL ans = dis[n]; for(int i = 62; i &gt;= 0; i--) ans = max(ans, ans ^ p[i]); printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/blog-xcpc/2020/03/10/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"线段树分治学习笔记（未完待续）","text":"参考博客：1 2 简述线段树分治解决一类具有撤销操作的问题。 与可持久化不同，可持久化在某个历史版本上做更改后不会影响到后续的结果，而这里的撤销操作会影响到后续的结果（即这是一个 ‘Retroactive Data Structure’ 而非 ‘Persistent Data Structure’，相关内容参看Eric Demaine的论文或者视频）。 为解决该问题，我们以时间为域建立一棵线段树，则所有的操作、询问对应了线段树上表示相关时间区间的一些节点。节点内储存解决问题需要的数据结构。 如此，倘若我们 $dfs$ 整棵线段树，并在路途中记录操作、在回溯时撤销操作，则到达线段树的每个叶节点时，我们就知道了在当前叶节点所表示的时刻，我们进行了哪些操作。 练习[TJOI2018]数学计算题目链接 乍一看以为直接模拟，但是 $mod$ 不保证质数或者互质，处理逆元不方便。 转换思路，以时间为域建立线段树，节点存储该时间乘上的数。除掉某一次操作其实就是更改乘数为 $1$，所以单点修改区间查询即可。 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int N = 100005;int T, q, opt;LL m, MOD;struct segTree{ int l, r; LL res, mul;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)inline void pushup(int id){ tr[id].res = tr[lid].res * tr[rid].res % MOD;}void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].res = tr[id].mul = 1; if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r); pushup(id);}void modify(int id, int pos, LL val){ if(tr[id].l == tr[id].r){ tr[id].mul = val; tr[id].res = val; return; } if(pos &lt;= mid) modify(lid, pos, val); else modify(rid, pos, val); pushup(id);}int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%lld&quot;, &amp;q, &amp;MOD); build(1, 1, q); for(int i = 1; i &lt;= q; i++){ scanf(&quot;%d%lld&quot;, &amp;opt, &amp;m); if(opt == 1) modify(1, i, m); else modify(1, m, 1); printf(&quot;%lld\\n&quot;, tr[1].res); } } return 0;} luoguP5787 / bzoj4025二分图题目链接 每一条边对应着一段持续时间，即对应了线段树的若干节点。线段树的每个节点开一个 vector，记录该节点时间段内存在的边，于是我们 $dfs$ 遍历整棵线段树，凡到达一个叶节点就能获知此时图中有哪些边。 由于一个图是二分图当且仅当该图不含奇环，我们只需要判断这些边是否形成奇环，这一点可以用带权并查集完成。回溯时需要撤掉边，所以带权并查集需要是可撤销的——开一个栈记录搜索过程中在并查集中加入了哪些边，回溯时弹栈撤掉这些边，此并查集不能路径压缩，所以要按秩合并以保证复杂度。 再多说一点带权并查集：带的权是一个点到其父节点在原图中的距离的奇偶性。当我们连接 $u,v$ 时，若它们同在一个并查集内且到并查集代表元素的距离同奇偶，则再连上 $(u,v)$ 这条边会导致奇环，输出 No；若它们不在同一个并查集内，设 $u,v$ 各自并查集代表元素为 $x,y$，则我们在并查集中实际上连接的是 $(x,y)$，这条边的权是 $(x,y)$ 在原图中的距离奇偶性，即 $x$ 到 $u$ 的距离奇偶性异或 $y$ 到 $v$ 的距离奇偶性异或 $1$. 时间复杂度：$O(k\\lg k\\lg n)$ >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)#define pb(x) emplace_back(x)const int N = 200005;int n, m, k, u[N], v[N];struct segTree{ int l, r; vector&lt;int&gt; vec;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].vec.clear(); if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r);}void add(int id, int l, int r, int val){ if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].vec.pb(val); return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val);}stack&lt;pii&gt; sta;int fa[N], sz[N], dis[N];int findfa(int x){ return x == fa[x] ? x : findfa(fa[x]); }int getDis(int x){ return x == fa[x] ? dis[x] : dis[x] ^ getDis(fa[x]); }void unionn(int x, int y){ int tx = x, ty = y; x = findfa(x), y = findfa(y); if(x == y) return; if(sz[x] &lt; sz[y]) swap(x, y); sta.push(mp(x, y)); fa[y] = x, sz[x] += sz[y]; dis[y] ^= getDis(tx) ^ getDis(ty) ^ 1;}void dfs(int id){ bool ok = true; int siz = sta.size(); for(auto i: tr[id].vec){ if(findfa(u[i]) == findfa(v[i])){ if(getDis(u[i]) == getDis(v[i])){ ok = false; break; } } else unionn(u[i], v[i]); } if(!ok) for(int i = tr[id].l; i &lt;= tr[id].r; i++) puts(&quot;No&quot;); else if(tr[id].l == tr[id].r) puts(&quot;Yes&quot;); else dfs(lid), dfs(rid); while(sta.size() &gt; siz){ pii cur = sta.top(); sta.pop(); int x = cur.first, y = cur.second; fa[y] = y, sz[x] -= sz[y]; }}int main(){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= k; i++) fa[i] = i, sz[i] = 1; build(1, 1, k); for(int i = 1; i &lt;= m; i++){ int l, r; scanf(&quot;%d%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;l, &amp;r); if(l &lt; r) add(1, l + 1, r, i); } dfs(1); return 0;} 「LibreOJ Round #6」花团题目链接 线段树每个节点开一个 vector，记录该节点时间段内有哪些物品。然后 $dfs$ 整棵线段树，在搜索的过程中做 $01$ 背包，到达询问点就输出结果。 回溯撤销操作时，需要把 $dp$ 数组置为上一层的 $dp$ 数组，所以 $dp$ 数组开成二维的，以线段树层数为第一维。 复杂度：$O(vq\\lg q)$ （不知为何就是可以过～） >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define mp(x, y) make_pair(x, y)const int N = 15005;int q, maxv, T, lastans;struct segTree{ int l, r; vector&lt;pii&gt; vec;}tr[N&lt;&lt;2];#define lid id&lt;&lt;1#define rid id&lt;&lt;1|1#define mid ((tr[id].l + tr[id].r) &gt;&gt; 1)void build(int id, int l, int r){ tr[id].l = l, tr[id].r = r; tr[id].vec.clear(); if(tr[id].l == tr[id].r) return; build(lid, l, mid); build(rid, mid+1, r);}void add(int id, int l, int r, pii val){ if(tr[id].l == l &amp;&amp; tr[id].r == r){ tr[id].vec.emplace_back(val); return; } if(r &lt;= mid) add(lid, l, r, val); else if(l &gt; mid) add(rid, l, r, val); else add(lid, l, mid, val), add(rid, mid+1, r, val);}int dp[20][N];void dfs(int dep, int id){ for(auto k: tr[id].vec) for(int j = maxv; j &gt;= k.first; j--) dp[dep][j] = max(dp[dep][j-k.first] + k.second, dp[dep][j]); if(tr[id].l == tr[id].r){ int op, v, w, e; scanf(&quot;%d&quot;, &amp;op); if(op == 1){ scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;e); v -= T * lastans, w -= T * lastans, e -= T * lastans; if(tr[id].l &lt; e) add(1, tr[id].l + 1, e, mp(v, w)); } else{ scanf(&quot;%d&quot;, &amp;v); v -= T * lastans; if(dp[dep][v] &lt; 0){ puts(&quot;0 0&quot;); lastans = 0; } else{ printf(&quot;1 %d\\n&quot;, dp[dep][v]); lastans = 1 ^ dp[dep][v]; } } return; } for(int j = 0; j &lt;= maxv; j++) dp[dep+1][j] = dp[dep][j]; dfs(dep + 1, lid); for(int j = 0; j &lt;= maxv; j++) dp[dep+1][j] = dp[dep][j]; dfs(dep + 1, rid);}int main(){ scanf(&quot;%d%d%d&quot;, &amp;q, &amp;maxv, &amp;T); build(1, 1, q); for(int i = 1; i &lt;= maxv; i++) dp[1][i] = -1e9; dfs(1, 1); return 0;}","link":"/blog-xcpc/2020/03/21/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"自适应Simpson积分学习笔记","text":"一种精度较高的积分数值计算方法。 原理简述（随便捞一本数分的书应该都会讲）Simpson 积分是积分数值计算的一种方法，用抛物线而非传统的矩形来近似图形，精度较高，公式为：$$\\int_a^bf(x)dx\\approx \\frac{b-a}{6n}\\sum\\limits_{i=1}^n\\left[f(x_i)+4f\\left(\\frac{x_i+x_{i-1}}{2}\\right)+f(x_{i-1})\\right]$$然而实际解题的过程中不好控制划分的数量 $n$，所以提出了自适应 Simpson 积分。所谓自适应，即积分数值在可接受范围内时直接返回积分，否则对半分开递归求解，这里每层在积分时只划分成 $1$ 条即可，也就是说：$$\\int_a^bf(x)dx\\approx \\frac{b-a}{6}\\left[f(a)+4f\\left(\\frac{a+b}{2}\\right)+f(b)\\right]$$即可。 模板12345678910double simpson(double l, double r){ double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;}double solve(double l, double r, double _eps, double I){ double mid = (l + r) / 2; double Il = simpson(l, mid), Ir = simpson(mid, r); if(fabs(Il + Ir - I) &lt;= 15 * _eps) return Il + Ir + (Il + Ir - I) / 15; return solve(l, mid, _eps / 2, Il) + solve(mid, r, _eps / 2, Ir);} 练习luoguP4525 【模板】自适应辛普森法1题目链接 >folded123456789101112131415161718192021222324252627#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;double a, b, c, d;double f(double x){ return (c * x + d) / (a * x + b);}double simpson(double l, double r){ double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;}double solve(double l, double r, double eps){ double mid = (l + r) / 2; double Il = simpson(l, mid), Ir = simpson(mid, r), I = simpson(l, r); if(fabs(Il + Ir - I) &lt;= 15 * eps) return Il + Ir + (Il + Ir - I) / 15; return solve(l, mid, eps / 2) + solve(mid, r, eps / 2);}int main(){ double l, r; scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;l, &amp;r); printf(&quot;%.6f\\n&quot;, solve(l, r, 1e-7)); return 0;} luoguP4526 【模板】自适应辛普森法2题目链接 >folded1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;double a;double f(double x){ return pow(x, a / x - x);}double simpson(double l, double r){ double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;}double solve(double l, double r, double eps){ double mid = (l + r) / 2; double Il = simpson(l, mid), Ir = simpson(mid, r), I = simpson(l, r); if(fabs(Il + Ir - I) &lt;= 15 * eps) return Il + Ir + (Il + Ir - I) / 15; return solve(l, mid, eps / 2) + solve(mid, r, eps / 2);}int main(){ scanf(&quot;%lf&quot;, &amp;a); if(a &lt; 0) puts(&quot;orz&quot;); else printf(&quot;%.5f\\n&quot;, solve(1e-8, 20, 1e-7)); return 0;} hdu1724 Ellipse题目链接 >folded1234567891011121314151617181920212223242526272829303132#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int T;double a, b;double f(double x){ // the function return 2 * sqrt(b * b * (1 - x * x / a / a));}double simpson(double l, double r){ double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;}double solve(double l, double r, double _eps, double I){ double mid = (l + r) / 2; double Il = simpson(l, mid), Ir = simpson(mid, r); if(fabs(Il + Ir - I) &lt;= 15 * _eps) return Il + Ir + (Il + Ir - I) / 15; return solve(l, mid, _eps / 2, Il) + solve(mid, r, _eps / 2, Ir);}int main(){ scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lf%lf&quot;, &amp;a, &amp;b); double l, r; scanf(&quot;%lf%lf&quot;, &amp;l, &amp;r); printf(&quot;%.3f\\n&quot;, solve(l, r, 1e-5, simpson(l, r))); } return 0;} SP8073 CIRU - The area of the union of circles题目链接 求圆的面积并。将 $x=x_0$ 处圆覆盖的线段长度作为函数值 $f(x_0)$，这个函数值可以 $O(n\\lg n)$ 求得。对这个函数 $f(x)$ 在整个区间内作 Simpson 积分即可。但是当圆的分布较为稀疏时，函数 $f(x)$ 可能有大量的 $0$ 点，在自适应 Simpson 积分时可能不会递归求解下去。所以我们选取一系列有圆覆盖的连续区间分段积分。 一些优化：小圆在大圆内部先删去；单独一个没有与其他圆有交的圆先算出答案并删去。 &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const double eps = 1e-8;const double PI = acos(-1);const double INF = 1e16;inline int sgn(double x){ if(fabs(x) &lt; eps) return 0; else if(x &gt; 0) return 1; else return -1;}inline int cmp(double x, double y){ if(fabs(x-y) &lt; eps) return 0; else if(x &gt; y) return 1; else return -1;}struct Vector{ double x, y; Vector(double x = 0, double y = 0):x(x), y(y){} void read(){ scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector{A.x + B.x, A.y + B.y}; }Vector operator - (Vector A, Vector B){ return Vector{A.x - B.x, A.y - B.y}; }double operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; } // dot productdouble Length(Vector A){ return sqrt(A * A); }struct Line{ Point p; Vector v;};struct Circle{ Point p; double r; bool operator &lt; (const Circle &amp;C) const{ return r &gt; C.r; }};// ------------------------------------------------------------------------------- //const int N = 1005;int n;Circle c[N];bool b[N];double ans;struct Segment{ double l, r; bool operator &lt; (const Segment &amp;A) const{ return l &lt; A.l; }}a[N], seg[N];double f(double x){ int id = 0; for(int i = 1; i &lt;= n; i++){ double d = c[i].r * c[i].r - (c[i].p.x - x) * (c[i].p.x - x); if(sgn(d) &lt;= 0) continue; d = sqrt(d); a[++id] = (Segment){c[i].p.y - d, c[i].p.y + d}; } sort(a+1, a+id+1); double res = 0, pre = -1e9; for(int i = 1; i &lt;= id; i++){ if(a[i].l &gt; pre) res += a[i].r - a[i].l, pre = a[i].r; else if(a[i].r &gt; pre) res += a[i].r - pre, pre = a[i].r; } return res;}double simpson(double l, double r){ double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;}double solve(double l, double r, double _eps){ double mid = (l + r) / 2; double Il = simpson(l, mid), Ir = simpson(mid, r), I = simpson(l, r); if(fabs(Il + Ir - I) &lt;= 15 * _eps) return Il + Ir + (Il + Ir - I) / 15; return solve(l, mid, _eps / 2) + solve(mid, r, _eps / 2);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf%lf&quot;, &amp;c[i].p.x, &amp;c[i].p.y, &amp;c[i].r); sort(c+1, c+n+1); int cid = 0; for(int i = 1; i &lt;= n; i++){ if(sgn(c[i].r) == 0) continue; bool in = false; for(int j = 1; j &lt;= cid; j++){ if(cmp(Length(c[j].p - c[i].p), c[j].r - c[i].r) &lt;= 0){ in = true; break; } } if(!in) c[++cid] = c[i]; } n = cid; cid = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt; i; j++) if(cmp(Length(c[i].p - c[j].p), c[i].r + c[j].r) &lt; 0) b[i] = b[j] = 1; for(int i = 1; i &lt;= n; i++) if(!b[i]) ans += PI * c[i].r * c[i].r; else c[++cid] = c[i]; n = cid; int id = 0; for(int i = 1; i &lt;= n; i++) seg[++id] = (Segment){c[i].p.x - c[i].r, c[i].p.x + c[i].r}; sort(seg+1, seg+id+1); double pre = -1e9; for(int i = 1; i &lt;= id; i++){ if(seg[i].l &gt; pre) ans += solve(seg[i].l, seg[i].r, 1e-5), pre = seg[i].r; else if(seg[i].r &gt; pre) ans += solve(pre, seg[i].r, 1e-5), pre = seg[i].r; } printf(&quot;%.3f\\n&quot;, ans); return 0;} [NOI2005]月下柠檬树题目链接 圆的投影仍然是圆，圆台的投影是两圆及其外公切线。套用 Simpson 积分即可。 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const double eps = 1e-8;const double PI = acos(-1);const double INF = 1e16;inline int sgn(double x){ if(fabs(x) &lt; eps) return 0; else if(x &gt; 0) return 1; else return -1;}inline int cmp(double x, double y){ if(fabs(x-y) &lt; eps) return 0; else if(x &gt; y) return 1; else return -1;}struct Vector{ double x, y; Vector(double x = 0, double y = 0):x(x), y(y){} void read(){ scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); }};typedef Vector Point;Vector operator + (Vector A, Vector B){ return Vector{A.x + B.x, A.y + B.y}; }Vector operator - (Vector A, Vector B){ return Vector{A.x - B.x, A.y - B.y}; }Vector operator * (Vector A, double k){ return Vector{A.x * k, A.y * k}; }double operator * (Vector A, Vector B){ return A.x * B.x + A.y * B.y; } // dot productdouble Length(Vector A){ return sqrt(A * A); }double Angle(Vector A){ return atan2(A.y, A.x); } // polar angle of vector Astruct Line{ Point p; Vector v;};struct Circle{ Point p; double r; Point getPoint(double alpha){ return Point(p.x + cos(alpha) * r, p.y + sin(alpha) * r); }};void getTangents(Circle C1, Circle C2, Point c1[], Point c2[], int &amp;resn){ // resn is the number of tangent lines // c1[] and c2[] are relevant points on C1 and C2 resn = 0; if(cmp(C1.r, C2.r) &lt; 0) swap(C1, C2), swap(c1, c2); double d = Length(C1.p - C2.p); if(sgn(d) == 0 &amp;&amp; cmp(C1.r, C2.r) == 0){ resn = -1; return; } // two circles are the same if(cmp(C1.r - C2.r, d) &gt; 0) return; // contained double base = Angle(C2.p - C1.p); if(cmp(C1.r - C2.r, d) == 0){ // internally tangent c1[++resn] = C1.getPoint(base), c2[resn] = C2.getPoint(base); return; } double ang = acos((C1.r - C2.r) / d); c1[++resn] = C1.getPoint(base - ang), c2[resn] = C2.getPoint(base - ang); c1[++resn] = C1.getPoint(base + ang), c2[resn] = C2.getPoint(base + ang);// if(cmp(C1.r + C2.r, d) == 0) // externally tangent// c1[++resn] = C1.getPoint(base), c2[resn] = C2.getPoint(base + PI);// else if(cmp(C1.r + C2.r, d) &lt; 0){ // separated// ang = acos((C1.r + C2.r) / d);// c1[++resn] = C1.getPoint(base - ang), c2[resn] = C2.getPoint(base - ang + PI);// c1[++resn] = C1.getPoint(base + ang), c2[resn] = C2.getPoint(base + ang + PI);// }}// ------------------------------------------------------------------------------- //const int N = 1005;int n;Circle c[N];double alpha, H[N], R[N], mxR, mnL = 1e9;pair&lt;Point, Point&gt; seg[N]; int sid;double f(double x){ double mx = 0, res = 0; for(int i = 1; i &lt;= sid; i++){ if(cmp(seg[i].first.x, x) &lt;= 0 &amp;&amp; cmp(seg[i].second.x, x) &gt;= 0){ Point p = seg[i].first + (seg[i].second - seg[i].first) * ((x - seg[i].first.x) / (seg[i].second.x - seg[i].first.x)); mx = max(mx, p.y); } } for(int i = 1; i &lt;= n; i++) if(cmp(c[i].r, fabs(x - c[i].p.x)) &gt; 0) mx = max(mx, sqrt(c[i].r * c[i].r - fabs(x - c[i].p.x) * fabs(x - c[i].p.x))); res += mx; return res;}double simpson(double l, double r){ double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;}double solve(double l, double r, double _eps, double I){ double mid = (l + r) / 2; double Il = simpson(l, mid), Ir = simpson(mid, r); if(fabs(Il + Ir - I) &lt;= 15 * _eps) return Il + Ir + (Il + Ir - I) / 15; return solve(l, mid, _eps / 2, Il) + solve(mid, r, _eps / 2, Ir);}int main(){ scanf(&quot;%d%lf&quot;, &amp;n, &amp;alpha); double Tan = 1 / tan(alpha); for(int i = 1; i &lt;= n + 1; i++){ scanf(&quot;%lf&quot;, &amp;H[i]); H[i] += H[i-1]; } for(int i = 1; i &lt;= n + 1; i++){ if(i &lt;= n) scanf(&quot;%lf&quot;, &amp;R[i]); c[i].p = Point(H[i] * Tan, 0); c[i].r = R[i]; mnL = min(mnL, c[i].p.x - c[i].r); mxR = max(mxR, c[i].p.x + c[i].r); if(i &gt; 1){ Point p1[10], p2[10]; int pid; getTangents(c[i-1], c[i], p1, p2, pid); for(int j = 1; j &lt;= pid; j++){ if(sgn(p1[j].y) &lt;= 0) continue; if(p1[j].x &gt; p2[j].x) swap(p1[j], p2[j]); seg[++sid] = make_pair(p1[j], p2[j]); } } } printf(&quot;%.2f\\n&quot;, 2 * solve(mnL, mxR, 1e-6, simpson(mnL, mxR))); return 0;}","link":"/blog-xcpc/2020/03/18/%E8%87%AA%E9%80%82%E5%BA%94Simpson%E7%A7%AF%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"计算几何专题练习记录","text":"部分题目参考来源：1 2 3 《算法竞赛入门经典——训练指南》 计算几何专题练习记录（二）：link 基础知识应用 poj 2318 TOYS: 判断点在直线的左右。$\\star$ poj 2398 Toy Storage: 同上。$\\star$ poj 1556 The Doors: 判断线段相交，建图跑最短路。$\\star\\star$ poj 1696 Space Ant: 从最低点开始尽可能左转少的角度，卷包裹。$\\star\\star$ poj 3304 Segments: 转化问题为找一条直线与所有线段相交，又易知平移旋转该直线可使其与两个线段端点重合，故枚举即可。$\\star\\star\\star$ poj 1127 Jack Straws: 线段相交，并查集。$\\star$ poj 1654 Area: 多边形面积。$\\star$ poj 1408 Fishnet: 四边形面积。$\\star$ poj 2954 Triangle: Pick 定理，gcd 计算边上的点数。$\\star$ poj 2031 Building a Space Station: 球体相交，最小生成树。$\\star$ poj 1584 A Round Peg in a Ground Hole: 判断圆是否在凸多边形内部时，首先看圆心是否在多边形内，然后看距离与半径大小。$\\star$ poj 3334 Connected Gheeves: 二分答案，多边形面积。$\\star\\star$ poj 1819 Disks: 计算相切时圆心，不要忘了处理开头与结尾。$\\star\\star$ poj 2826 An Easy Problem?!: 情况容易漏掉，另外还有一个坑：输出时可能输出 -0.00，应加上 eps 后再输出。$\\star\\star\\star$ poj 2074 Line of Sight: 视线遮挡问题。$\\star\\star$ poj 1039 Pipe: 容易发现一定存在过一个上端点、过一个下端点的最优光路，于是枚举端点，依次判断相交即可，注意端点相交的处理。$\\star\\star$ poj 1418 Viva Confetti: 每一个可见部分都由几段小圆弧构成，可以先求出所有小圆弧，将其中点向内向外扰动一点点得到两点，标记包含这两点的最顶端的圆盘为可见。$\\star\\star\\star\\star$ UVA 11817 Tunnelling the Earth: 球面距离。$\\star$ UVA 10969 Sweet Dream: 和 poj1418 类似，找出所有小圆弧，用其中点判断该段小圆弧是否被覆盖。$\\star\\star\\star$ UVA 11178 Morley’s Theorem: 角度计算、向量旋转、直线相交。$\\star$ UVA 1342 The Nice Euler Circuits: 欧拉定理，线段相交。$\\star\\star$ UVA 11796 Dog Distance: 模拟，把同时运动的距离最值转化成点到线段距离最值（绝对速度转化为相对速度）$\\star\\star$ UVA 11177 Fighting against a Polygonal Monster: 二分答案，多边形与圆相交的面积。$\\star\\star\\star$ UVA 1340 Find The Border: 卷包裹，从最左下端开始沿着线段走，走到一个交点后尽可能地右转，继续走。$\\star\\star\\star$ UVA 12296 Pieces and Discs: 切割多边形；判断多边形与圆的位置关系：圆心在多边形内或圆心到多边形边（是一系列线段）的距离小于圆的半径）$\\star\\star\\star$ CF 1254C Point Ordering: 交互题。首先用 $n-2$ 次提问确定 $3$ 至 $n$ 这些点在 $1,2$ 两点连线的左右，对于左边的那些点（右边同理），用第一种提问得到它们到 $1,2$ 连线的距离，找到最远的点 $mark$，判断其他点是在 $1,mark$ 之间还是 $mark,2$ 之间，分别按距离排序后就形成了逆时针方向。$\\star\\star\\star\\star$ CF 961D Pair Of Lines: 找三个不共线的点，两两配对连线作为一条直线，判断其余点是否在这条线上或构成另一条线。$\\star\\star$ CF 1059D Nature Reserve: 二分答案，check：判断一个半径为 $r$ 的圆能否覆盖所有点，即判断以每个点为圆心、以 $r$ 为半径构造的圆是否有公共交点，又圆心在 $y=r$ 上，只需判断构造的圆与 $y=r$ 交成的线段是否有公共交点即可。小心卡精度，用 long double 并且二分150次就退出。$\\star\\star\\star\\star$ 初中平几 UVA 11437 Triangle Fun: 梅涅劳斯定理。$\\star$ UVA 11800 Determine the Shape: 判断四边形形状。$\\star$ UVA 11646 Athletics Track: 平几。$\\star$ UVA 11524 InCircle: 内切圆。$\\star$ UVA 11731 Ex-Circles: 旁切圆。$\\star\\star$ UVA 10566 Crossed Ladders: 相似三角形，二分答案。$\\star$ UVA 11186 Circum Triangle: 把三角形面积拆成和圆心连线后的三个三角形面积之和/差，枚举边，数多少取正多少取负。$\\star\\star\\star$ UVA 1447 Malfatti Circles: 内切圆，推不出公式可以二分。$\\star\\star\\star$ UVA 12165 Triangle Hazard: 梅涅劳斯定理。$\\star\\star$ UVA 1473 Dome of Circus: 转化为平面坐标系，三分。$\\star\\star$ 反演变换 hdu 4773 Problems of Apollonius: 视要求经过的点为反演中心，任取反演半径，则根据反演的性质，所求圆反演后是一条直线，且与给定两圆的反演圆相切，即反演直线是两反演圆的公切线。于是求得公切线之后再反演回去即可。$\\star\\star\\star\\star$ hdu 6158 The Designer: 选取两大圆的切点为反演中心，任取反演半径，则两大圆反演为两直线，所有小圆的反演圆都是夹在这两条直线之间的半径相同的圆，根据反演圆的信息倒推小圆半径即可。当答案小到不影响精度时就 break 掉。$\\star\\star\\star$ 平面最近点对 luogu P1429: 模板 poj 3714 Raid: 对模板略加修改即可。$\\star$ 凸包 luogu P2742: 模板 poj 1873 The Fortified Forest: 二进制枚举，求凸包。$\\star\\star\\star$ poj 1228 Grandpa’s Estate: 判断凸包是否存在仅有两个点的边。$\\star\\star$ poj 3348 Cows: 求凸包面积。$\\star$ poj 1113 Wall: 凸包周长。$\\star$ [SHOI2012]信用卡凸包: 凸包周长加一个圆周长。$\\star$ UVA 10652 Board Wrapping: 求凸包面积。$\\star$ UVA 109 SCUD Busters: 求凸包及面积，判断点在多边形内。$\\star$ UVA 11168 Airport: 凸包，总距离需要转换为解析几何的思路方可 $O(1)$ 计算。$\\star\\star$ UVA 10256 The Great Divide: 判断两凸包是否有公共部分——看点在不在对方凸包内、看凸包线段是否相交。$\\star\\star\\star$ CF 1142C U2: 很妙的一道题！抛物线函数式改写成：$y-x^2=bx+c$，我们发现如果把所有点 $(x,y)$ 改成 $(x,y-x^2)$，那么抛物线就变成了直线，一个点在原抛物线内等价于改动后的点在直线上方，所以求出上凸包的边数即可。$\\star\\star\\star\\star$ 旋转卡壳 luogu P1452: 求凸包直径。$\\star$ poj 2187 Beauty Contest: 求凸包直径。$\\star$ UVA 1453 Squares: 求凸包直径，输入可能重复，需要去重。$\\star\\star$ poj 3608 Bridge Across Islands: 求两凸包之间的最短距离。$\\star\\star\\star$ [HNOI2007]最小矩形覆盖: 求覆盖所有点的最小面积矩形，先求出凸包，这个矩形的一条边一定与凸包的一条边共线，于是旋转卡壳枚举矩形一条边，找到对踵点作为对边上的点，然后向左向右找到左右边界。找左右边界时找投影长度最长的点，容易发现投影长度函数是单峰的，所以可以三分法求得（然而与暴力找时间开销几近相同）$\\star\\star\\star$ UVA 12307 Smallest Enclosing Rectangle: 求覆盖所有点的最小面积矩形和最小周长矩形：最小周长矩形也是一定有一条边与凸包一条边共线，在 HNOI2007 的最小面积矩形的基础上稍加改动即可。$\\star\\star\\star$ 半平面交 poj 3335 Rotating Scoreboard: 模板，判断多边形是否有核。 poj 3130 How I Mathematician Wonder What You Are!: 模板，同上。 poj 1474 Video Surveillance: 模板，同上。 poj 1279 Art Gallery: 模版，求多边形核的面积。 [CQOI2006]凸多边形: 模版，同上。 poj 2451 Uyuw’s Concert: 同上。 poj 3525 Most Distant Point from the Sea: 求凸多边形最大内切圆，二分答案，判断半平面交是否为空。$\\star\\star$ poj 3384 Feng Shui: 把问题转化为求将每条边向内平移 $r$ 长度后形成的凸多边形直径，该凸多边形用半平面交来生成。$\\star\\star\\star$ poj 2540 Hotter Colder: 把条件转化为半平面，注意方向。$\\star\\star\\star$ poj 1755 Triathlon: 设第一段长 $a$，第二段长 $b$，第三段长 $1-a-b$，列出 $i$ 快于 $j$ 的表达式，得到线性规划区域，半平面交判断是否有解。此题卡精度，需设置 eps=1e-16。$\\star\\star\\star$ [JSOI2004]平衡点: 初始平面是整个平面，取平面的中心，计算合力，则平衡点一定在合力指向的那个半平面上，于是不断二分、不断用半平面切割平面，直到剩余平面够小了则输出。$\\star\\star\\star\\star$ UVA 1475 Jungle Outpost: 假设已知敌人炸了 $k$ 座瞭望台，我们可以通过数归证明敌人的最优策略是炸掉连续的 $k$ 座瞭望台，此时，对应不同连续 $k$ 座被炸的瞭望台，保留部分是不同的半平面，它们交集非空，则总部设在其交集中便总能被保护。于是二分答案，判断半平面交是否为空。$\\star\\star\\star$ [SCOI2015]小凸想跑步: 列式表示 $\\Delta p01&lt;\\Delta pab$：$(x-x_0,y-y_0)\\times(x-x_1,y-y_1)&lt;(x-x_a,y-y_a)\\times(x-x_b,y-y_b)$，整理得：$(y_0-y_1+y_b-y_a)x+(x_1-x_0+x_a-x_b)y&lt;x_1y_0-x_0y_1+x_ay_b-x_by_a$，为一个半平面，计算半平面面积。 备注：$ax+by+c&lt;0$ 表示半平面时，方向向量为 $(-b, a)$. $\\star\\star\\star$ 扫描线 poj 1151 Atlantis: 模板，数据不大，可暴力。 luogu P5490: 模板 poj 3832 Posters: 注意不能添加空矩形区域，否则会 RE. poj 1177 Picture: 求图形周长，线段树需要多维护一个区间覆盖段数的信息，扫描线每扫到一个高度，竖直方向上周长加上两倍段数乘以高度，水平方向上周长加上当前覆盖长度与前一个覆盖长度的差的绝对值。$\\star\\star\\star$ luogu P1502 窗口的星星: 每一颗星星右上方划出一块 $W\\times H$ 的矩形区域，则窗户右上角落在该区域内时该星星可见。于是可以扫描线解之，线段树维护区间加、区间求最大值操作。$\\star\\star\\star$ poj 2932 Coneology: 由于两圆不可能有交点，所以一个圆覆盖另一个等价于另一个圆的圆心在这个圆内，然后从下往上扫描，每扫到一个圆的下界时判断这个圆有没有被已经扫过的圆覆盖，如果没有，则它一定是不被任何圆覆盖的；判断时，只需要判断当前圆左边横坐标方向最近的和右边横坐标方向最近的圆是否覆盖它即可，因为如果这两个圆都不覆盖的话，其他圆更不可能覆盖。于是乎，我们可以用一个可查询前驱或后继的数据结构维护不被任何圆覆盖的圆这个集合——平衡树、STL 的 set、值域线段树都可以。$\\star\\star\\star\\star$ hdu 1255 覆盖的面积: 由于没有 pushdown 操作，需要深入理解 cnt 标记——cnt == 0 表示区间信息完全未知，更新信息从子节点直接更新；cnt == 1 表示区间被覆盖至少 $1$ 次（有可能更多次），更新信息时，被覆盖 $2$ 次的长度等于左右子节点被覆盖 $1$ 次的长度和（因为已知本身被覆盖至少 $1$ 次，而这 $1$ 次是不会下放到子节点的）；cnt &gt;= 2 表示区间被覆盖至少 $2$ 次（有可能更多次），被覆盖 $2$ 次的长度等于区间长度。$\\star\\star\\star$ World Finals 2008 The Sky is the Limit: 记录山顶、山脚和交点的横坐标，扫描线从左往右扫之，在每个区间内枚举寻找最高的线段即可。$\\star\\star$ 三维凸包 luogu P4724: 模板 hdu 3662 3D Convex Hull: 求三维凸包的面数。$\\star$ hdu 4266 The Worm in the Apple: 求凸包内的点到凸包表面的最小距离。$\\star$ hdu 4273 Rescue: 求凸包重心到凸包表面最小距离。多面体重心求法：任取一点，用该点与多面体的面形成的三角锥分割多面体，三角锥的重心即其各顶点坐标的平均值，多面体的重心即各三角锥的重心坐标按照其质量（体积）加权的平均值。$\\star\\star$ 计算几何背景以计算几何为背景，考察构造思维或其他算法。 UVA 1318 Monster Trap: （计算几何+图论）容易知道，若怪物能逃离，则存在擦着一系列线段端点的逃离路径，也就是说，能两两连接不被隔断的线段端点之间建一条边，则跑一遍 dfs 或者 bfs 即可。问题在于，若有两个线段在转角处端点重合，这么建边会使得怪物可以在转角处穿墙而过，解决方案是把每一个线段都向两端延长一点点；再注意要特殊处理具有公共端点的线段共线的情况。$\\star\\star\\star\\star$ CF 1270E Divide Points: （计算几何+构造）从距离的奇偶性入手。把点分成四类：$(odd,odd),(odd,even),(even,odd),(even,even)$，如果只存在其中一类点，就将坐标不断除以2后重新分类；如果存在两类点，则其中一类作为 $A$ 集合，另一类作为 $B$ 集合，它们之间的距离有奇偶之分或是否整除 $4$ 之分；如果存在三类以上的点，则横纵坐标和为奇数作为 $A$ 集合，和为偶数作为 $B$ 集合，它们之间的距离有奇偶之分。$\\star\\star\\star\\star$","link":"/blog-xcpc/2020/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"计算几何专题练习记录（二）","text":"计算几何专题练习记录第一部分链接：link 点 / 向量 CF 672C Recycling Bottles：$2$ 倍的所有点到垃圾桶距离减去 $A,B$ 第一次走的时候顺便带垃圾的距离最大值；注意还有可能只有 $A$ 或 $B$ 捡垃圾的情形。$\\star$ CF 136D Rectangle and Square：暴力枚举+矩形判断+正方形判断。 $\\star$ CF 127A Wasted Time：两点之间距离。$\\star$ 极角排序 CF 598C Nearest vectors：极角排序方法：先判断向量在哪个半区，然后用叉积判断顺序；算两向量夹角时用 atan2 而非 acos 精度更高；开 long double. $\\star\\star$ hdu3629 Convex：给定 $n$ 个点，保证没有三点共线，求能形成多少凸四边形。 $凸四边形数=总四边形数(C_n^4)-凹四边形数$。凹四边形的特征是一个点被一个三角形严格包含在内，所以 $凹四边形数=\\sum包围一个点的三角形数$。而 $包围一个点的三角形数=总三角形数(C_{n-1}^3)-不包含该点的三角形数$。所以问题转化为求不包含一个点的三角形数量。以该点（设为 $O$ ）为参考系按极角排序，双指针扫描——$i$ 指向某点时，$j$ 指向逆时针方向第一个使 $\\angle iOj\\geq\\pi$ 的点，则两指针之间的所有点任取两个与 $i$ 都能形成不含 $O$ 的三角形，可以知道这样做不重不漏。$\\star\\star\\star$ UVA1606 Amphiphilic Carbon Molecules：一定存在过两个点的最优直线，然而枚举两个点显然会超时。现在我们只枚举一个点，其他点关于枚举的点作极角排序（黑点取对称点），双指针扫描一遍，边扫描边统计。$\\star\\star\\star$ CF 1284E New Year and Castle Construction：对于每个点，$包含它的四点集合个数=总个数(C_{n-1}^4)-不包含它的四点集合个数$。所以枚举每个点，以它为参考系极角排序，双指针扫描，两个指针之间所有点任取三个与第一个指针指向的点都能形成不包含原点的四点集合。【与hdu3629极其类似】$\\star\\star\\star$ 多边形 hdu1115 Lifting the Stone：多边形重心模版。 Gym 101808E Floods：积水面积问题。想象从每个点往上引直线，那么积水面积可以分割成一系列三角形和梯形之和。枚举每条边，预处理其前、其后最高点位置，取这两个位置小的那个为积水高度。若积水高度大于当前边的两端高度则是梯形；若一大一小则是三角形；若小于则为零。$\\star\\star\\star$ CF 975E Hag’s Khashba：由于多边形顶点相对位置不会改变，我们只需要记录旋转后的重心位置和第一个顶点位置即可，其他位置可以通过预处理的信息 $O(1)$ 得到。注意实现时尽量少地求角度再旋转该角度，因为求角度用一个 atan 再加上旋转时对它取 sin 和 cos 就会累积出较大误差。$\\star\\star\\star\\star$ 圆 CF 600D Area of Two Circles’ Intersection：注意坐标范围较大，要用 long double. $\\star\\star$ CF 908C New Year and Curling：$\\star$ CF 140A New Year Table：算出角度，精度问题需要 +eps. $\\star$ 闵可夫斯基和 [JSOI2018]战争：会发生战争的条件是：$\\exists a\\in A,b\\in B$ 使得 $b+\\overrightarrow d=a$，即 $\\overrightarrow d=a-b$. 故只需要求出凸包 $A$ 和 $-B$ 的闵可夫斯基和，然后判断 $\\overrightarrow d$ 是否落在和凸包内。判断点在凸包内方法：以凸包左下点为参考系，按照极角序排序，二分出点被哪两个向量夹住，在判断点是否在凸包内。复杂度：$O(n\\lg n)$. $\\star\\star\\star\\star$ 三维几何 Gym 101726C Ekaterinburg Pyramids：一个点能看到四面体某个面的充要条件是：这个点与该面的对点分处面的两侧。判断是否分处两侧可通过判断混合积正负是否相同。$\\star\\star\\star$","link":"/blog-xcpc/2020/04/06/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"tags":[{"name":"ICPC","slug":"ICPC","link":"/blog-xcpc/tags/ICPC/"},{"name":"HDU","slug":"HDU","link":"/blog-xcpc/tags/HDU/"},{"name":"Nowcoder","slug":"Nowcoder","link":"/blog-xcpc/tags/Nowcoder/"},{"name":"AtCoder","slug":"AtCoder","link":"/blog-xcpc/tags/AtCoder/"},{"name":"CCPC","slug":"CCPC","link":"/blog-xcpc/tags/CCPC/"},{"name":"学习笔记","slug":"学习笔记","link":"/blog-xcpc/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Codeforces","slug":"Codeforces","link":"/blog-xcpc/tags/Codeforces/"},{"name":"GMCPC","slug":"GMCPC","link":"/blog-xcpc/tags/GMCPC/"},{"name":"随笔","slug":"随笔","link":"/blog-xcpc/tags/%E9%9A%8F%E7%AC%94/"},{"name":"POI","slug":"POI","link":"/blog-xcpc/tags/POI/"},{"name":"hihoCoder","slug":"hihoCoder","link":"/blog-xcpc/tags/hihoCoder/"}],"categories":[{"name":"ICPC&#x2F;CCPC","slug":"ICPC-CCPC","link":"/blog-xcpc/categories/ICPC-CCPC/"},{"name":"Contests","slug":"ICPC-CCPC/Contests","link":"/blog-xcpc/categories/ICPC-CCPC/Contests/"},{"name":"Exercises","slug":"ICPC-CCPC/Exercises","link":"/blog-xcpc/categories/ICPC-CCPC/Exercises/"},{"name":"其他","slug":"ICPC-CCPC/Contests/其他","link":"/blog-xcpc/categories/ICPC-CCPC/Contests/%E5%85%B6%E4%BB%96/"},{"name":"CCPC","slug":"ICPC-CCPC/Contests/CCPC","link":"/blog-xcpc/categories/ICPC-CCPC/Contests/CCPC/"},{"name":"Notes","slug":"ICPC-CCPC/Notes","link":"/blog-xcpc/categories/ICPC-CCPC/Notes/"},{"name":"Codeforces","slug":"ICPC-CCPC/Contests/Codeforces","link":"/blog-xcpc/categories/ICPC-CCPC/Contests/Codeforces/"},{"name":"ICPC2020","slug":"ICPC-CCPC/Contests/ICPC2020","link":"/blog-xcpc/categories/ICPC-CCPC/Contests/ICPC2020/"},{"name":"随笔","slug":"随笔","link":"/blog-xcpc/categories/%E9%9A%8F%E7%AC%94/"}]}